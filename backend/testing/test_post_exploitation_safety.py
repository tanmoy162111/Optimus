"""Test suite for post-exploitation safety guards"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from inference.tool_manager import ToolManager
from unittest.mock import MagicMock
import time

def test_post_exploitation_safety_without_session():
    """Test: Post-exploitation tools should be blocked without session"""
    print("\n[TEST] Post-Exploitation Safety Without Session")
    print("=" * 60)
    
    socketio = MagicMock()
    manager = ToolManager(socketio)
    
    # Try to execute linpeas without session in post-exploitation phase
    result = manager.execute_tool(
        tool_name='linpeas',
        target='192.168.1.100',
        parameters={'timeout': 300},
        scan_id='test-001',
        phase='post_exploitation'
    )
    
    # Should be blocked
    assert not result['success'], "FAIL: linpeas should be blocked without session"
    assert 'blocked' in result['error'].lower(), "FAIL: Should mention blocking"
    
    print(f"✅ PASS: linpeas correctly blocked without session")
    print(f"  Error: {result['error']}")
    
    return True

def test_post_exploitation_safety_with_invalid_session():
    """Test: Post-exploitation tools should be blocked with invalid session"""
    print("\n[TEST] Post-Exploitation Safety With Invalid Session")
    print("=" * 60)
    
    socketio = MagicMock()
    manager = ToolManager(socketio)
    
    # Try to execute winpeas with invalid session ID
    result = manager.execute_tool(
        tool_name='winpeas',
        target='192.168.1.100',
        parameters={'timeout': 300, 'session_id': 'abc'},  # Too short
        scan_id='test-002',
        phase='post_exploitation'
    )
    
    # Should be blocked
    assert not result['success'], "FAIL: winpeas should be blocked with invalid session"
    assert 'blocked' in result['error'].lower(), "FAIL: Should mention blocking"
    
    print(f"✅ PASS: winpeas correctly blocked with invalid session")
    print(f"  Error: {result['error']}")
    
    return True

def test_post_exploitation_safety_with_valid_session():
    """Test: Post-exploitation tools should work with valid session"""
    print("\n[TEST] Post-Exploitation Safety With Valid Session")
    print("=" * 60)
    
    socketio = MagicMock()
    manager = ToolManager(socketio)
    
    # Try to execute linpeas with valid session ID
    result = manager.execute_tool(
        tool_name='echo',  # Use echo for testing to avoid actual execution
        target='test',
        parameters={'timeout': 30, 'session_id': 'valid_session_id_123'},
        scan_id='test-003',
        phase='post_exploitation'
    )
    
    # For this test, we're just checking that it passes the safety check
    # The actual execution will fail because we're using 'echo' but that's OK
    # The important thing is that it doesn't get blocked by safety checks
    if 'blocked' not in result.get('error', '').lower():
        print(f"✅ PASS: Tool passed safety checks with valid session")
        return True
    else:
        print(f"❌ FAIL: Tool blocked despite valid session")
        print(f"  Error: {result.get('error', 'No error message')}")
        return False

def test_post_exploitation_rate_limiting():
    """Test: Post-exploitation tools should be rate limited"""
    print("\n[TEST] Post-Exploitation Rate Limiting")
    print("=" * 60)
    
    socketio = MagicMock()
    manager = ToolManager(socketio)
    
    # Execute 11 tools rapidly to trigger rate limit
    blocked_count = 0
    for i in range(11):
        result = manager.execute_tool(
            tool_name='echo',
            target=f'test-{i}',
            parameters={'timeout': 30, 'session_id': f'session_{i}'},
            scan_id=f'test-rate-{i}',
            phase='post_exploitation'
        )
        
        if 'blocked' in result.get('error', '').lower() and 'rate' in result.get('error', '').lower():
            blocked_count += 1
    
    # At least one should be blocked (likely the 11th)
    assert blocked_count >= 1, "FAIL: Rate limiting not working - no tools were blocked"
    
    print(f"✅ PASS: Rate limiting working - {blocked_count}/11 tools blocked")
    
    return True

def test_timeout_restrictions():
    """Test: Post-exploitation tools should respect timeout restrictions"""
    print("\n[TEST] Timeout Restrictions")
    print("=" * 60)
    
    socketio = MagicMock()
    manager = ToolManager(socketio)
    
    # Try to execute linpeas with excessive timeout
    result = manager.execute_tool(
        tool_name='linpeas',
        target='192.168.1.100',
        parameters={'timeout': 900, 'session_id': 'valid_session_id_123'},  # 15 minutes
        scan_id='test-004',
        phase='post_exploitation'
    )
    
    # Should be blocked due to timeout restriction
    assert not result['success'], "FAIL: linpeas should be blocked with excessive timeout"
    assert 'blocked' in result['error'].lower(), "FAIL: Should mention blocking"
    
    print(f"✅ PASS: linpeas correctly blocked due to timeout restriction")
    print(f"  Error: {result['error']}")
    
    return True

def run_all_tests():
    """Run all post-exploitation safety tests"""
    print("\n" + "=" * 60)
    print("POST-EXPLOITATION SAFETY GUARD TEST SUITE")
    print("=" * 60)
    
    tests = [
        ("Without Session", test_post_exploitation_safety_without_session),
        ("With Invalid Session", test_post_exploitation_safety_with_invalid_session),
        ("With Valid Session", test_post_exploitation_safety_with_valid_session),
        ("Rate Limiting", test_post_exploitation_rate_limiting),
        ("Timeout Restrictions", test_timeout_restrictions),
    ]
    
    results = []
    for name, test_func in tests:
        try:
            result = test_func()
            results.append((name, result))
        except Exception as e:
            print(f"❌ FAIL: {name} - {e}")
            import traceback
            traceback.print_exc()
            results.append((name, False))
    
    # Summary
    print("\n" + "=" * 60)
    print("TEST SUMMARY")
    print("=" * 60)
    passed = sum(1 for _, r in results if r)
    total = len(results)
    
    for name, result in results:
        status = "✅ PASS" if result else "❌ FAIL"
        print(f"{status} - {name}")
    
    print(f"\nTotal: {passed}/{total} tests passed ({passed/total*100:.0f}%)")
    print("=" * 60)
    
    return passed == total

if __name__ == '__main__':
    success = run_all_tests()
    sys.exit(0 if success else 1)