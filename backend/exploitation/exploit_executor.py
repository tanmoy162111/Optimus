"""
Exploit Executor

Safely executes exploits with:
- Pre-execution validation
- Sandbox testing (when possible)
- Result parsing and validation
- Feedback for learning

Integration Points:
- autonomous_agent.py: Called during exploitation phase
- tool_manager.py: Uses SSH client for execution
- adaptive_exploitation.py: Provides feedback for adaptation
"""

import logging
import re
import time
import asyncio
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from .exploit_db import ExploitTemplate

logger = logging.getLogger(__name__)


class ExploitStatus(Enum):
    """Status of exploit execution"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    PARTIAL = "partial"  # Some success, not complete
    FAILED = "failed"
    BLOCKED = "blocked"  # WAF/IPS blocked
    TIMEOUT = "timeout"
    ERROR = "error"


@dataclass
class ExploitResult:
    """Result of exploit execution"""
    exploit_id: str
    status: ExploitStatus
    command: str
    output: str
    execution_time: float
    success_indicators_found: List[str] = field(default_factory=list)
    failure_indicators_found: List[str] = field(default_factory=list)
    extracted_data: Dict[str, Any] = field(default_factory=dict)
    shell_obtained: bool = False
    credentials_found: List[Dict[str, str]] = field(default_factory=list)
    files_accessed: List[str] = field(default_factory=list)
    error_message: str = ""
    recommendations: List[str] = field(default_factory=list)
    timestamp: str = ""
    
    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = datetime.now().isoformat()
    
    @property
    def is_success(self) -> bool:
        """Check if execution was successful"""
        return self.status in [ExploitStatus.SUCCESS, ExploitStatus.PARTIAL]
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "exploit_id": self.exploit_id,
            "status": self.status.value,
            "command": self.command,
            "output": self.output[:5000] if self.output else "",  # Truncate long output
            "execution_time": self.execution_time,
            "success_indicators_found": self.success_indicators_found,
            "failure_indicators_found": self.failure_indicators_found,
            "extracted_data": self.extracted_data,
            "shell_obtained": self.shell_obtained,
            "credentials_found": self.credentials_found,
            "files_accessed": self.files_accessed,
            "error_message": self.error_message,
            "recommendations": self.recommendations,
            "timestamp": self.timestamp,
        }
    
    def to_finding(self) -> Dict[str, Any]:
        """Convert to a vulnerability finding format"""
        severity = "critical" if self.shell_obtained else "high" if self.is_success else "medium"
        
        return {
            "type": "exploit_result",
            "exploit_id": self.exploit_id,
            "severity": severity,
            "description": f"Exploit {self.exploit_id} - {self.status.value}",
            "evidence": self.output[:1000] if self.output else "",
            "extracted_data": self.extracted_data,
            "credentials": self.credentials_found,
            "shell_obtained": self.shell_obtained,
            "timestamp": self.timestamp,
        }


class ExploitExecutor:
    """
    Executes exploits safely with validation and feedback.
    
    Usage:
        executor = ExploitExecutor(tool_manager)
        
        # Execute exploit template
        result = await executor.execute_template(
            template=exploit_template,
            context={"target": "http://vulnerable.com", "lhost": "10.10.14.1"}
        )
        
        # Execute raw command
        result = await executor.execute_command(
            command="sqlmap -u 'http://target/page?id=1' --batch --dbs",
            exploit_id="sqli_test",
            success_indicators=["available databases"],
            timeout=300
        )
    """
    
    def __init__(self, tool_manager=None):
        """
        Initialize exploit executor.
        
        Args:
            tool_manager: ToolManager instance for SSH execution
        """
        self.tool_manager = tool_manager
        
        # Execution history for learning
        self.execution_history: List[ExploitResult] = []
        
        # Dangerous command patterns to block
        self.dangerous_patterns = [
            r'rm\s+-rf\s+/',  # rm -rf /
            r'mkfs\.',  # Format disk
            r'dd\s+if=.*of=/dev/',  # Overwrite disk
            r':\(\)\{:\|:&\};:',  # Fork bomb
            r'>\s*/dev/sd[a-z]',  # Overwrite disk
        ]
        
        # Patterns for data extraction
        self._init_extraction_patterns()
        
        logger.info("[ExploitExecutor] Initialized")
    
    def _init_extraction_patterns(self):
        """Initialize patterns for extracting data from exploit output"""
        
        self.credential_patterns = [
            # Username:password format
            (r'(?:user(?:name)?|login|admin)\s*[:=]\s*([^\s:]+)\s+(?:pass(?:word)?|pwd)\s*[:=]\s*([^\s]+)', 
             'username_password'),
            # email:password
            (r'([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)\s*[:=]\s*([^\s]+)',
             'email_password'),
            # Unix hash (user:$hash)
            (r'([a-zA-Z0-9_]+):(\$[0-9a-z]\$[^\s:]+)',
             'unix_hash'),
            # MD5 hash
            (r'([a-zA-Z0-9_]+):([a-f0-9]{32})(?:\s|$)',
             'md5_hash'),
            # SHA256 hash
            (r'([a-zA-Z0-9_]+):([a-f0-9]{64})(?:\s|$)',
             'sha256_hash'),
            # MySQL old password
            (r'([a-zA-Z0-9_]+):([a-f0-9]{16})(?:\s|$)',
             'mysql_old'),
            # Generic user:pass in output
            (r"'([^']+)'\s*,\s*'([^']+)'",
             'quoted_creds'),
        ]
        
        self.database_patterns = [
            r'Database:\s*[`\']?(\w+)[`\']?',
            r'current database:\s*[\'"`]?(\w+)[\'"`]?',
            r'\[INFO\]\s+the back-end DBMS is\s+(\w+)',
            r'available databases.*?:\s*([\w\s,]+)',
        ]
        
        self.table_patterns = [
            r'Table:\s*[`\']?(\w+)[`\']?',
            r'\|\s*(\w+)\s*\|',
            r'table_name[:\s]+[`\']?(\w+)[`\']?',
        ]
        
        self.version_patterns = [
            r'version[:\s]+([0-9]+\.[0-9]+[^\s]*)',
            r'(\d+\.\d+\.\d+(?:-\w+)?)',
            r'Server:\s*([^\r\n]+)',
        ]
        
        self.file_content_patterns = [
            (r'(root:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^\n]+)', 'passwd_root'),
            (r'(www-data:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^\n]+)', 'passwd_www'),
            (r'(<\?php[\s\S]{0,500})', 'php_code'),
            (r'(BEGIN RSA PRIVATE KEY[\s\S]+END RSA PRIVATE KEY)', 'private_key'),
            (r'(ssh-rsa\s+[A-Za-z0-9+/=]+)', 'ssh_public_key'),
        ]
        
        self.shell_indicators = [
            r'uid=(\d+)\(([^)]+)\)\s+gid=(\d+)\(([^)]+)\)',  # id command
            r'(www-data|root|admin|apache|nginx)[@\$#]',  # Shell prompt
            r'whoami\s*\n\s*(\w+)',
            r'pseudo-terminal',
            r'interactive shell',
            r'got shell',
            r'meterpreter\s*>',
        ]
        
        self.waf_indicators = [
            r'403\s+forbidden',
            r'access\s+denied',
            r'blocked\s+by',
            r'web\s+application\s+firewall',
            r'mod_security',
            r'cloudflare',
            r'request\s+rejected',
            r'security\s+violation',
            r'attack\s+detected',
        ]
        
        self.error_indicators = [
            r'connection\s+refused',
            r'connection\s+timed?\s*out',
            r'host\s+unreachable',
            r'name\s+or\s+service\s+not\s+known',
            r'no\s+route\s+to\s+host',
            r'permission\s+denied',
            r'authentication\s+failed',
        ]
    
    async def execute_template(
        self,
        template: 'ExploitTemplate',
        context: Dict[str, Any],
        timeout: int = 300,
        validate_before: bool = True
    ) -> ExploitResult:
        """
        Execute an exploit template.
        
        Args:
            template: ExploitTemplate from exploit_db
            context: Execution context with target, parameters, etc.
            timeout: Maximum execution time in seconds
            validate_before: Whether to validate command before execution
            
        Returns:
            ExploitResult with execution details
        """
        # Build command from template
        command = template.build_command(context)
        
        # Execute with template's indicators
        return await self.execute_command(
            command=command,
            exploit_id=template.exploit_id,
            success_indicators=template.success_indicators,
            failure_indicators=template.failure_indicators,
            timeout=timeout,
            validate_before=validate_before,
            dangerous_allowed=template.dangerous
        )
    
    async def execute_command(
        self,
        command: str,
        exploit_id: str,
        success_indicators: List[str] = None,
        failure_indicators: List[str] = None,
        timeout: int = 300,
        validate_before: bool = True,
        dangerous_allowed: bool = False
    ) -> ExploitResult:
        """
        Execute a raw exploit command.
        
        Args:
            command: Command to execute
            exploit_id: Identifier for this exploit
            success_indicators: Patterns indicating success
            failure_indicators: Patterns indicating failure
            timeout: Maximum execution time
            validate_before: Validate command safety
            dangerous_allowed: Allow dangerous commands
            
        Returns:
            ExploitResult with execution details
        """
        start_time = time.time()
        success_indicators = success_indicators or []
        failure_indicators = failure_indicators or []
        
        # Validate command safety
        if validate_before and not dangerous_allowed:
            is_safe, reason = self._validate_command(command)
            if not is_safe:
                return ExploitResult(
                    exploit_id=exploit_id,
                    status=ExploitStatus.ERROR,
                    command=command,
                    output="",
                    execution_time=0,
                    error_message=f"Command blocked: {reason}",
                    recommendations=["Review command for safety issues"]
                )
        
        # Execute command
        try:
            output = await self._execute_via_tool_manager(command, timeout)
            execution_time = time.time() - start_time
            
            # Analyze results
            result = self._analyze_output(
                output=output,
                exploit_id=exploit_id,
                command=command,
                execution_time=execution_time,
                success_indicators=success_indicators,
                failure_indicators=failure_indicators
            )
            
            # Store in history
            self.execution_history.append(result)
            
            return result
            
        except asyncio.TimeoutError:
            return ExploitResult(
                exploit_id=exploit_id,
                status=ExploitStatus.TIMEOUT,
                command=command,
                output="",
                execution_time=timeout,
                error_message=f"Execution timed out after {timeout}s",
                recommendations=["Increase timeout", "Try faster technique"]
            )
        except Exception as e:
            logger.error(f"[ExploitExecutor] Error executing {exploit_id}: {e}")
            return ExploitResult(
                exploit_id=exploit_id,
                status=ExploitStatus.ERROR,
                command=command,
                output="",
                execution_time=time.time() - start_time,
                error_message=str(e),
                recommendations=["Check target connectivity", "Verify tool installation"]
            )
    
    async def _execute_via_tool_manager(self, command: str, timeout: int) -> str:
        """Execute command via tool manager's SSH connection"""
        if self.tool_manager is None:
            # Fallback to local execution for testing
            logger.warning("[ExploitExecutor] No tool_manager, using local execution")
            return await self._execute_local(command, timeout)
        
        try:
            # Use tool_manager's execute_tool method
            result = self.tool_manager.execute_tool_direct(command, timeout=timeout)
            return result.get('output', '') if isinstance(result, dict) else str(result)
        except Exception as e:
            logger.error(f"[ExploitExecutor] Tool manager execution failed: {e}")
            raise
    
    async def _execute_local(self, command: str, timeout: int) -> str:
        """Execute command locally (for testing)"""
        import subprocess
        
        try:
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            
            return stdout.decode('utf-8', errors='replace') + stderr.decode('utf-8', errors='replace')
        except asyncio.TimeoutError:
            process.kill()
            raise
    
    def _validate_command(self, command: str) -> Tuple[bool, str]:
        """
        Validate command is safe to execute.
        
        Returns:
            Tuple of (is_safe, reason)
        """
        command_lower = command.lower()
        
        # Check for dangerous patterns
        for pattern in self.dangerous_patterns:
            if re.search(pattern, command_lower):
                return False, f"Dangerous pattern detected: {pattern}"
        
        # Check for obviously destructive commands
        destructive_commands = ['rm -rf /', 'mkfs', '> /dev/sd', 'dd if=']
        for dc in destructive_commands:
            if dc in command_lower:
                return False, f"Destructive command detected: {dc}"
        
        return True, "Command validated"
    
    def _analyze_output(
        self,
        output: str,
        exploit_id: str,
        command: str,
        execution_time: float,
        success_indicators: List[str],
        failure_indicators: List[str]
    ) -> ExploitResult:
        """Analyze exploit output and extract data"""
        
        output_lower = output.lower()
        
        # Check for WAF/blocking
        waf_found = []
        for pattern in self.waf_indicators:
            if re.search(pattern, output_lower):
                waf_found.append(pattern)
        
        if waf_found:
            return ExploitResult(
                exploit_id=exploit_id,
                status=ExploitStatus.BLOCKED,
                command=command,
                output=output,
                execution_time=execution_time,
                failure_indicators_found=waf_found,
                error_message="Blocked by WAF/security system",
                recommendations=[
                    "Try WAF bypass techniques",
                    "Use encoding/obfuscation",
                    "Try alternative exploit"
                ]
            )
        
        # Check for errors
        errors_found = []
        for pattern in self.error_indicators:
            if re.search(pattern, output_lower):
                errors_found.append(pattern)
        
        if errors_found and not success_indicators:
            return ExploitResult(
                exploit_id=exploit_id,
                status=ExploitStatus.ERROR,
                command=command,
                output=output,
                execution_time=execution_time,
                failure_indicators_found=errors_found,
                error_message="Connection/execution error",
                recommendations=[
                    "Check target connectivity",
                    "Verify target is up",
                    "Check network path"
                ]
            )
        
        # Check success indicators
        success_found = []
        for indicator in success_indicators:
            if indicator.lower() in output_lower:
                success_found.append(indicator)
        
        # Check failure indicators
        failure_found = []
        for indicator in failure_indicators:
            if indicator.lower() in output_lower:
                failure_found.append(indicator)
        
        # Check for shell
        shell_obtained = False
        for pattern in self.shell_indicators:
            if re.search(pattern, output, re.IGNORECASE):
                shell_obtained = True
                success_found.append("shell_indicator")
                break
        
        # Extract data
        extracted_data = self._extract_data(output)
        credentials = self._extract_credentials(output)
        files = self._extract_files(output)
        
        # Determine status
        if shell_obtained:
            status = ExploitStatus.SUCCESS
        elif success_found and not failure_found:
            status = ExploitStatus.SUCCESS
        elif success_found and failure_found:
            status = ExploitStatus.PARTIAL
        elif failure_found:
            status = ExploitStatus.FAILED
        elif extracted_data or credentials:
            status = ExploitStatus.PARTIAL
        else:
            status = ExploitStatus.FAILED
        
        # Generate recommendations
        recommendations = self._generate_recommendations(
            status=status,
            shell_obtained=shell_obtained,
            credentials=credentials,
            extracted_data=extracted_data
        )
        
        return ExploitResult(
            exploit_id=exploit_id,
            status=status,
            command=command,
            output=output,
            execution_time=execution_time,
            success_indicators_found=success_found,
            failure_indicators_found=failure_found,
            extracted_data=extracted_data,
            shell_obtained=shell_obtained,
            credentials_found=credentials,
            files_accessed=files,
            recommendations=recommendations
        )
    
    def _extract_data(self, output: str) -> Dict[str, Any]:
        """Extract structured data from output"""
        data = {}
        
        # Extract databases
        databases = []
        for pattern in self.database_patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            if matches:
                if isinstance(matches[0], str):
                    databases.extend(matches)
                else:
                    databases.extend([m[0] if isinstance(m, tuple) else m for m in matches])
        if databases:
            data['databases'] = list(set(databases))
        
        # Extract tables
        tables = []
        for pattern in self.table_patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            if matches:
                tables.extend(matches)
        if tables:
            data['tables'] = list(set(tables))[:50]  # Limit
        
        # Extract versions
        versions = []
        for pattern in self.version_patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            if matches:
                versions.extend(matches)
        if versions:
            data['versions'] = list(set(versions))[:10]
        
        # Extract file contents
        for pattern, label in self.file_content_patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            if matches:
                data[label] = matches[0][:500]  # Truncate
        
        return data
    
    def _extract_credentials(self, output: str) -> List[Dict[str, str]]:
        """Extract credentials from output"""
        credentials = []
        seen = set()
        
        for pattern, cred_type in self.credential_patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            for match in matches:
                if len(match) >= 2:
                    username, password = match[0], match[1]
                    key = f"{username}:{password}"
                    
                    if key not in seen and len(username) > 1 and len(password) > 1:
                        seen.add(key)
                        credentials.append({
                            'username': username,
                            'password': password,
                            'type': cred_type
                        })
        
        return credentials[:20]  # Limit
    
    def _extract_files(self, output: str) -> List[str]:
        """Extract accessed file paths from output"""
        files = []
        
        # Common file path patterns
        patterns = [
            r'/etc/passwd',
            r'/etc/shadow',
            r'/etc/hosts',
            r'/var/log/[\w/]+',
            r'/home/[\w]+/[\w.]+',
            r'/root/[\w.]+',
            r'/var/www/[\w/]+',
            r'C:\\[\w\\]+',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            files.extend(matches)
        
        return list(set(files))[:20]
    
    def _generate_recommendations(
        self,
        status: ExploitStatus,
        shell_obtained: bool,
        credentials: List[Dict],
        extracted_data: Dict
    ) -> List[str]:
        """Generate recommendations based on results"""
        recommendations = []
        
        if shell_obtained:
            recommendations.extend([
                "Stabilize shell (python -c 'import pty;pty.spawn(\"/bin/bash\")')",
                "Run privilege escalation enumeration (linpeas/winpeas)",
                "Check for lateral movement opportunities",
                "Establish persistence"
            ])
        elif status == ExploitStatus.SUCCESS:
            if credentials:
                recommendations.extend([
                    "Try credentials on other services (SSH, FTP, RDP)",
                    "Check for password reuse across accounts",
                    "Attempt to crack hashes if found"
                ])
            if 'databases' in extracted_data:
                recommendations.extend([
                    "Enumerate database tables",
                    "Look for sensitive data (users, configs)",
                    "Check for stored procedures with elevated privileges"
                ])
        elif status == ExploitStatus.PARTIAL:
            recommendations.extend([
                "Increase exploit level/risk",
                "Try alternative techniques",
                "Enumerate further before next attempt"
            ])
        elif status == ExploitStatus.FAILED:
            recommendations.extend([
                "Verify vulnerability exists",
                "Check exploit compatibility with target version",
                "Try different exploit for same vulnerability"
            ])
        elif status == ExploitStatus.BLOCKED:
            recommendations.extend([
                "Apply WAF bypass techniques",
                "Use encoding (base64, URL, unicode)",
                "Try time-based/out-of-band techniques",
                "Reduce scan aggressiveness"
            ])
        
        return recommendations
    
    def get_success_rate(self, exploit_id: str = None) -> float:
        """Get success rate for an exploit or overall"""
        if not self.execution_history:
            return 0.0
        
        relevant = self.execution_history
        if exploit_id:
            relevant = [r for r in relevant if r.exploit_id == exploit_id]
        
        if not relevant:
            return 0.0
        
        successes = sum(1 for r in relevant if r.is_success)
        return successes / len(relevant)
    
    def get_execution_stats(self) -> Dict[str, Any]:
        """Get execution statistics"""
        if not self.execution_history:
            return {"total": 0}
        
        status_counts = {}
        for result in self.execution_history:
            status = result.status.value
            status_counts[status] = status_counts.get(status, 0) + 1
        
        total_time = sum(r.execution_time for r in self.execution_history)
        shells_obtained = sum(1 for r in self.execution_history if r.shell_obtained)
        creds_found = sum(len(r.credentials_found) for r in self.execution_history)
        
        return {
            "total": len(self.execution_history),
            "status_counts": status_counts,
            "success_rate": self.get_success_rate(),
            "total_execution_time": total_time,
            "avg_execution_time": total_time / len(self.execution_history),
            "shells_obtained": shells_obtained,
            "credentials_found": creds_found,
        }
    
    def clear_history(self):
        """Clear execution history"""
        self.execution_history = []


# Singleton instance
_exploit_executor: Optional[ExploitExecutor] = None


def get_exploit_executor(tool_manager=None) -> ExploitExecutor:
    """Get singleton ExploitExecutor instance"""
    global _exploit_executor
    if _exploit_executor is None:
        _exploit_executor = ExploitExecutor(tool_manager)
    elif tool_manager is not None and _exploit_executor.tool_manager is None:
        _exploit_executor.tool_manager = tool_manager
    return _exploit_executor
