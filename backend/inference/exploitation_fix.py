"""
Exploitation Phase Fix Module

This module provides fixes for:
1. Exploitation phase not executing tools
2. Post-exploitation being skipped
3. Better finding classification for exploitation

Key issues identified:
- _get_exploitable_findings() was too strict
- Findings from parsers don't always have exploitable types
- Post-exploitation requires sessions but we rarely get them

Solution:
- Broaden exploitable types detection
- Always run basic exploitation tools on findings
- Run post-exploitation tools even without sessions (for reconnaissance)
"""

import re
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


def get_enhanced_exploitable_findings(findings: List[Dict]) -> List[Dict]:
    """
    Enhanced version of _get_exploitable_findings that catches more vulnerabilities.
    
    The original version was too strict - many parser outputs don't use
    standard vulnerability type names.
    """
    # Expanded exploitable patterns
    exploitable_patterns = [
        # SQL Injection variants
        r'sql.*inject', r'sqli', r'\bsql\b', r'blind.*sql', r'union.*select',
        r'database', r'mysql', r'postgres', r'oracle', r'mssql',
        
        # Command/Code Injection
        r'command.*inject', r'cmd.*inject', r'rce', r'remote.*code',
        r'os.*command', r'shell.*inject', r'code.*execution',
        
        # XSS variants
        r'xss', r'cross.*site.*script', r'reflected', r'stored.*xss',
        r'dom.*xss', r'script.*inject',
        
        # File-based
        r'file.*inclus', r'lfi', r'rfi', r'path.*travers', r'directory.*travers',
        r'file.*upload', r'unrestrict.*upload', r'arbitrary.*file',
        
        # Authentication
        r'auth.*bypass', r'broken.*auth', r'session.*hijack', r'privilege.*escal',
        r'access.*control', r'idor', r'insecure.*direct',
        
        # Injection variants
        r'inject', r'ldap.*inject', r'xpath.*inject', r'xml.*inject',
        r'ssti', r'template.*inject', r'expression.*language',
        
        # Other critical
        r'ssrf', r'xxe', r'deserializ', r'open.*redirect',
        r'crlf', r'header.*inject', r'http.*split',
        
        # Generic high severity
        r'critical', r'remote', r'exploit', r'vulnerable',
    ]
    
    exploitable = []
    seen_locations = set()  # Avoid duplicates
    
    for finding in findings:
        # Get all text fields to search
        vuln_type = str(finding.get('type', '')).lower()
        vuln_name = str(finding.get('name', '')).lower()
        evidence = str(finding.get('evidence', '')).lower()
        location = str(finding.get('location', finding.get('url', '')))
        severity = finding.get('severity', 0)
        
        # Create search text
        search_text = f"{vuln_type} {vuln_name} {evidence}"
        
        # Check patterns
        is_exploitable = False
        
        for pattern in exploitable_patterns:
            if re.search(pattern, search_text, re.IGNORECASE):
                is_exploitable = True
                break
        
        # Also include high severity findings
        if severity >= 6.0:
            is_exploitable = True
        
        # Also include if marked exploitable
        if finding.get('exploitable', False):
            is_exploitable = True
        
        # Add if exploitable and not duplicate location
        if is_exploitable:
            loc_key = f"{location}:{vuln_type}"
            if loc_key not in seen_locations:
                seen_locations.add(loc_key)
                exploitable.append(finding)
    
    # Sort by severity
    exploitable.sort(key=lambda x: x.get('severity', 0), reverse=True)
    
    logger.info(f"[ExploitationFix] Found {len(exploitable)} exploitable findings from {len(findings)} total")
    
    return exploitable


def classify_finding_for_exploitation(finding: Dict) -> Dict[str, Any]:
    """
    Classify a finding and determine appropriate exploitation tools.
    
    Returns dict with:
    - exploit_type: sql, xss, cmd, file, auth, other
    - tools: list of tools to use
    - payloads: suggested payloads
    - priority: 1-5 (1 = highest)
    """
    vuln_type = str(finding.get('type', '')).lower()
    vuln_name = str(finding.get('name', '')).lower()
    evidence = str(finding.get('evidence', '')).lower()
    location = finding.get('location', finding.get('url', ''))
    
    combined = f"{vuln_type} {vuln_name} {evidence}"
    
    classification = {
        'exploit_type': 'other',
        'tools': [],
        'priority': 5,
        'parameters': {},
    }
    
    # SQL Injection
    if re.search(r'sql|database|mysql|inject.*query', combined):
        classification['exploit_type'] = 'sql'
        classification['tools'] = ['sqlmap']
        classification['priority'] = 1
        classification['parameters'] = {
            'sqlmap': {
                'target': location,
                'args': '--batch --level=3 --risk=2 --dbs'
            }
        }
    
    # XSS
    elif re.search(r'xss|cross.*site|script.*inject|reflected', combined):
        classification['exploit_type'] = 'xss'
        classification['tools'] = ['dalfox']
        classification['priority'] = 2
        classification['parameters'] = {
            'dalfox': {
                'target': location,
                'args': '--skip-bav --blind'
            }
        }
    
    # Command Injection
    elif re.search(r'command|cmd|rce|shell|os.*inject', combined):
        classification['exploit_type'] = 'cmd'
        classification['tools'] = ['commix']
        classification['priority'] = 1
        classification['parameters'] = {
            'commix': {
                'target': location,
                'args': '--batch --all'
            }
        }
    
    # File Inclusion/Path Traversal
    elif re.search(r'file.*inclu|lfi|rfi|path.*travers|directory', combined):
        classification['exploit_type'] = 'file'
        classification['tools'] = ['curl']  # Manual testing with curl
        classification['priority'] = 2
        classification['parameters'] = {
            'curl': {
                'target': location,
                'args': '-s --path-as-is'
            }
        }
    
    # Authentication Issues
    elif re.search(r'auth|session|access.*control|idor|privilege', combined):
        classification['exploit_type'] = 'auth'
        classification['tools'] = ['curl', 'hydra']
        classification['priority'] = 2
    
    # SSRF
    elif re.search(r'ssrf|server.*side.*request', combined):
        classification['exploit_type'] = 'ssrf'
        classification['tools'] = ['curl']
        classification['priority'] = 1
    
    # XXE
    elif re.search(r'xxe|xml.*external|xml.*inject', combined):
        classification['exploit_type'] = 'xxe'
        classification['tools'] = ['curl']
        classification['priority'] = 1
    
    # Default - try common tools
    else:
        classification['tools'] = ['nuclei', 'curl']
        classification['priority'] = 4
    
    return classification


def get_exploitation_commands(finding: Dict, target: str) -> List[Dict[str, str]]:
    """
    Generate specific exploitation commands for a finding.
    
    Returns list of {tool, command, description}
    """
    classification = classify_finding_for_exploitation(finding)
    commands = []
    
    location = finding.get('location', finding.get('url', target))
    param = finding.get('parameter', finding.get('param', ''))
    
    # Ensure URL format
    if location and not location.startswith('http'):
        location = f"http://{location}"
    
    exploit_type = classification['exploit_type']
    
    if exploit_type == 'sql':
        # SQLMap commands
        if param:
            commands.append({
                'tool': 'sqlmap',
                'command': f"sqlmap -u '{location}' -p '{param}' --batch --level=3 --risk=2 --dbs",
                'description': f"SQL Injection exploitation on parameter {param}"
            })
        else:
            commands.append({
                'tool': 'sqlmap',
                'command': f"sqlmap -u '{location}' --batch --forms --crawl=2 --level=2 --risk=2",
                'description': "SQL Injection exploitation with form discovery"
            })
    
    elif exploit_type == 'xss':
        commands.append({
            'tool': 'dalfox',
            'command': f"dalfox url '{location}' --skip-bav",
            'description': "XSS vulnerability exploitation"
        })
    
    elif exploit_type == 'cmd':
        commands.append({
            'tool': 'commix',
            'command': f"commix --url='{location}' --batch --all",
            'description': "Command injection exploitation"
        })
        # Also try curl for manual verification
        commands.append({
            'tool': 'curl',
            'command': f"curl -s '{location}' --data 'test=;id'",
            'description': "Manual command injection test"
        })
    
    elif exploit_type == 'file':
        # LFI/RFI tests
        commands.append({
            'tool': 'curl',
            'command': f"curl -s '{location}' --path-as-is",
            'description': "File inclusion verification"
        })
    
    elif exploit_type == 'ssrf':
        commands.append({
            'tool': 'curl',
            'command': f"curl -s '{location}'",
            'description': "SSRF exploitation attempt"
        })
    
    # Always add nuclei as fallback
    commands.append({
        'tool': 'nuclei',
        'command': f"nuclei -u '{location}' -severity critical,high -as",
        'description': "Automated vulnerability verification"
    })
    
    return commands


def should_run_post_exploitation(scan_state: Dict) -> bool:
    """
    Determine if post-exploitation should run.
    
    CHANGED: Run post-exploitation even without sessions
    for information gathering purposes.
    """
    # Always run if we have high severity findings
    findings = scan_state.get('findings', [])
    high_sev = [f for f in findings if f.get('severity', 0) >= 7.0]
    
    if high_sev:
        logger.info(f"[ExploitationFix] Running post-exploitation due to {len(high_sev)} high-severity findings")
        return True
    
    # Run if we have any sessions
    if scan_state.get('sessions_obtained'):
        return True
    
    # Run if we have credentials
    if scan_state.get('credentials_found'):
        return True
    
    # Run if exploitation attempted anything
    if scan_state.get('exploits_attempted'):
        return True
    
    # Default: run if we have any findings at all
    if findings:
        logger.info("[ExploitationFix] Running minimal post-exploitation for reconnaissance")
        return True
    
    return False


def get_post_exploitation_tools(scan_state: Dict) -> List[Dict[str, str]]:
    """
    Get post-exploitation tools to run based on context.
    
    Even without shell access, we can run:
    - Additional enumeration
    - Credential harvesting attempts
    - Data exfiltration tests
    """
    tools = []
    target = scan_state.get('target', '')
    
    # Basic enumeration (always useful)
    tools.append({
        'tool': 'curl',
        'command': f"curl -s '{target}/robots.txt' '{target}/sitemap.xml' '{target}/.git/config' '{target}/.env'",
        'description': "Sensitive file enumeration"
    })
    
    # Check for exposed admin panels
    tools.append({
        'tool': 'curl',
        'command': f"curl -s -o /dev/null -w '%{{http_code}}' '{target}/admin' '{target}/administrator' '{target}/wp-admin'",
        'description': "Admin panel detection"
    })
    
    # If we have sessions, add more aggressive tools
    if scan_state.get('sessions_obtained'):
        tools.append({
            'tool': 'linpeas',
            'command': 'linpeas.sh -a 2>/dev/null',
            'description': "Linux privilege escalation enumeration"
        })
    
    # Check for data exposure
    tools.append({
        'tool': 'curl',
        'command': f"curl -s '{target}/api/' '{target}/api/v1/' '{target}/graphql'",
        'description': "API endpoint enumeration"
    })
    
    return tools


# Export functions for use in orchestrator
__all__ = [
    'get_enhanced_exploitable_findings',
    'classify_finding_for_exploitation', 
    'get_exploitation_commands',
    'should_run_post_exploitation',
    'get_post_exploitation_tools',
]
