"""
Vulnerability Knowledge Base
Stores exploitation techniques, reproduction templates, and remediation knowledge
"""

import json
import os
from typing import Dict, Any, List


class VulnerabilityKnowledgeBase:
    """
    Central repository of vulnerability knowledge for accurate reporting and guidance
    """

    def __init__(self):
        self.knowledge_base = self._load_knowledge_base()
        
    def _load_knowledge_base(self) -> Dict[str, Any]:
        """
        Load vulnerability knowledge from JSON files
        """
        # Create knowledge directory if it doesn't exist
        knowledge_dir = os.path.join(os.path.dirname(__file__), 'data')
        os.makedirs(knowledge_dir, exist_ok=True)
        
        # Default knowledge base structure
        kb = {
            'exploitation_techniques': {},
            'reproduction_templates': {},
            'remediation_knowledge': {},
            'cve_mapping': {},
            'cwe_mapping': {},
            'owasp_mapping': {}
        }
        
        # Load from files if they exist
        for key in kb.keys():
            file_path = os.path.join(knowledge_dir, f'{key}.json')
            if os.path.exists(file_path):
                try:
                    with open(file_path, 'r') as f:
                        kb[key] = json.load(f)
                except Exception as e:
                    print(f"Warning: Could not load {file_path}: {e}")
        
        # Initialize with some default knowledge if empty
        if not kb['exploitation_techniques']:
            kb['exploitation_techniques'] = self._get_default_exploitation_techniques()
            
        if not kb['reproduction_templates']:
            kb['reproduction_templates'] = self._get_default_reproduction_templates()
            
        if not kb['remediation_knowledge']:
            kb['remediation_knowledge'] = self._get_default_remediation_knowledge()
            
        return kb
    
    def _get_default_exploitation_techniques(self) -> Dict[str, Any]:
        """
        Get default exploitation techniques
        """
        return {
            'sql_injection': {
                'variants': ['union', 'boolean', 'time_based', 'error_based'],
                'techniques': [
                    'UNION SELECT injection',
                    'Boolean-based blind injection',
                    'Time-based blind injection',
                    'Error-based injection'
                ],
                'tools': ['sqlmap', 'ghauri'],
                'detection_signatures': [
                    'SQL syntax error messages',
                    'Unexpected database responses',
                    'Different response times'
                ]
            },
            'xss': {
                'variants': ['reflected', 'stored', 'dom_based'],
                'techniques': [
                    'Script injection in HTML context',
                    'Event handler injection',
                    'JavaScript URI injection'
                ],
                'tools': ['dalfox', 'xsser', 'xsstrike'],
                'detection_signatures': [
                    'Unescaped HTML output',
                    'JavaScript execution in browser',
                    'Reflection of user input'
                ]
            },
            'command_injection': {
                'variants': ['os_command', 'shell_metacharacters'],
                'techniques': [
                    'Shell command concatenation',
                    'Metacharacter injection',
                    'Command substitution'
                ],
                'tools': ['commix'],
                'detection_signatures': [
                    'Unexpected command execution',
                    'System response output',
                    'Process creation anomalies'
                ]
            }
        }
    
    def _get_default_reproduction_templates(self) -> Dict[str, Any]:
        """
        Get default reproduction templates
        """
        return {
            'sql_injection': {
                'steps': [
                    'Identify input fields that interact with database',
                    'Test for SQL injection with single quote (\')',
                    'Observe error messages or behavioral changes',
                    'Use sqlmap for automated exploitation',
                    'Extract database schema and data'
                ],
                'manual_testing': [
                    '\' OR \'1\'=\'1',
                    '\' OR \'1\'=\'1\' --',
                    '\' UNION SELECT NULL, username, password FROM users --'
                ],
                'tool_commands': [
                    'sqlmap -u "{target}" -p {parameter}',
                    'sqlmap -u "{target}" --dbs',
                    'sqlmap -u "{target}" -D {database} --tables'
                ]
            },
            'xss': {
                'steps': [
                    'Identify input fields or URL parameters',
                    'Test with simple script payload: <script>alert(1)</script>',
                    'Observe JavaScript execution in browser',
                    'Try different contexts (HTML, attribute, JavaScript)',
                    'Use specialized tools for comprehensive testing'
                ],
                'manual_testing': [
                    '<script>alert(1)</script>',
                    '"><script>alert(1)</script>',
                    '\'><script>alert(1)</script>',
                    'javascript:alert(1)'
                ],
                'tool_commands': [
                    'dalfox url "{target}"',
                    'dalfox file urls.txt',
                    'xsser --url "{target}" -p "{parameter}"'
                ]
            }
        }
    
    def _get_default_remediation_knowledge(self) -> Dict[str, Any]:
        """
        Get default remediation knowledge
        """
        return {
            'sql_injection': {
                'immediate_fix': 'Use parameterized queries or prepared statements',
                'long_term_solution': 'Implement input validation and ORM frameworks',
                'code_examples': {
                    'python': '''
# Vulnerable code
query = "SELECT * FROM users WHERE id = " + user_id
cursor.execute(query)

# Secure code
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
''',
                    'java': '''
// Vulnerable code
String query = "SELECT * FROM users WHERE id = " + userId;
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(query);

// Secure code
String query = "SELECT * FROM users WHERE id = ?";
PreparedStatement pstmt = connection.prepareStatement(query);
pstmt.setString(1, userId);
ResultSet rs = pstmt.executeQuery();
'''
                },
                'framework_specific': {
                    'django': 'Use Django ORM or parameterized raw SQL queries',
                    'flask': 'Use SQLAlchemy ORM or parameterized queries'
                }
            },
            'xss': {
                'immediate_fix': 'Implement proper output encoding for context',
                'long_term_solution': 'Use Content Security Policy (CSP) and modern frameworks',
                'code_examples': {
                    'javascript': '''
// Vulnerable code
document.getElementById("output").innerHTML = userInput;

// Secure code
document.getElementById("output").textContent = userInput;
''',
                    'python': '''
# Vulnerable code
return f"<div>{user_input}</div>"

# Secure code (using Jinja2 autoescape)
return render_template("page.html", user_input=user_input)
'''
                },
                'framework_specific': {
                    'react': 'Use JSX curly braces for automatic escaping',
                    'vue': 'Use v-text or v-html with caution'
                }
            }
        }
    
    def get_exploitation_technique(self, vuln_type: str) -> Dict[str, Any]:
        """
        Get exploitation technique for a vulnerability type
        """
        return self.knowledge_base['exploitation_techniques'].get(vuln_type, {})
    
    def get_reproduction_template(self, vuln_type: str) -> Dict[str, Any]:
        """
        Get reproduction template for a vulnerability type
        """
        return self.knowledge_base['reproduction_templates'].get(vuln_type, {})
    
    def get_remediation_knowledge(self, vuln_type: str) -> Dict[str, Any]:
        """
        Get remediation knowledge for a vulnerability type
        """
        return self.knowledge_base['remediation_knowledge'].get(vuln_type, {})
    
    def map_to_cve(self, finding: Dict[str, Any]) -> str:
        """
        Map finding to CVE identifier
        """
        # In a real implementation, this would query a CVE database
        # For now, we'll return a placeholder
        return "CVE-NVD-CWE-noinfo"
    
    def map_to_cwe(self, finding: Dict[str, Any]) -> str:
        """
        Map finding to CWE identifier
        """
        vuln_type = finding.get('type', '')
        cwe_mapping = {
            'sql_injection': 'CWE-89',
            'xss': 'CWE-79',
            'command_injection': 'CWE-77',
            'path_traversal': 'CWE-22',
            'idor': 'CWE-639',
            'ssrf': 'CWE-918',
            'xxe': 'CWE-611'
        }
        return cwe_mapping.get(vuln_type, 'CWE-NVD-CWE-Other')
    
    def map_to_owasp(self, finding: Dict[str, Any]) -> str:
        """
        Map finding to OWASP category
        """
        vuln_type = finding.get('type', '')
        owasp_mapping = {
            'sql_injection': 'A03:2021-Injection',
            'xss': 'A03:2021-Injection',
            'command_injection': 'A03:2021-Injection',
            'path_traversal': 'A01:2021-Broken Access Control',
            'idor': 'A01:2021-Broken Access Control',
            'ssrf': 'A10:2021-Server-Side Request Forgery',
            'xxe': 'A04:2021-Insecure Design'
        }
        return owasp_mapping.get(vuln_type, 'A00:2021-Other')
    
    def adapt_reproduction_steps(self, vuln_type: str, tech_stack: List[str]) -> List[str]:
        """
        Adapt reproduction steps based on target technology stack
        """
        template = self.get_reproduction_template(vuln_type)
        if not template:
            return []
            
        steps = template.get('steps', []).copy()
        
        # Modify steps based on technology stack
        if 'php' in tech_stack:
            steps.append('Note: PHP applications may be vulnerable to magic quotes bypass')
        elif 'java' in tech_stack:
            steps.append('Note: Java applications may require specific payload encoding')
        elif 'python' in tech_stack:
            steps.append('Note: Python applications may have different quoting mechanisms')
            
        return steps
    
    def get_language_specific_remediation(self, vuln_type: str, language: str) -> str:
        """
        Get language-specific remediation guidance
        """
        remediation = self.get_remediation_knowledge(vuln_type)
        code_examples = remediation.get('code_examples', {})
        return code_examples.get(language, 'No language-specific guidance available')
    
    def get_framework_specific_remediation(self, vuln_type: str, framework: str) -> str:
        """
        Get framework-specific remediation guidance
        """
        remediation = self.get_remediation_knowledge(vuln_type)
        framework_specific = remediation.get('framework_specific', {})
        return framework_specific.get(framework, 'No framework-specific guidance available')