"""
Real-Time Adaptive Exploitation Module

This module enables the agent to:
1. Learn from failures in real-time during scans
2. Adapt exploitation strategies based on results
3. Dynamically adjust tool parameters
4. Implement intelligent retry with variations
5. Detect and evade defenses

Key Features:
- Online learning from immediate feedback
- Bayesian strategy selection
- Adaptive parameter tuning
- Defense detection and evasion
- Intelligent backoff and retry
"""

import os
import json
import logging
import time
import random
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict
import numpy as np
import threading

logger = logging.getLogger(__name__)


class ExecutionOutcome(Enum):
    """Possible outcomes of tool execution"""
    SUCCESS = "success"  # Found vulnerabilities
    PARTIAL = "partial"  # Some results, not complete
    BLOCKED = "blocked"  # Blocked by WAF/IPS
    TIMEOUT = "timeout"  # Execution timeout
    ERROR = "error"      # Tool error
    NO_RESULTS = "no_results"  # Completed but nothing found


class DefenseType(Enum):
    """Types of defenses detected"""
    WAF = "waf"
    IPS = "ips"
    RATE_LIMIT = "rate_limit"
    HONEYPOT = "honeypot"
    CAPTCHA = "captcha"
    AUTHENTICATION = "authentication"
    UNKNOWN = "unknown"


@dataclass
class ExecutionContext:
    """Context for a tool execution"""
    tool_name: str
    target: str
    parameters: Dict[str, Any]
    phase: str
    attempt_number: int
    previous_outcomes: List[ExecutionOutcome]
    detected_defenses: List[DefenseType]
    start_time: float = field(default_factory=time.time)


@dataclass
class AdaptationStrategy:
    """Strategy for adapting to failures"""
    name: str
    description: str
    conditions: List[str]  # When to apply
    modifications: Dict[str, Any]  # What to change
    success_rate: float = 0.5
    usage_count: int = 0


class DefenseDetector:
    """Detects various defense mechanisms"""
    
    def __init__(self):
        # Patterns indicating various defenses
        self.waf_signatures = [
            "403 forbidden",
            "request blocked",
            "access denied",
            "waf",
            "web application firewall",
            "mod_security",
            "cloudflare",
            "akamai",
            "imperva",
            "f5 big-ip",
            "aws waf",
            "sucuri"
        ]
        
        self.rate_limit_signatures = [
            "429 too many requests",
            "rate limit",
            "slow down",
            "too many requests",
            "throttl"
        ]
        
        self.honeypot_signatures = [
            "honeypot",
            "tarpit",
            "fake",
            "decoy"
        ]
        
        self.ips_signatures = [
            "connection reset",
            "connection refused",
            "connection timed out",
            "no route to host"
        ]
    
    def detect_defenses(self, output: str, response_code: int = None,
                       response_time: float = None) -> List[DefenseType]:
        """Detect defenses from tool output"""
        defenses = []
        output_lower = output.lower() if output else ""
        
        # Check WAF
        if any(sig in output_lower for sig in self.waf_signatures):
            defenses.append(DefenseType.WAF)
        
        # Check rate limiting
        if response_code == 429 or any(sig in output_lower for sig in self.rate_limit_signatures):
            defenses.append(DefenseType.RATE_LIMIT)
        
        # Check honeypot indicators
        if any(sig in output_lower for sig in self.honeypot_signatures):
            defenses.append(DefenseType.HONEYPOT)
        
        # Check IPS (connection issues)
        if any(sig in output_lower for sig in self.ips_signatures):
            defenses.append(DefenseType.IPS)
        
        # Check for captcha
        if "captcha" in output_lower or "recaptcha" in output_lower:
            defenses.append(DefenseType.CAPTCHA)
        
        # Check for unusually slow responses (possible tarpit)
        if response_time and response_time > 30:
            defenses.append(DefenseType.HONEYPOT)
        
        return defenses


class AdaptiveParameterTuner:
    """Dynamically tunes tool parameters based on feedback"""
    
    def __init__(self):
        # Parameter adjustment rules
        self.parameter_rules = {
            # Rate/timing adjustments
            'rate': {
                'decrease_on': [ExecutionOutcome.BLOCKED, ExecutionOutcome.TIMEOUT],
                'increase_on': [ExecutionOutcome.SUCCESS],
                'min_value': 1,
                'max_value': 100,
                'adjustment_factor': 0.5
            },
            'threads': {
                'decrease_on': [ExecutionOutcome.BLOCKED, ExecutionOutcome.TIMEOUT, ExecutionOutcome.ERROR],
                'increase_on': [ExecutionOutcome.SUCCESS],
                'min_value': 1,
                'max_value': 50,
                'adjustment_factor': 0.5
            },
            'timeout': {
                'increase_on': [ExecutionOutcome.TIMEOUT],
                'decrease_on': [ExecutionOutcome.SUCCESS],
                'min_value': 5,
                'max_value': 120,
                'adjustment_factor': 1.5
            },
            'delay': {
                'increase_on': [ExecutionOutcome.BLOCKED, ExecutionOutcome.TIMEOUT],
                'decrease_on': [ExecutionOutcome.SUCCESS],
                'min_value': 0,
                'max_value': 10,
                'adjustment_factor': 2.0
            }
        }
        
        # Current parameter states per tool/target combo
        self.parameter_states: Dict[str, Dict[str, float]] = defaultdict(dict)
    
    def get_state_key(self, tool: str, target: str) -> str:
        """Generate unique key for tool/target combination"""
        return hashlib.md5(f"{tool}:{target}".encode()).hexdigest()[:12]
    
    def adjust_parameters(self, tool: str, target: str, 
                         current_params: Dict[str, Any],
                         outcome: ExecutionOutcome,
                         defenses: List[DefenseType]) -> Dict[str, Any]:
        """Adjust parameters based on execution outcome"""
        state_key = self.get_state_key(tool, target)
        adjusted = current_params.copy()
        
        # Apply adjustments based on rules
        for param_name, rules in self.parameter_rules.items():
            if param_name not in adjusted:
                continue
            
            current_value = adjusted[param_name]
            
            # Check if we should decrease
            if outcome in rules.get('decrease_on', []):
                new_value = current_value * rules['adjustment_factor']
                new_value = max(rules['min_value'], new_value)
                adjusted[param_name] = int(new_value) if isinstance(current_value, int) else new_value
                logger.info(f"Decreased {param_name}: {current_value} -> {adjusted[param_name]}")
            
            # Check if we should increase
            elif outcome in rules.get('increase_on', []):
                new_value = current_value / rules['adjustment_factor']
                new_value = min(rules['max_value'], new_value)
                adjusted[param_name] = int(new_value) if isinstance(current_value, int) else new_value
        
        # Special adjustments for detected defenses
        if DefenseType.WAF in defenses:
            # Use evasion techniques
            adjusted['evasion'] = True
            adjusted['random_agent'] = True
            if 'rate' in adjusted:
                adjusted['rate'] = max(1, adjusted.get('rate', 10) // 2)
        
        if DefenseType.RATE_LIMIT in defenses:
            # Add delay between requests
            adjusted['delay'] = adjusted.get('delay', 0) + 2
            if 'rate' in adjusted:
                adjusted['rate'] = max(1, adjusted.get('rate', 10) // 3)
        
        if DefenseType.IPS in defenses:
            # Randomize source ports, use fragmentation
            adjusted['random_ports'] = True
            adjusted['fragment'] = True
        
        # Store state
        self.parameter_states[state_key] = adjusted
        
        return adjusted
    
    def get_cached_parameters(self, tool: str, target: str) -> Optional[Dict[str, Any]]:
        """Get previously adjusted parameters if available"""
        state_key = self.get_state_key(tool, target)
        return self.parameter_states.get(state_key)


class BayesianStrategySelector:
    """
    Uses Bayesian inference to select the best exploitation strategy
    based on observed outcomes
    """
    
    def __init__(self):
        # Strategy prior beliefs (alpha, beta for Beta distribution)
        # Higher alpha = more success, higher beta = more failures
        self.strategy_beliefs: Dict[str, Dict[str, float]] = defaultdict(
            lambda: {'alpha': 1.0, 'beta': 1.0}
        )
        
        # Context-specific beliefs
        self.context_beliefs: Dict[str, Dict[str, Dict[str, float]]] = defaultdict(
            lambda: defaultdict(lambda: {'alpha': 1.0, 'beta': 1.0})
        )
    
    def update_belief(self, strategy: str, success: bool, context: str = None):
        """Update belief about a strategy based on observed outcome"""
        # Update global belief
        if success:
            self.strategy_beliefs[strategy]['alpha'] += 1
        else:
            self.strategy_beliefs[strategy]['beta'] += 1
        
        # Update context-specific belief
        if context:
            if success:
                self.context_beliefs[context][strategy]['alpha'] += 1
            else:
                self.context_beliefs[context][strategy]['beta'] += 1
    
    def get_expected_success_rate(self, strategy: str, context: str = None) -> float:
        """Get expected success rate for a strategy"""
        if context and strategy in self.context_beliefs[context]:
            beliefs = self.context_beliefs[context][strategy]
        else:
            beliefs = self.strategy_beliefs[strategy]
        
        # Expected value of Beta distribution
        alpha, beta = beliefs['alpha'], beliefs['beta']
        return alpha / (alpha + beta)
    
    def select_strategy(self, available_strategies: List[str], 
                       context: str = None,
                       exploration_rate: float = 0.1) -> str:
        """
        Select best strategy using Thompson Sampling
        (Balances exploration vs exploitation)
        """
        if random.random() < exploration_rate:
            # Exploration: random choice
            return random.choice(available_strategies)
        
        # Exploitation: sample from posteriors and pick best
        best_strategy = None
        best_sample = -1
        
        for strategy in available_strategies:
            if context and strategy in self.context_beliefs[context]:
                beliefs = self.context_beliefs[context][strategy]
            else:
                beliefs = self.strategy_beliefs[strategy]
            
            # Sample from Beta distribution
            sample = np.random.beta(beliefs['alpha'], beliefs['beta'])
            
            if sample > best_sample:
                best_sample = sample
                best_strategy = strategy
        
        return best_strategy or available_strategies[0]
    
    def get_strategy_rankings(self, strategies: List[str], 
                             context: str = None) -> List[Tuple[str, float]]:
        """Get strategies ranked by expected success rate"""
        rankings = []
        for strategy in strategies:
            rate = self.get_expected_success_rate(strategy, context)
            rankings.append((strategy, rate))
        
        rankings.sort(key=lambda x: x[1], reverse=True)
        return rankings


class EvasionEngine:
    """Handles evasion techniques when defenses are detected"""
    
    def __init__(self):
        self.evasion_techniques = {
            DefenseType.WAF: [
                {
                    'name': 'encoding_bypass',
                    'description': 'Use URL encoding, double encoding, unicode',
                    'payload_transform': self._encode_payload
                },
                {
                    'name': 'case_variation',
                    'description': 'Vary case in payloads',
                    'payload_transform': self._vary_case
                },
                {
                    'name': 'comment_insertion',
                    'description': 'Insert comments in payloads',
                    'payload_transform': self._insert_comments
                },
                {
                    'name': 'parameter_pollution',
                    'description': 'Use HTTP parameter pollution',
                    'param_transform': self._pollute_params
                }
            ],
            DefenseType.RATE_LIMIT: [
                {
                    'name': 'request_spreading',
                    'description': 'Spread requests over time',
                    'timing_config': {'delay': 5, 'jitter': 2}
                },
                {
                    'name': 'ip_rotation',
                    'description': 'Rotate source IPs (if proxies available)',
                    'requires': 'proxy_list'
                }
            ],
            DefenseType.IPS: [
                {
                    'name': 'fragmentation',
                    'description': 'Fragment packets',
                    'nmap_flags': ['-f', '--mtu 8']
                },
                {
                    'name': 'decoy_scan',
                    'description': 'Use decoy addresses',
                    'nmap_flags': ['-D', 'RND:5']
                },
                {
                    'name': 'timing_adjustment',
                    'description': 'Slow down scan timing',
                    'nmap_flags': ['-T2']
                }
            ]
        }
    
    def _encode_payload(self, payload: str) -> str:
        """Apply encoding transformations"""
        import urllib.parse
        # Double URL encode
        encoded = urllib.parse.quote(urllib.parse.quote(payload))
        return encoded
    
    def _vary_case(self, payload: str) -> str:
        """Randomly vary case"""
        return ''.join(
            c.upper() if random.random() > 0.5 else c.lower()
            for c in payload
        )
    
    def _insert_comments(self, payload: str) -> str:
        """Insert SQL comments to break signatures"""
        # For SQL injection
        if any(kw in payload.upper() for kw in ['SELECT', 'UNION', 'WHERE']):
            # Insert /**/ comments
            words = payload.split()
            return '/**/'.join(words)
        return payload
    
    def _pollute_params(self, params: Dict) -> Dict:
        """Apply HTTP parameter pollution"""
        polluted = {}
        for key, value in params.items():
            # Add parameter multiple times with variations
            polluted[key] = value
            polluted[f"{key}[]"] = value
        return polluted
    
    def get_evasion_techniques(self, defenses: List[DefenseType]) -> List[Dict]:
        """Get applicable evasion techniques for detected defenses"""
        techniques = []
        for defense in defenses:
            if defense in self.evasion_techniques:
                techniques.extend(self.evasion_techniques[defense])
        return techniques
    
    def apply_evasion(self, command: str, params: Dict,
                     defenses: List[DefenseType]) -> Tuple[str, Dict]:
        """Apply evasion techniques to command and parameters"""
        modified_command = command
        modified_params = params.copy()
        
        techniques = self.get_evasion_techniques(defenses)
        
        for technique in techniques:
            # Apply payload transforms
            if 'payload_transform' in technique:
                for key, value in modified_params.items():
                    if isinstance(value, str):
                        modified_params[key] = technique['payload_transform'](value)
            
            # Apply parameter transforms
            if 'param_transform' in technique:
                modified_params = technique['param_transform'](modified_params)
            
            # Apply nmap flags
            if 'nmap_flags' in technique and 'nmap' in command:
                flags = ' '.join(technique['nmap_flags'])
                modified_command = f"{command} {flags}"
            
            # Apply timing configs
            if 'timing_config' in technique:
                modified_params['delay'] = technique['timing_config'].get('delay', 0)
                modified_params['jitter'] = technique['timing_config'].get('jitter', 0)
        
        return modified_command, modified_params


class RealTimeAdaptiveEngine:
    """
    Main engine for real-time adaptive exploitation
    
    Coordinates all adaptive components to provide intelligent,
    learning-based exploitation that adapts in real-time.
    """
    
    def __init__(self, memory_system=None):
        self.memory_system = memory_system
        
        # Initialize components
        self.defense_detector = DefenseDetector()
        self.parameter_tuner = AdaptiveParameterTuner()
        self.strategy_selector = BayesianStrategySelector()
        self.evasion_engine = EvasionEngine()
        
        # Execution history for learning
        self.execution_history: List[Dict] = []
        self.active_contexts: Dict[str, ExecutionContext] = {}
        
        # Retry configuration
        self.max_retries = 3
        self.base_backoff = 2  # seconds
        
        # Learning statistics
        self.stats = {
            'total_executions': 0,
            'successful_adaptations': 0,
            'defenses_detected': defaultdict(int),
            'strategy_effectiveness': defaultdict(lambda: {'success': 0, 'total': 0})
        }
        
        logger.info("Real-Time Adaptive Engine initialized")
    
    def create_execution_context(self, tool_name: str, target: str,
                                 parameters: Dict, phase: str) -> ExecutionContext:
        """Create a new execution context"""
        context = ExecutionContext(
            tool_name=tool_name,
            target=target,
            parameters=parameters,
            phase=phase,
            attempt_number=1,
            previous_outcomes=[],
            detected_defenses=[]
        )
        
        context_id = f"{tool_name}_{target}_{time.time()}"
        self.active_contexts[context_id] = context
        
        return context
    
    def process_execution_result(self, context: ExecutionContext,
                                output: str, response_code: int = None,
                                response_time: float = None,
                                findings: List[Dict] = None) -> Dict[str, Any]:
        """
        Process execution result and determine next steps
        
        Returns:
            Dict with:
            - outcome: ExecutionOutcome
            - should_retry: bool
            - adapted_params: Dict (if retry)
            - evasion_applied: bool
            - recommendations: List[str]
        """
        self.stats['total_executions'] += 1
        
        # Determine outcome
        outcome = self._determine_outcome(output, response_code, findings)
        context.previous_outcomes.append(outcome)
        
        # Detect defenses
        defenses = self.defense_detector.detect_defenses(
            output, response_code, response_time
        )
        for defense in defenses:
            if defense not in context.detected_defenses:
                context.detected_defenses.append(defense)
                self.stats['defenses_detected'][defense.value] += 1
        
        # Update strategy beliefs
        strategy_key = f"{context.tool_name}_{context.phase}"
        target_context = self._get_target_context(context.target)
        self.strategy_selector.update_belief(
            strategy_key,
            outcome == ExecutionOutcome.SUCCESS,
            target_context
        )
        
        # Determine if we should retry
        should_retry = self._should_retry(context, outcome)
        
        result = {
            'outcome': outcome,
            'defenses_detected': [d.value for d in defenses],
            'should_retry': should_retry,
            'adapted_params': None,
            'evasion_applied': False,
            'recommendations': []
        }
        
        if should_retry:
            # Adapt parameters
            adapted_params = self.parameter_tuner.adjust_parameters(
                context.tool_name,
                context.target,
                context.parameters,
                outcome,
                defenses
            )
            
            # Apply evasion if defenses detected
            if defenses:
                command = context.parameters.get('command', '')
                command, adapted_params = self.evasion_engine.apply_evasion(
                    command, adapted_params, defenses
                )
                result['evasion_applied'] = True
                adapted_params['command'] = command
            
            result['adapted_params'] = adapted_params
            context.parameters = adapted_params
            context.attempt_number += 1
            
            self.stats['successful_adaptations'] += 1
        
        # Generate recommendations
        result['recommendations'] = self._generate_recommendations(context, outcome, defenses)
        
        # Record in history
        self._record_execution(context, outcome, defenses, findings)
        
        # Store in long-term memory if available
        if self.memory_system:
            self._update_memory(context, outcome, defenses, findings)
        
        return result
    
    def _determine_outcome(self, output: str, response_code: int,
                          findings: List[Dict]) -> ExecutionOutcome:
        """Determine execution outcome from results"""
        output_lower = (output or "").lower()
        
        # Check for findings
        if findings and len(findings) > 0:
            return ExecutionOutcome.SUCCESS
        
        # Check for blocking
        if response_code in [403, 406, 429] or "blocked" in output_lower:
            return ExecutionOutcome.BLOCKED
        
        # Check for timeout
        if "timeout" in output_lower or "timed out" in output_lower:
            return ExecutionOutcome.TIMEOUT
        
        # Check for errors
        if "error" in output_lower or "failed" in output_lower:
            return ExecutionOutcome.ERROR
        
        # Completed but no findings
        return ExecutionOutcome.NO_RESULTS
    
    def _should_retry(self, context: ExecutionContext, 
                     outcome: ExecutionOutcome) -> bool:
        """Determine if we should retry with adapted parameters"""
        # Don't retry if successful
        if outcome == ExecutionOutcome.SUCCESS:
            return False
        
        # Don't retry if max attempts reached
        if context.attempt_number >= self.max_retries:
            return False
        
        # Don't retry if honeypot detected
        if DefenseType.HONEYPOT in context.detected_defenses:
            logger.warning("Honeypot detected - not retrying")
            return False
        
        # Retry on these outcomes
        retryable = [
            ExecutionOutcome.BLOCKED,
            ExecutionOutcome.TIMEOUT,
            ExecutionOutcome.ERROR
        ]
        
        return outcome in retryable
    
    def _get_target_context(self, target: str) -> str:
        """Generate context identifier for target"""
        # Extract domain or IP characteristics
        if '.' in target:
            parts = target.split('.')
            if len(parts) >= 2:
                return f"{parts[-2]}.{parts[-1]}"
        return "generic"
    
    def _generate_recommendations(self, context: ExecutionContext,
                                 outcome: ExecutionOutcome,
                                 defenses: List[DefenseType]) -> List[str]:
        """Generate recommendations based on execution results"""
        recommendations = []
        
        if DefenseType.WAF in defenses:
            recommendations.append(
                "WAF detected - Consider using encoding bypass techniques"
            )
            recommendations.append(
                "Try alternative attack vectors that might bypass WAF rules"
            )
        
        if DefenseType.RATE_LIMIT in defenses:
            recommendations.append(
                "Rate limiting detected - Reduce request rate significantly"
            )
            recommendations.append(
                "Consider spreading scan over longer time period"
            )
        
        if DefenseType.IPS in defenses:
            recommendations.append(
                "IPS detected - Use fragmentation and timing evasion"
            )
        
        if outcome == ExecutionOutcome.TIMEOUT:
            recommendations.append(
                "Timeout occurred - Consider increasing timeout or reducing scope"
            )
        
        if outcome == ExecutionOutcome.NO_RESULTS and context.attempt_number > 1:
            recommendations.append(
                "Multiple attempts with no results - Target may not be vulnerable"
            )
            recommendations.append(
                "Consider trying different tools or attack vectors"
            )
        
        return recommendations
    
    def _record_execution(self, context: ExecutionContext,
                         outcome: ExecutionOutcome,
                         defenses: List[DefenseType],
                         findings: List[Dict]):
        """Record execution in history for learning"""
        record = {
            'timestamp': datetime.now().isoformat(),
            'tool': context.tool_name,
            'target': context.target,
            'phase': context.phase,
            'attempt': context.attempt_number,
            'outcome': outcome.value,
            'defenses': [d.value for d in defenses],
            'findings_count': len(findings) if findings else 0,
            'parameters_hash': hashlib.md5(
                json.dumps(context.parameters, sort_keys=True).encode()
            ).hexdigest()[:8]
        }
        
        self.execution_history.append(record)
        
        # Keep history bounded
        if len(self.execution_history) > 1000:
            self.execution_history = self.execution_history[-500:]
    
    def _update_memory(self, context: ExecutionContext,
                      outcome: ExecutionOutcome,
                      defenses: List[DefenseType],
                      findings: List[Dict]):
        """Update long-term memory with learnings"""
        if not self.memory_system:
            return
        
        try:
            # Record tool effectiveness
            self.memory_system.record_tool_execution(
                tool_name=context.tool_name,
                target_type=self._get_target_context(context.target),
                phase=context.phase,
                context={'defenses': [d.value for d in defenses]},
                success=outcome == ExecutionOutcome.SUCCESS,
                vulns_found=len(findings) if findings else 0,
                execution_time=time.time() - context.start_time
            )
            
            # Store defense patterns
            if defenses:
                self.memory_system.store_memory(
                    memory_type='defense_pattern',
                    content={
                        'target': context.target,
                        'defenses': [d.value for d in defenses],
                        'tool': context.tool_name,
                        'timestamp': datetime.now().isoformat()
                    },
                    tags=[d.value for d in defenses],
                    importance=0.6
                )
                
        except Exception as e:
            logger.error(f"Failed to update memory: {e}")
    
    def get_recommended_strategy(self, tool_options: List[str],
                                target: str, phase: str) -> str:
        """Get recommended tool/strategy based on learned patterns"""
        context = self._get_target_context(target)
        
        # Create strategy keys
        strategies = [f"{tool}_{phase}" for tool in tool_options]
        
        # Get rankings
        rankings = self.strategy_selector.get_strategy_rankings(strategies, context)
        
        if rankings:
            best_strategy = rankings[0][0]
            # Extract tool name from strategy
            return best_strategy.replace(f"_{phase}", "")
        
        return tool_options[0]
    
    def get_initial_parameters(self, tool_name: str, target: str,
                              default_params: Dict) -> Dict:
        """Get optimized initial parameters based on past experience"""
        # Check if we have cached parameters for this tool/target
        cached = self.parameter_tuner.get_cached_parameters(tool_name, target)
        
        if cached:
            # Merge with defaults, preferring cached values
            merged = default_params.copy()
            merged.update(cached)
            return merged
        
        # Check memory for similar targets
        if self.memory_system:
            profile = self.memory_system.get_target_profile(target)
            if profile:
                # Adjust based on known defenses
                if profile.get('waf_detected'):
                    default_params['rate'] = default_params.get('rate', 10) // 2
                    default_params['delay'] = default_params.get('delay', 0) + 1
                
                # Use tools that worked before
                if tool_name in profile.get('failed_tools', []):
                    logger.info(f"Tool {tool_name} failed on this target before")
        
        return default_params
    
    def get_adaptation_statistics(self) -> Dict[str, Any]:
        """Get statistics about adaptations"""
        return {
            'total_executions': self.stats['total_executions'],
            'successful_adaptations': self.stats['successful_adaptations'],
            'adaptation_rate': (
                self.stats['successful_adaptations'] / max(1, self.stats['total_executions'])
            ),
            'defenses_encountered': dict(self.stats['defenses_detected']),
            'strategy_rankings': dict(self.strategy_selector.strategy_beliefs)
        }
    
    def export_learnings(self) -> Dict[str, Any]:
        """Export learned knowledge for persistence"""
        return {
            'strategy_beliefs': dict(self.strategy_selector.strategy_beliefs),
            'context_beliefs': {
                ctx: dict(beliefs) 
                for ctx, beliefs in self.strategy_selector.context_beliefs.items()
            },
            'parameter_states': dict(self.parameter_tuner.parameter_states),
            'execution_history': self.execution_history[-100:],  # Last 100
            'stats': {
                'total_executions': self.stats['total_executions'],
                'successful_adaptations': self.stats['successful_adaptations'],
                'defenses_detected': dict(self.stats['defenses_detected'])
            }
        }
    
    def import_learnings(self, data: Dict[str, Any]):
        """Import previously learned knowledge"""
        if 'strategy_beliefs' in data:
            for strategy, beliefs in data['strategy_beliefs'].items():
                self.strategy_selector.strategy_beliefs[strategy] = beliefs
        
        if 'parameter_states' in data:
            self.parameter_tuner.parameter_states.update(data['parameter_states'])
        
        if 'stats' in data:
            self.stats['total_executions'] = data['stats'].get('total_executions', 0)
            self.stats['successful_adaptations'] = data['stats'].get('successful_adaptations', 0)
        
        logger.info("Imported learned knowledge")


# Singleton instance
_adaptive_engine = None

def get_adaptive_engine(memory_system=None) -> RealTimeAdaptiveEngine:
    """Get the singleton adaptive engine"""
    global _adaptive_engine
    if _adaptive_engine is None:
        _adaptive_engine = RealTimeAdaptiveEngine(memory_system)
    return _adaptive_engine
