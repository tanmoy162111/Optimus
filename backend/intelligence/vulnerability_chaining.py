"""
Contextual Vulnerability Chaining Module

This module enables intelligent vulnerability chaining by:
1. Building attack graphs from discovered vulnerabilities
2. Identifying exploitation paths that maximize impact
3. Reasoning about vulnerability dependencies
4. Automatically executing multi-step exploits
5. Learning successful chains for future use

Key Concepts:
- Attack Graph: Directed graph of vulnerabilities and their relationships
- Kill Chain: Sequence of exploits leading to high-impact compromise
- Pivot Point: Vulnerability that enables access to new attack surface
- Impact Amplification: How chaining increases overall severity
"""

import os
import json
import logging
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict
import heapq

logger = logging.getLogger(__name__)


class VulnType(Enum):
    """Vulnerability types for classification"""
    INJECTION = "injection"
    AUTH_BYPASS = "auth_bypass"
    INFO_DISCLOSURE = "info_disclosure"
    SSRF = "ssrf"
    XSS = "xss"
    FILE_ACCESS = "file_access"
    RCE = "rce"
    PRIVILEGE_ESCALATION = "privesc"
    MISCONFIG = "misconfig"
    CREDENTIAL_LEAK = "credential_leak"
    DESERIALIZATION = "deserialization"
    XXE = "xxe"
    PATH_TRAVERSAL = "path_traversal"
    OPEN_REDIRECT = "open_redirect"


class ImpactType(Enum):
    """Impact types for vulnerabilities"""
    CONFIDENTIALITY = "confidentiality"
    INTEGRITY = "integrity"
    AVAILABILITY = "availability"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"


class AssetType(Enum):
    """Types of assets that can be compromised"""
    WEB_SERVER = "web_server"
    DATABASE = "database"
    INTERNAL_SERVICE = "internal_service"
    CLOUD_METADATA = "cloud_metadata"
    CREDENTIALS = "credentials"
    API = "api"
    FILE_SYSTEM = "file_system"
    NETWORK = "network"
    ADMIN_PANEL = "admin_panel"
    USER_DATA = "user_data"


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability"""
    id: str
    vuln_type: VulnType
    name: str
    description: str
    severity: float  # 0-10 CVSS-like
    endpoint: str
    parameter: Optional[str] = None
    evidence: Optional[str] = None
    exploitable: bool = True
    requires_auth: bool = False
    
    # Chain-relevant properties
    provides_access_to: List[AssetType] = field(default_factory=list)
    requires_access_to: List[AssetType] = field(default_factory=list)
    can_pivot_to: List[str] = field(default_factory=list)  # Other endpoints
    
    # Impact
    impacts: List[ImpactType] = field(default_factory=list)
    
    # Metadata
    discovered_at: str = field(default_factory=lambda: datetime.now().isoformat())
    exploit_complexity: str = "low"  # low, medium, high


@dataclass
class AttackEdge:
    """Edge in attack graph representing exploitation path"""
    source_vuln_id: str
    target_vuln_id: str
    relationship: str  # 'enables', 'requires', 'amplifies'
    probability: float  # Success probability
    description: str
    
    def __lt__(self, other):
        return self.probability > other.probability  # Higher probability = better


@dataclass
class AttackChain:
    """A sequence of vulnerabilities forming an attack chain"""
    id: str
    vulnerabilities: List[str]  # Vuln IDs in order
    total_severity: float
    success_probability: float
    final_impact: str
    description: str
    steps: List[Dict[str, Any]] = field(default_factory=list)
    
    def __lt__(self, other):
        # Sort by severity * probability for best chains
        return (self.total_severity * self.success_probability) > \
               (other.total_severity * other.success_probability)


class VulnerabilityRelationshipAnalyzer:
    """Analyzes relationships between vulnerabilities"""
    
    def __init__(self):
        # Define vulnerability type relationships
        # Key: (source_type, target_type) -> (relationship, probability)
        self.type_relationships = {
            # SSRF enables access to internal services
            (VulnType.SSRF, VulnType.INFO_DISCLOSURE): ("enables", 0.8),
            (VulnType.SSRF, VulnType.CREDENTIAL_LEAK): ("enables", 0.7),
            (VulnType.SSRF, VulnType.RCE): ("enables", 0.5),
            
            # Info disclosure can lead to auth bypass
            (VulnType.INFO_DISCLOSURE, VulnType.AUTH_BYPASS): ("enables", 0.6),
            (VulnType.INFO_DISCLOSURE, VulnType.INJECTION): ("amplifies", 0.7),
            
            # Credential leak enables auth bypass
            (VulnType.CREDENTIAL_LEAK, VulnType.AUTH_BYPASS): ("enables", 0.9),
            (VulnType.CREDENTIAL_LEAK, VulnType.PRIVILEGE_ESCALATION): ("enables", 0.7),
            
            # Auth bypass enables privilege escalation
            (VulnType.AUTH_BYPASS, VulnType.PRIVILEGE_ESCALATION): ("enables", 0.8),
            (VulnType.AUTH_BYPASS, VulnType.INJECTION): ("enables", 0.7),
            (VulnType.AUTH_BYPASS, VulnType.FILE_ACCESS): ("enables", 0.6),
            
            # SQL injection can lead to RCE
            (VulnType.INJECTION, VulnType.RCE): ("enables", 0.4),
            (VulnType.INJECTION, VulnType.CREDENTIAL_LEAK): ("enables", 0.8),
            (VulnType.INJECTION, VulnType.FILE_ACCESS): ("enables", 0.6),
            
            # Path traversal to file access to credential leak
            (VulnType.PATH_TRAVERSAL, VulnType.FILE_ACCESS): ("enables", 0.9),
            (VulnType.FILE_ACCESS, VulnType.CREDENTIAL_LEAK): ("enables", 0.7),
            (VulnType.FILE_ACCESS, VulnType.INFO_DISCLOSURE): ("enables", 0.8),
            
            # XXE chains
            (VulnType.XXE, VulnType.SSRF): ("enables", 0.8),
            (VulnType.XXE, VulnType.FILE_ACCESS): ("enables", 0.9),
            (VulnType.XXE, VulnType.INFO_DISCLOSURE): ("enables", 0.9),
            
            # Deserialization to RCE
            (VulnType.DESERIALIZATION, VulnType.RCE): ("enables", 0.8),
            
            # XSS chains
            (VulnType.XSS, VulnType.CREDENTIAL_LEAK): ("enables", 0.6),
            (VulnType.XSS, VulnType.AUTH_BYPASS): ("enables", 0.5),
            
            # Misconfig enables many things
            (VulnType.MISCONFIG, VulnType.INFO_DISCLOSURE): ("enables", 0.7),
            (VulnType.MISCONFIG, VulnType.AUTH_BYPASS): ("enables", 0.5),
            
            # Open redirect for phishing/token theft
            (VulnType.OPEN_REDIRECT, VulnType.CREDENTIAL_LEAK): ("enables", 0.4),
        }
        
        # Asset-based relationships
        self.asset_chains = {
            # If you have access to X, you can potentially get Y
            AssetType.WEB_SERVER: [AssetType.FILE_SYSTEM, AssetType.DATABASE],
            AssetType.DATABASE: [AssetType.CREDENTIALS, AssetType.USER_DATA],
            AssetType.INTERNAL_SERVICE: [AssetType.DATABASE, AssetType.CLOUD_METADATA],
            AssetType.CLOUD_METADATA: [AssetType.CREDENTIALS, AssetType.INTERNAL_SERVICE],
            AssetType.CREDENTIALS: [AssetType.ADMIN_PANEL, AssetType.DATABASE],
            AssetType.FILE_SYSTEM: [AssetType.CREDENTIALS, AssetType.USER_DATA],
        }
    
    def analyze_relationship(self, vuln1: Vulnerability, 
                            vuln2: Vulnerability) -> Optional[AttackEdge]:
        """Analyze if there's a relationship between two vulnerabilities"""
        # Check type-based relationship
        type_key = (vuln1.vuln_type, vuln2.vuln_type)
        if type_key in self.type_relationships:
            relationship, probability = self.type_relationships[type_key]
            
            # Adjust probability based on complexity
            if vuln2.exploit_complexity == "high":
                probability *= 0.7
            elif vuln2.exploit_complexity == "medium":
                probability *= 0.85
            
            # Adjust for auth requirements
            if vuln2.requires_auth and not any(
                asset in vuln1.provides_access_to 
                for asset in [AssetType.CREDENTIALS, AssetType.ADMIN_PANEL]
            ):
                probability *= 0.5
            
            return AttackEdge(
                source_vuln_id=vuln1.id,
                target_vuln_id=vuln2.id,
                relationship=relationship,
                probability=probability,
                description=f"{vuln1.vuln_type.value} {relationship} {vuln2.vuln_type.value}"
            )
        
        # Check asset-based relationship
        for asset in vuln1.provides_access_to:
            if asset in self.asset_chains:
                required_assets = vuln2.requires_access_to
                if any(ra in self.asset_chains[asset] for ra in required_assets):
                    return AttackEdge(
                        source_vuln_id=vuln1.id,
                        target_vuln_id=vuln2.id,
                        relationship="enables_via_asset",
                        probability=0.6,
                        description=f"Access to {asset.value} enables {vuln2.name}"
                    )
        
        # Check endpoint-based pivot
        if vuln2.endpoint in vuln1.can_pivot_to:
            return AttackEdge(
                source_vuln_id=vuln1.id,
                target_vuln_id=vuln2.id,
                relationship="pivots_to",
                probability=0.7,
                description=f"Can pivot from {vuln1.endpoint} to {vuln2.endpoint}"
            )
        
        return None


class AttackGraphBuilder:
    """Builds attack graphs from vulnerabilities"""
    
    def __init__(self):
        self.relationship_analyzer = VulnerabilityRelationshipAnalyzer()
        
        # Graph structure
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.edges: List[AttackEdge] = []
        self.adjacency: Dict[str, List[AttackEdge]] = defaultdict(list)
        
        # Entry points (vulns that don't require prior access)
        self.entry_points: Set[str] = set()
        
        # High-value targets (RCE, credential access, etc.)
        self.high_value_targets: Set[str] = set()
    
    def add_vulnerability(self, vuln: Vulnerability):
        """Add a vulnerability to the graph"""
        self.vulnerabilities[vuln.id] = vuln
        
        # Check if it's an entry point
        if not vuln.requires_auth and not vuln.requires_access_to:
            self.entry_points.add(vuln.id)
        
        # Check if it's a high-value target
        if vuln.vuln_type in [VulnType.RCE, VulnType.PRIVILEGE_ESCALATION]:
            self.high_value_targets.add(vuln.id)
        if AssetType.CREDENTIALS in vuln.provides_access_to:
            self.high_value_targets.add(vuln.id)
        if AssetType.DATABASE in vuln.provides_access_to:
            self.high_value_targets.add(vuln.id)
        
        # Analyze relationships with existing vulnerabilities
        for existing_id, existing_vuln in self.vulnerabilities.items():
            if existing_id == vuln.id:
                continue
            
            # Check vuln -> existing relationship
            edge = self.relationship_analyzer.analyze_relationship(vuln, existing_vuln)
            if edge:
                self.edges.append(edge)
                self.adjacency[vuln.id].append(edge)
            
            # Check existing -> vuln relationship
            edge = self.relationship_analyzer.analyze_relationship(existing_vuln, vuln)
            if edge:
                self.edges.append(edge)
                self.adjacency[existing_id].append(edge)
    
    def build_from_findings(self, findings: List[Dict]) -> int:
        """Build graph from scan findings"""
        count = 0
        
        for finding in findings:
            vuln = self._finding_to_vulnerability(finding)
            if vuln:
                self.add_vulnerability(vuln)
                count += 1
        
        logger.info(f"Built attack graph with {count} vulnerabilities and {len(self.edges)} edges")
        return count
    
    def _finding_to_vulnerability(self, finding: Dict) -> Optional[Vulnerability]:
        """Convert a scan finding to a Vulnerability object"""
        try:
            # Map finding type to VulnType
            vuln_type = self._map_vuln_type(finding.get('type', ''))
            if not vuln_type:
                return None
            
            vuln_id = finding.get('id') or hashlib.md5(
                json.dumps(finding, sort_keys=True).encode()
            ).hexdigest()[:12]
            
            vuln = Vulnerability(
                id=vuln_id,
                vuln_type=vuln_type,
                name=finding.get('title', finding.get('type', 'Unknown')),
                description=finding.get('description', ''),
                severity=finding.get('severity', finding.get('cvss_score', 5.0)),
                endpoint=finding.get('url', finding.get('endpoint', '')),
                parameter=finding.get('parameter'),
                evidence=finding.get('evidence'),
                exploit_complexity=finding.get('complexity', 'low'),
                requires_auth=finding.get('requires_auth', False)
            )
            
            # Set provides/requires based on type
            self._set_asset_relationships(vuln)
            
            return vuln
            
        except Exception as e:
            logger.error(f"Error converting finding to vulnerability: {e}")
            return None
    
    def _map_vuln_type(self, type_str: str) -> Optional[VulnType]:
        """Map string type to VulnType enum"""
        type_lower = type_str.lower()
        
        mappings = {
            'sql': VulnType.INJECTION,
            'sqli': VulnType.INJECTION,
            'injection': VulnType.INJECTION,
            'command': VulnType.INJECTION,
            'xss': VulnType.XSS,
            'cross-site': VulnType.XSS,
            'ssrf': VulnType.SSRF,
            'server-side request': VulnType.SSRF,
            'auth': VulnType.AUTH_BYPASS,
            'bypass': VulnType.AUTH_BYPASS,
            'info': VulnType.INFO_DISCLOSURE,
            'disclosure': VulnType.INFO_DISCLOSURE,
            'sensitive': VulnType.INFO_DISCLOSURE,
            'rce': VulnType.RCE,
            'remote code': VulnType.RCE,
            'command execution': VulnType.RCE,
            'lfi': VulnType.FILE_ACCESS,
            'file inclusion': VulnType.FILE_ACCESS,
            'file read': VulnType.FILE_ACCESS,
            'path traversal': VulnType.PATH_TRAVERSAL,
            'directory traversal': VulnType.PATH_TRAVERSAL,
            'xxe': VulnType.XXE,
            'xml external': VulnType.XXE,
            'deserialization': VulnType.DESERIALIZATION,
            'privesc': VulnType.PRIVILEGE_ESCALATION,
            'privilege': VulnType.PRIVILEGE_ESCALATION,
            'credential': VulnType.CREDENTIAL_LEAK,
            'password': VulnType.CREDENTIAL_LEAK,
            'misconfig': VulnType.MISCONFIG,
            'misconfiguration': VulnType.MISCONFIG,
            'redirect': VulnType.OPEN_REDIRECT,
        }
        
        for key, vuln_type in mappings.items():
            if key in type_lower:
                return vuln_type
        
        return None
    
    def _set_asset_relationships(self, vuln: Vulnerability):
        """Set asset relationships based on vulnerability type"""
        type_assets = {
            VulnType.SSRF: {
                'provides': [AssetType.INTERNAL_SERVICE, AssetType.CLOUD_METADATA],
                'requires': []
            },
            VulnType.INJECTION: {
                'provides': [AssetType.DATABASE, AssetType.USER_DATA],
                'requires': []
            },
            VulnType.FILE_ACCESS: {
                'provides': [AssetType.FILE_SYSTEM, AssetType.CREDENTIALS],
                'requires': []
            },
            VulnType.PATH_TRAVERSAL: {
                'provides': [AssetType.FILE_SYSTEM],
                'requires': []
            },
            VulnType.RCE: {
                'provides': [AssetType.WEB_SERVER, AssetType.FILE_SYSTEM, AssetType.NETWORK],
                'requires': []
            },
            VulnType.CREDENTIAL_LEAK: {
                'provides': [AssetType.CREDENTIALS],
                'requires': []
            },
            VulnType.AUTH_BYPASS: {
                'provides': [AssetType.ADMIN_PANEL],
                'requires': []
            },
            VulnType.XXE: {
                'provides': [AssetType.FILE_SYSTEM, AssetType.INTERNAL_SERVICE],
                'requires': []
            },
        }
        
        if vuln.vuln_type in type_assets:
            assets = type_assets[vuln.vuln_type]
            vuln.provides_access_to = assets['provides']
            vuln.requires_access_to = assets['requires']
    
    def get_graph_stats(self) -> Dict[str, Any]:
        """Get statistics about the attack graph"""
        return {
            'total_vulnerabilities': len(self.vulnerabilities),
            'total_edges': len(self.edges),
            'entry_points': len(self.entry_points),
            'high_value_targets': len(self.high_value_targets),
            'vuln_types': {
                vtype.value: len([v for v in self.vulnerabilities.values() 
                                 if v.vuln_type == vtype])
                for vtype in VulnType
            }
        }


class AttackChainFinder:
    """Finds optimal attack chains in the attack graph"""
    
    def __init__(self, graph: AttackGraphBuilder):
        self.graph = graph
    
    def find_all_chains(self, max_length: int = 5, 
                       min_probability: float = 0.3) -> List[AttackChain]:
        """Find all viable attack chains"""
        chains = []
        
        # Start from each entry point
        for entry_id in self.graph.entry_points:
            found_chains = self._find_chains_from(
                entry_id, 
                max_length=max_length,
                min_probability=min_probability
            )
            chains.extend(found_chains)
        
        # Sort by effectiveness (severity * probability)
        chains.sort()
        
        return chains
    
    def find_chains_to_target(self, target_vuln_id: str,
                             max_length: int = 5) -> List[AttackChain]:
        """Find all chains leading to a specific high-value target"""
        chains = []
        
        for entry_id in self.graph.entry_points:
            found_chains = self._find_chains_from(
                entry_id,
                target_id=target_vuln_id,
                max_length=max_length
            )
            chains.extend(found_chains)
        
        chains.sort()
        return chains
    
    def find_highest_impact_chain(self) -> Optional[AttackChain]:
        """Find the single highest impact attack chain"""
        best_chain = None
        best_score = 0
        
        for target_id in self.graph.high_value_targets:
            chains = self.find_chains_to_target(target_id)
            for chain in chains:
                score = chain.total_severity * chain.success_probability
                if score > best_score:
                    best_score = score
                    best_chain = chain
        
        return best_chain
    
    def _find_chains_from(self, start_id: str, target_id: str = None,
                         max_length: int = 5, min_probability: float = 0.3,
                         current_path: List[str] = None,
                         current_probability: float = 1.0) -> List[AttackChain]:
        """Recursively find chains from a starting vulnerability"""
        if current_path is None:
            current_path = []
        
        # Check termination conditions
        if len(current_path) >= max_length:
            return []
        
        if current_probability < min_probability:
            return []
        
        if start_id in current_path:  # Avoid cycles
            return []
        
        current_path = current_path + [start_id]
        chains = []
        
        # If we reached the target, create a chain
        if target_id and start_id == target_id:
            chain = self._create_chain(current_path, current_probability)
            if chain:
                chains.append(chain)
            return chains
        
        # If this is a high-value target and no specific target, create chain
        if not target_id and start_id in self.graph.high_value_targets:
            chain = self._create_chain(current_path, current_probability)
            if chain:
                chains.append(chain)
        
        # Continue exploring
        for edge in self.graph.adjacency.get(start_id, []):
            new_probability = current_probability * edge.probability
            
            sub_chains = self._find_chains_from(
                edge.target_vuln_id,
                target_id=target_id,
                max_length=max_length,
                min_probability=min_probability,
                current_path=current_path,
                current_probability=new_probability
            )
            chains.extend(sub_chains)
        
        return chains
    
    def _create_chain(self, vuln_ids: List[str], probability: float) -> Optional[AttackChain]:
        """Create an AttackChain from a list of vulnerability IDs"""
        if not vuln_ids:
            return None
        
        vulns = [self.graph.vulnerabilities[vid] for vid in vuln_ids]
        
        # Calculate total severity (consider diminishing returns)
        total_severity = 0
        for i, vuln in enumerate(vulns):
            # Later vulns in chain get slightly less weight
            weight = 1.0 / (1 + i * 0.1)
            total_severity += vuln.severity * weight
        
        # Normalize
        total_severity = min(10.0, total_severity)
        
        # Determine final impact
        final_vuln = vulns[-1]
        final_impact = self._determine_impact(final_vuln)
        
        # Generate steps
        steps = self._generate_steps(vulns)
        
        # Create description
        description = " â†’ ".join([v.name for v in vulns])
        
        chain_id = hashlib.md5("_".join(vuln_ids).encode()).hexdigest()[:12]
        
        return AttackChain(
            id=chain_id,
            vulnerabilities=vuln_ids,
            total_severity=total_severity,
            success_probability=probability,
            final_impact=final_impact,
            description=description,
            steps=steps
        )
    
    def _determine_impact(self, vuln: Vulnerability) -> str:
        """Determine the final impact of exploiting a vulnerability"""
        impacts = []
        
        if vuln.vuln_type == VulnType.RCE:
            impacts.append("Remote Code Execution")
        if vuln.vuln_type == VulnType.CREDENTIAL_LEAK:
            impacts.append("Credential Compromise")
        if AssetType.DATABASE in vuln.provides_access_to:
            impacts.append("Database Access")
        if AssetType.CREDENTIALS in vuln.provides_access_to:
            impacts.append("Credential Access")
        if AssetType.ADMIN_PANEL in vuln.provides_access_to:
            impacts.append("Admin Access")
        
        return ", ".join(impacts) if impacts else "System Compromise"
    
    def _generate_steps(self, vulns: List[Vulnerability]) -> List[Dict[str, Any]]:
        """Generate exploitation steps for a chain"""
        steps = []
        
        for i, vuln in enumerate(vulns):
            step = {
                'step_number': i + 1,
                'vulnerability': vuln.name,
                'type': vuln.vuln_type.value,
                'target': vuln.endpoint,
                'action': self._get_exploitation_action(vuln),
                'expected_outcome': self._get_expected_outcome(vuln),
                'complexity': vuln.exploit_complexity
            }
            
            if vuln.parameter:
                step['parameter'] = vuln.parameter
            
            steps.append(step)
        
        return steps
    
    def _get_exploitation_action(self, vuln: Vulnerability) -> str:
        """Get the exploitation action for a vulnerability"""
        actions = {
            VulnType.INJECTION: "Inject malicious payload to extract data or execute commands",
            VulnType.SSRF: "Craft SSRF payload to access internal resources",
            VulnType.XSS: "Inject JavaScript to steal credentials or session",
            VulnType.FILE_ACCESS: "Access sensitive files on the server",
            VulnType.PATH_TRAVERSAL: "Traverse directories to access restricted files",
            VulnType.RCE: "Execute arbitrary commands on the server",
            VulnType.AUTH_BYPASS: "Bypass authentication to gain unauthorized access",
            VulnType.CREDENTIAL_LEAK: "Extract leaked credentials",
            VulnType.XXE: "Exploit XML parsing to read files or make requests",
            VulnType.DESERIALIZATION: "Exploit unsafe deserialization for code execution",
            VulnType.PRIVILEGE_ESCALATION: "Escalate privileges to higher access level",
        }
        return actions.get(vuln.vuln_type, "Exploit vulnerability")
    
    def _get_expected_outcome(self, vuln: Vulnerability) -> str:
        """Get expected outcome of exploiting a vulnerability"""
        outcomes = []
        
        for asset in vuln.provides_access_to:
            outcomes.append(f"Access to {asset.value}")
        
        return ", ".join(outcomes) if outcomes else "Successful exploitation"


class VulnerabilityChainEngine:
    """
    Main engine for vulnerability chaining
    
    Coordinates attack graph building, chain finding, and execution planning
    """
    
    def __init__(self, memory_system=None):
        self.memory_system = memory_system
        self.graph = AttackGraphBuilder()
        self.chain_finder = None
        
        # Discovered chains
        self.discovered_chains: List[AttackChain] = []
        
        # Chain execution history
        self.execution_history: List[Dict] = []
        
        logger.info("Vulnerability Chain Engine initialized")
    
    def analyze_findings(self, findings: List[Dict]) -> Dict[str, Any]:
        """
        Analyze findings and build attack chains
        
        Args:
            findings: List of vulnerability findings from scanning
            
        Returns:
            Analysis results including chains found
        """
        # Build attack graph
        vuln_count = self.graph.build_from_findings(findings)
        
        # Initialize chain finder
        self.chain_finder = AttackChainFinder(self.graph)
        
        # Find all chains
        self.discovered_chains = self.chain_finder.find_all_chains()
        
        # Find highest impact chain
        best_chain = self.chain_finder.find_highest_impact_chain()
        
        # Get graph stats
        stats = self.graph.get_graph_stats()
        
        result = {
            'vulnerabilities_analyzed': vuln_count,
            'graph_stats': stats,
            'chains_found': len(self.discovered_chains),
            'top_chains': [self._chain_to_dict(c) for c in self.discovered_chains[:5]],
            'highest_impact_chain': self._chain_to_dict(best_chain) if best_chain else None,
            'entry_points': list(self.graph.entry_points),
            'high_value_targets': list(self.graph.high_value_targets)
        }
        
        # Store chains in memory if available
        if self.memory_system and self.discovered_chains:
            self._store_chains_in_memory()
        
        return result
    
    def get_exploitation_plan(self, chain_id: str = None) -> Optional[Dict]:
        """
        Get detailed exploitation plan for a chain
        
        Args:
            chain_id: ID of chain to plan, or None for best chain
        """
        if chain_id:
            chain = next((c for c in self.discovered_chains if c.id == chain_id), None)
        else:
            chain = self.chain_finder.find_highest_impact_chain() if self.chain_finder else None
        
        if not chain:
            return None
        
        plan = {
            'chain_id': chain.id,
            'description': chain.description,
            'final_impact': chain.final_impact,
            'success_probability': chain.success_probability,
            'total_severity': chain.total_severity,
            'steps': [],
            'prerequisites': [],
            'recommendations': []
        }
        
        # Detailed steps
        for i, vuln_id in enumerate(chain.vulnerabilities):
            vuln = self.graph.vulnerabilities.get(vuln_id)
            if not vuln:
                continue
            
            step = {
                'step': i + 1,
                'vulnerability': vuln.name,
                'type': vuln.vuln_type.value,
                'target': vuln.endpoint,
                'severity': vuln.severity,
                'complexity': vuln.exploit_complexity,
                'tools': self._get_recommended_tools(vuln),
                'payloads': self._get_sample_payloads(vuln),
                'verification': self._get_verification_method(vuln),
                'fallback': self._get_fallback_approach(vuln)
            }
            
            plan['steps'].append(step)
        
        # Add prerequisites
        if chain.vulnerabilities:
            first_vuln = self.graph.vulnerabilities.get(chain.vulnerabilities[0])
            if first_vuln and first_vuln.requires_auth:
                plan['prerequisites'].append("Authentication required for initial access")
        
        # Add recommendations
        plan['recommendations'] = self._generate_recommendations(chain)
        
        return plan
    
    def find_chains_for_asset(self, asset_type: str) -> List[Dict]:
        """Find chains that provide access to a specific asset type"""
        try:
            target_asset = AssetType(asset_type)
        except ValueError:
            return []
        
        matching_chains = []
        
        for chain in self.discovered_chains:
            final_vuln_id = chain.vulnerabilities[-1]
            final_vuln = self.graph.vulnerabilities.get(final_vuln_id)
            
            if final_vuln and target_asset in final_vuln.provides_access_to:
                matching_chains.append(self._chain_to_dict(chain))
        
        return matching_chains
    
    def record_chain_execution(self, chain_id: str, success: bool,
                              notes: str = None):
        """Record the result of executing a chain"""
        record = {
            'chain_id': chain_id,
            'timestamp': datetime.now().isoformat(),
            'success': success,
            'notes': notes
        }
        
        self.execution_history.append(record)
        
        # Update memory if available
        if self.memory_system:
            chain = next((c for c in self.discovered_chains if c.id == chain_id), None)
            if chain:
                self.memory_system.store_vuln_chain(
                    chain_steps=[
                        {'vuln_id': vid, 'vuln_name': self.graph.vulnerabilities.get(vid, {}).name}
                        for vid in chain.vulnerabilities
                    ],
                    initial_vuln=chain.vulnerabilities[0] if chain.vulnerabilities else '',
                    final_impact=chain.final_impact,
                    success=success,
                    target_type='web',  # Would need context
                    technology_stack=[]  # Would need context
                )
    
    def _chain_to_dict(self, chain: AttackChain) -> Dict:
        """Convert AttackChain to dictionary"""
        return {
            'id': chain.id,
            'vulnerabilities': chain.vulnerabilities,
            'description': chain.description,
            'total_severity': chain.total_severity,
            'success_probability': chain.success_probability,
            'final_impact': chain.final_impact,
            'steps': chain.steps
        }
    
    def _get_recommended_tools(self, vuln: Vulnerability) -> List[str]:
        """Get recommended tools for exploiting a vulnerability"""
        tool_mapping = {
            VulnType.INJECTION: ['sqlmap', 'commix', 'nosqlmap'],
            VulnType.XSS: ['xsstrike', 'dalfox', 'xsser'],
            VulnType.SSRF: ['ssrfmap', 'gopherus'],
            VulnType.FILE_ACCESS: ['ffuf', 'dotdotpwn'],
            VulnType.PATH_TRAVERSAL: ['dotdotpwn', 'ffuf'],
            VulnType.XXE: ['xxeinjector'],
            VulnType.DESERIALIZATION: ['ysoserial', 'marshalsec'],
            VulnType.RCE: ['metasploit', 'reverse-shell-generator'],
        }
        return tool_mapping.get(vuln.vuln_type, ['manual testing'])
    
    def _get_sample_payloads(self, vuln: Vulnerability) -> List[str]:
        """Get sample payloads for a vulnerability type"""
        payloads = {
            VulnType.INJECTION: ["' OR '1'='1", "1; SELECT * FROM users--"],
            VulnType.XSS: ["<script>alert(1)</script>", "<img onerror=alert(1) src=x>"],
            VulnType.SSRF: ["http://169.254.169.254/latest/meta-data/", "http://localhost:6379/"],
            VulnType.PATH_TRAVERSAL: ["../../../etc/passwd", "....//....//etc/passwd"],
            VulnType.XXE: ['<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>'],
        }
        return payloads.get(vuln.vuln_type, [])
    
    def _get_verification_method(self, vuln: Vulnerability) -> str:
        """Get verification method for successful exploitation"""
        verifications = {
            VulnType.INJECTION: "Data extraction or error-based confirmation",
            VulnType.XSS: "JavaScript execution or DOM modification",
            VulnType.SSRF: "Response from internal resource",
            VulnType.FILE_ACCESS: "File contents in response",
            VulnType.RCE: "Command output or reverse shell connection",
            VulnType.CREDENTIAL_LEAK: "Valid credentials obtained",
        }
        return verifications.get(vuln.vuln_type, "Successful exploitation confirmed")
    
    def _get_fallback_approach(self, vuln: Vulnerability) -> str:
        """Get fallback approach if primary exploitation fails"""
        fallbacks = {
            VulnType.INJECTION: "Try blind injection techniques or time-based detection",
            VulnType.XSS: "Try different encoding or context-specific payloads",
            VulnType.SSRF: "Try different protocols (gopher, dict) or bypass filters",
            VulnType.FILE_ACCESS: "Try encoding bypass or null byte injection",
        }
        return fallbacks.get(vuln.vuln_type, "Try alternative exploitation vectors")
    
    def _generate_recommendations(self, chain: AttackChain) -> List[str]:
        """Generate recommendations for chain exploitation"""
        recommendations = []
        
        if chain.success_probability < 0.5:
            recommendations.append(
                "Low success probability - consider manual verification before automated exploitation"
            )
        
        if len(chain.vulnerabilities) > 3:
            recommendations.append(
                "Long chain - each step increases risk of detection, consider breaking into phases"
            )
        
        # Check for high-complexity steps
        for step in chain.steps:
            if step.get('complexity') == 'high':
                recommendations.append(
                    f"Step {step.get('step_number')} has high complexity - allocate extra time"
                )
        
        recommendations.append(
            "Document each step's output for the final report"
        )
        
        return recommendations
    
    def _store_chains_in_memory(self):
        """Store discovered chains in long-term memory"""
        if not self.memory_system:
            return
        
        for chain in self.discovered_chains[:10]:  # Top 10 chains
            self.memory_system.store_memory(
                memory_type='attack_chain',
                content={
                    'chain_id': chain.id,
                    'vulnerabilities': chain.vulnerabilities,
                    'description': chain.description,
                    'final_impact': chain.final_impact,
                    'severity': chain.total_severity
                },
                tags=['chain', chain.final_impact.lower().replace(' ', '_')],
                importance=min(1.0, chain.total_severity / 10)
            )


# Singleton instance
_chain_engine = None

def get_chain_engine(memory_system=None) -> VulnerabilityChainEngine:
    """Get the singleton vulnerability chain engine"""
    global _chain_engine
    if _chain_engine is None:
        _chain_engine = VulnerabilityChainEngine(memory_system)
    return _chain_engine
